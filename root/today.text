
Paper deadlines:
AAAI: 10Sep14-abstract, 15Sep14-final paper (conference 25-29Jan15 Austin, TX)
ICRA: 15Sep14-abstract, 12Feb15-final paper (conference 25-30May15, Seattle, WA) 
      (last conference 31May-5June14, paper deadline was 16Sep13)
IROS: 18Feb15-abstract, 8Jul15-final paper (conference 28Sep-2Oct15, Hamburg, Germany)
      (last conference 14-18Sep14, paper deadline was 6Feb14)


Old notes
--------------------------
13 Mar 14
-- Discovered that 1. Raw PGR images are 1/4 the size of BGRU-converted PGR (and Imlib) images, 2. Raw PGR images can be converted to BGR (vice BGRU) for a 25% reduction in size);
-- Looking into sending raw PGR images across network, but first need to have flycapture libraries installed on seykhl in order to reconstruct the PGR image and convert it to color (specifically need PGR Image class, along with PixelFormat and BayerTileFormat data types);
-- Got 4g dongle working--comes up as eth0 automatically, then must call 'dhclient eth0' to get local IP, should be set to connect to internet automatically now, but if not, use 'wget -T 30 http://192.168.32.2/condata?action=connect';
-- Generic USB Wifi dongle "sort-of" working--causes crashes after sustained data transfer.  Need to look at how it's set up.  Added lines for wlan2 in /etc/network/interfaces;
-- try UDP sockets instead of TCP for less overhead??

14 Mar 14
-- started on sending the raw PGR image across the network piece by piece...need to finish receiver and test

17 Mar 14
-- First test of sending raw images across network successful, images saved via PGR methods as color PPM.  Getting ~1.2-1.3 frames/sec/cam.
-- Need to look into ways to speed up transfer to the 5-8 f/s/c range (possibly compression, alternate wifi, ???)
-- First effort at using TP-LINK TL-W822N USB Wifi adapter. Driver installed and works, but still need to have it come up automatically on boot. First test of transfer gets ~2.9 f/s/c. Getting same 'task crda blocked' message as with other USB Wifi--not sure if I can just ignore it

18 Mar 14
-- apt-get install libnl1 libnl-dev
-- changed /sys/module/cfg80211/parameters/ieee80211_regdom from '00' to 'US' using 'cat US >> ...' in an attempt to try to fix crda error message -- FILE NOT IN GIT
------
-- changing of /sys/module/cfg80211/parameters/ieee80211_regdom did not work--file gets rewritten at boot
-- attempting to uninstall crda, wireless-crda, wireless-regdb to fix
   apt-get purge crda wireless-crda wireless-regdb
-- purge of crda/regdb seemed to work
-- still having issues with USB port quitting after a certain amount of time (non-deterministic)
-- added 'modprobe g_multi' to /etc/init.d/gpio-monitor.sh to load module needed to enable USB OTG port as second USB
------
-- Modified CustomImageEx.cpp with methods to just transfer image data on first image to see if it speeds things up...still need to finish work on camera-server.cpp to get it to break out of fork before we can see if it speeds things up or not

19 Mar 14
-- Commit before incorporating miniz.c compression
-- Noticed some issues with USB OTG port when cameras were connected to it--sometimes gave error 'musb_host_rx 1625: Rx interrupt with no errors or packet!' which would cause image capture to stop.  Couldn't find an easy workaround, so went back to putting cameras and wifi in main USB port.
-- Finished mod of camera-server.cpp to break out of forked receive process when no image data received--no significant speedup.
-------
-- Testing of miniz.c compression showed it to be worse than just sending uncompressed images via wifi (~0.5 f/s/c to get miniz-compressed data vs. ~3.5 f/s/c for uncompressed data over 802.11n or ~1.2 f/s/c for 802.11g)
-- Now trying 'snappy' from Google

20 Mar 14
-- attempted setting non-blocking send sockets with fcntl--improved speed, but got garbled images on workstation end...maybe need to adapt recv calls?
-- UDP (DGRAM) sockets might be a possibility, but would require a complete refiguring of the send/receive code.
-- ***Got framerate to ~8 f/s/c (close to rate at which cameras produce) by 1) changing save location on seykhl to /aux vice /home, and 2) changing pano cam to 640x480 greyscale.   If pano cam stays at 1240x934 color, framerate ~4.75 f/s/c
----------------
-- Removed g_multi.ko load from gpio-monitor.sh and added it to g-multi.sh with priority 01
----------------
-- Tested snappy compression -- results in a 10-15% reduction in buffer size, currently a bug with Send/ReceiveMetadataCompressed

21 Mar 14
-- Got connected to PAL3.0 with changes to /etc/network/interfaces and /etc/wpa_supplicant.conf
-- Checked raw frame rate (w/o sending)--seemed to top out around 17 fps, set it to 15 fps
-- Experimented with putting one of the cameras onto the secondary USB of the gumstix, but the fastest capture rate was with both cameras and the wifi adapter plugged into the main USB
-- Still need to look into compressing data prior to sending across network
-----------
-- Started work on using jpeg-compressor from Google, but haven't gotten it to work yet.

31 Mar 14
-- Got jpeg-compressor working. Getting good compression ratios (~95-97%), but at the cost of framerate--w/o compression, getting 15 f/s/c, with compression < 1 f/s/c.  Working on improving that.
-- Switched pano cam back to greyscale by calling PGR_SetCameraNEW from within PGR_StartCameras.  Now Gumstix can produce ~17-24 f/s/c without compression.
-- After testing jpeg-compressor using only 640x480 images, best framerate was about 2.5 f/s/c, regardless of parameters settings.
-- Installed OpenCV based on http://docs.opencv.org/doc/tutorials/introduction/linux_install/linux_install.html#linux-installation

1 Apr 14
-- Got OpenCV working with PGR images to encode in memory and checked via decoding and saving.  Next need to work on sending across network.
(test jpeg-compressor on workstation -- compiles then crashes on workstation, won't compile on laptop)

2 Apr 14
-- Got images sending across network.  With JPEG compression set at 50 (range 0-100), can get images across network as fast as Gumstix can produce them (~9.5-11.5 f/s/c).  With JPEG compression at default (95), Gumstix produces images ~8.6 f/s/c, sends ~6.5-7 f/s/c.
-- Changed PGR_GetFrame() and OpenCV_CompressFrame() to differentiate between 3-channel color images from front cam and 1-channel grayscale images from pano cam--now getting ~13 f/s/c across network with quality at 75, ~14 f/s/c with quality at 50.
-- Saving across network is working (quality = 75) at ~11.9-12.5 f/s/c.  Can save as either .jpg or .png, doesn't seem to affect speed
(first attempt at libjpeg-turbo/OpenCV install: cmake -DENABLE_VFPV3=ON -DENABLE_NEON=ON -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. )

3 Apr 14
-- Attempted to install libjpeg-turbo then recompile/reinstall OpenCV with NEON and VFPv3 enabled.  Loosely followed instructions at http://blog.lemoneerlabs.com/3rdParty/Darling_BBB_30fps_DRAFT.html#XMatthew_cvdecode and https://github.com/aumuell/libjpeg-turbo/blob/master/BUILDING.txt
-- apt-get install g++-4.6-multilib g++-multilib gcc-4.6-multilib gcc-multilib (used to attempt to get past libjpeg-turbo configure error--not sure if needed)
-- Downloaded libjpeg-turbo-1.3.0 from http://sourceforge.net/projects/libjpeg-turbo/files/1.3.0/libjpeg-turbo-1.3.0.tar.gz
-- Went to libjpeg-turbo-1.3.0/build and ran:
   ../configure CPPFLAGS='-O3 -march=armv7-a -mcpu=cortex-a8 -mtune=cortex-a8 -mfpu=neon -mfloat-abi=hard -fPIC'
   make
   make install prefix=/usr/local libdir=/usr/local/lib
   make install

   	Output:
	----------------------------------------------------------------------
	Libraries have been installed in:
	   /opt/libjpeg-turbo/lib
	   (/usr/local/lib)

	   If you ever happen to want to link against installed libraries
	   in a given directory, LIBDIR, you must either use libtool, and
	   specify the full pathname of the library, or use the `-LLIBDIR'
	   flag during linking and do at least one of the following:
	      - add LIBDIR to the `LD_LIBRARY_PATH' environment variable
	      	during execution
	      - add LIBDIR to the `LD_RUN_PATH' environment variable
                during linking
	      - use the `-Wl,--rpath -Wl,LIBDIR' linker flag
   	      - have your system administrator add LIBDIR to `/etc/ld.so.conf'

	See any operating system documentation about shared libraries for
	more information, such as the ld(1) and ld.so(8) manual pages.
	 ---------------------------------------------------------------------- 
-- Then went to ~/opencv-2.4.8/release and ran:
     cmake -D CMAKE_C_FLAGS='-O3 -march=armv7-a -mcpu=cortex-a8 -mtune=cortex-a8 \
     -mfpu=neon -mfloat-abi=hard -fPIC' -D CMAKE_CXX_FLAGS='-O3 -march=armv7-a \
     -mcpu=cortex-a8 -mtune=cortex-a8 -mfpu=neon -mfloat-abi=hard -fPIC' \
     -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local \
     -D BUILD_PYTHON_SUPPORT=ON -DWITH_JPEG=ON -DBUILD_JPEG=OFF \
     -DJPEG_INCLUDE_DIR=/usr/local/include/ \
     -DJPEG_LIBRARY=/usr/local/lib/libjpeg.a -DUSE_VFPV3=ON -DUSE_NEON=ON \
     -DENABLE_VFPV3=ON -DENABLE_NEON=ON .. 
     make
     make install
-- When complete, did a make clean and then make on CustomImageEx.cpp.  Did not see any improvment in OpenCV compression speed (~12 f/s/c with compression on, ~17-24 f/s/c with compression off).
-- Have machine shop working on mounting brace for USB wifi adapter

4 Apr 14
-- apt-get install libv4l-dev v4l-utils qv4l2 v4l2ucp
-- Installed mounting brace for USB wifi adapter from machine shop

14 Apr 14
--Moved code for monitor and motor_control from ~/test_code/ to ~/source/*. Put symlinks to headers in ~/include. Have executables in ~/bin.  Created makefiles for each to automate compilation.
------
--Moved CustomImageEx to ~/source/camera and broke it into toollib-camera.cpp/h and run-cameras.cpp.  Reconfigured Makefile to make run_cameras executable and put it int ~/bin.  Committing here prior to massive rework of run-cameras.cpp and cleanup of toollib-camera.cpp.
--Also moved Flycapture includes from ~/test_code/flycapture/include to ~/include, and libs from ~/test_code/flycapture/lib to ~/lib (with symlinks in /usr/local/lib.
-------
--Cleaned up toollib-camera.cpp/h
--Reconfigured run_cameras to use an infinite loop for capturing.  Killing the process with Ctrl-C doesn't seem to do any harm (so far), but I will still work on implementing a signal handler so that the PGR_StopAndCleanup() function can get called before exit.

15 Apr 14
--Implemented signal handler in run_cameras.cpp.  Can now exit cleanly from by sending 'pkill run_cameras' either locally or over ssh.

17 Apr 14
--Switched over to backup gumstix in an effort to troubleshoot USB EMI failure.  All external systems functional after switchover.  Also changed USB cable running between gumstix and hub from one that I had shorted to an uncut cable.
--Testing camera transmission to see if/when USB fails:
	  Internal wifi on qobi-office:  ran for ~48 minutes until battery died (intermittent whole-system pauses/hangs...but images resume after ~5 sec or less)
	  Internal wifi on PAL: ran for 29 minutes until I stopped the test to do a driving test (did not notice the hangs above)
	  USB wifi on qobi-office: (skipped these and went to drive testing)
	  USB wifi on PAL: (skipped these and went to drive testing)
  ***Did not see USB EMI failure after over an hour and a half of operation (split between 2 tests due to a reboot for a battery change)
-- 40-pin header configuration:
   5 = right encoder yellow	
   6 = right encoder green
   7 = left encoder yellow
   8 = left encoder green
   10 = motors
   15 = GND (with 16)
   16 = VCC 1.8V to level shifters (with 15)
   23 = Rear bump GPIO 184 RED (with 24)
   24 = Front bump GPIO 185 YELLOW (with 23)
   25 = GND to bump switches (with 26)
   26 = VCC 1.8V to bump switch pullups (with 25)
   27 = ultrasonic yellow (with 29)
   28 = PWM10 - pan servo
   29 = ultrasonic red (with 27)
   30 = PWM9 - tilt servo
--apt-get install hwinfo
--Drive testing results:
	Internal wifi on PAL: Performance OK, but still have occasions when connection seems to hang--which seem to coincide with AP handoffs (as observed by running iwconfig)
	USB wifi on PAL: Very similar performance.  Long hangs that sometimes seem to resolve themselves sometimes.  However, had to terminate the test when a hang didn't recover after ~2 minutes of waiting--and then after I had walked out and recovered the robot, system was still moderately non-responsive to console commands.  Interestingly, when I went to terminate the Scheme GUI I noticed that it flashed an image of me carrying the robot back from several minutes prior--implying that somewhere there is a buffer of images that haven't been sent/received yet.  That seems to make sense, since I am using TCP sockets (SOCK_STREAM).  Perhaps I need to switch to UDP sockets to allow images to be dropped (and possibly RTP on top of UDP).
-- Removed g-multi.sh from startup to kill driver for USB OTG (update-rc.d -f /etc/init.d/g-multi.sh remove) -- previously had 01 priority.
-- Made changes to /etc/modprobe.d/blacklist.conf and /etc/modules recommended in http://www.ajaykumarsingh.com/linux/tp-link-tl-wn822n-300mbps-high-gain-wireless-n-usb-adapter-not-working-on-ubuntu-12-04.html in order to see if it helps with wifi handoffs.

18 Apr 14
--apt-get install wavemon (monitors wifi connection statistics similar to iptraf)
--Making some tweaks to /etc/wpa_supplicant.conf and /etc/network/interfaces to see if it improves connectivity to PAL--tried 'wpa-roam' vice 'wpa-conf' but that didn't seem to work--did comment out all networks other than PAL from wpa_supplicant.conf
--Added 'sleep 5' to /etc/init.d/keepalive-ping.sh prior to the ping call to allow time for new /etc/network/interfaces and /etc/wpa_supplicant.conf to bring network up.  Also removed 'sleep 15' from /etc/init.d/time-update.sh

23 Apr 14
--Started working on master program (~/source/emperor) that will listen for commands from seykhl and then start threads or call functions as needed.

24 Apr 14
--apt-get install lsof
--Have control message-passing infrastructure working between rover and seykhl.  On vader-rover, emperor 'calls home' to open a socket to seykhl and then listens for commands on that socket.  Currently have start_cameras and stop_cameras working (had to make some tweaks to toollib-camera.cpp to explicitly close sockets to get cameras to start again after being stopped--previously that had been getting taken care of when I terminated run_cameras with a SIGINT).  Next working on getting pan and tilt to work from right thumb stick.

25 Apr 14
--apt-get install gdb
--Got pan and tilt servos working from right thumbstick of gamepad controller.  

28 Apr 14
--Have motor commands receiving and parsing properly on rover side.  Have implemented duplicate command checking on seykhl side, so may need to remove analogous code in emperor (observing slow execution of commands once received).
--Started implementing the sending of commands from emperor to motors--not functional yet.

29 Apr 14
--Tracked down slowness of pan/tilt execution to tcdrain() used to send integer speeds to motors. tcdrain() is necessary to ensure that integers get sent to motor controllers--removing it results in missed motor commands.  Reduced tcdrain wait time to minimum allowable (100ms), and also implemented code to skip sending motor command when motor command is a repeat.  That seemed to resolve the problem.
--Finished implementation of command parsing and sending to motors within emperor.cpp.  Also removed debugging printfs.
----
--First modifications to motor_control.h in attempt to correct leftward pull while driving.
----
--Final corrections to fix leftward pull.  Corrected by slowing right motors ~30% (see motor_control.h for details).

30 Apr 14
--Started modifications to emperor to add data logging.  Opened socket connection in first part of main().  Need to finish timestamp and send operation in emperor_log_data().

1 May 14
--First draft of data logging functional.  Need to filter pan/tilt commands in a way similar to how I filter motor commands to prevent excessive logging (currently in the log, every motor command is preceded by a pan/tilt command, even when the pan/tilt is unchanged).
--Have logging working for all pan/tilt and motor commands without duplicates.
--Integrated all bump switch monitor functions into emperor in a separate thread (emperor_monitor_bump_switches()).  Removed old monitor executable from startup--no longer needed (had been startup priority 98).

5 May 14
--Implemented sending of camera start and stop messages (toollib-camera.cpp, Network_StartCameras() and PGR_StopAndCleanup()).
--Completed and debugged implementation of sending individual timestamps for images.  Needed to use a send of "0" before sending camera stop message in order to get OpenCV_ReceiveFrame() on workstation to exit and not interpret 1st 4 bytes of camera stop message as an int representing compressed image size.

6 May 14
--Troubleshot slow framerate issue in emperor using new modifications to CustomImageEx.cpp.  Found problem was in the emperor_monitor_bump_switches() thread -- it was using ~95% processor without cameras running.  I am using select() with a blocking read() in order to allow the loop to exit when I change the global boolean gpio_thread_should_die.  However, the select() call takes the timeval timeout parameter as a pointer, and select() updates that value, which caused it to get set to 0 and cause subsequent select() calls to return immediately.  I changed the loop to set my timeval timeout variable inside each loop, ensuring that the timeout is set to 100 ms on every call to select().  CPU usage is now <1% without cameras running, and framerate is up to ~11-15 fps per camera (counted using timestamps in log files).
----
--Video saving working on seykhl.

19 May 14
--First attempts at using rotary encoders on wheels.  All example/test code downloaded so far has used too much (~50%+) CPU to be useful.  Looking into developing kernel-space interrupt handler to count ticks.

20 May 14
--Started working on modifying the libbeagle (BeagleBone) code gathered from bwgz.org.  My first thought is that the slowness comes from the fact that every time the GPIO class reads a GPIO value, it opens, reads, and closes the file.  Trying to modify the code so that it opens a file descriptor in the constructor and just reads from that fd when getting the value.  Don't have it working just yet--still troubleshooting.

21 May 14
--Have libbeagle code reading from a file descriptor opened in the GPIO constructor, but not sure what good it's doing me.  CPU usage on the test program is down to ~39% (from ~50%), but still too high to be useful while cameras are running.  Still think it might be better to have a kernel module running that counts ticks and keeps direction, and then reports that info out to user-space on demand.
----
--Tested libbeagle code modified with a SIGALRM timer to fire the code that checks the state of the GPIO lines.  Based on 30:1 gearing on the motors and 400 pulses per revolution on the encoders, need to be able to capture 12,000 pulses per second if the wheel is turning at 1 revolution per second (motors are capable of 200 rpm or 3.33 revolutions per second) times 2 (because of two encoders).  Attempting to run the SIGALRM timer set at 40 microseconds (25,000 iterations per second) resulted in a runing time of ~5.6 seconds, and it should have taken 1 second.  I think that I can conclude from this that this code is unusable for my purposes--I think that the concept of polling the devices for their data, rather than being driven by hardware interrupts, is the wrong way to go.
--I believe that I need to develop a kernel module that responds to interrupts caused by the state changes on the encoder data lines.  In my research I have found rotary_encoder.h (on the gumstix at /usr/src/linux-headers.../include/linux) and rotary_encoder.c (not found on the gumstix, but a couple different versions on various code sites).  These files appear to be a part of the Linux kernel.  I think my best bet is to figure out how to build this kernel module and make it work with my hardware.

22 May 14
--Edited kernel config to have rotary_encoder built as a kernel module by running 'make xconfig' from ~/build/linux-omap-3.5 (dot in checkbox indicates build as module, vice check mark that indicates build into kernel), then compiled (all) kernel modules by running 'make ARCH=arm CROSS_COMPILE=<EMPTY QUOTES> modules' from same location. ** Module would not load via either modprobe or insmod--need to research error messages more--possibly compiled with wrong command or need Module.symvers somewhere while compiling.

23 May 14
--In an effort to get kernel modules to compile properly on Gumstix (via how-to located at http://gumstix.8.x6.nabble.com/Linaro-linux-source-has-no-makefiles-help-td4967421.html, Larry Martin 21Jun13), tried the following:
     #apt-get install devscripts
     #apt-get install fakeroot build-essential kexec-tools kernel-wedge
     #apt-get build-dep linux
     #apt-get install git-core libncurses5 libncurses5-dev libelf-dev asciidoc binutils-dev
     --in ~/build/linux-omap-3.5:
     backup .config file
     #make mrproper
     #cp /path/to/config-backup .config
     #make prepare
     #make scripts
     #make && make modules_install (left running over the weekend)

27 May 14
--Kernel modules finished compilation without error, but when I try to load rotary_encoder.ko using 'modprobe rotary_encoder' I get an error stating 'Invalid module format'.  Not sure what the error is, because when I call 'modinfo rotary_encoder' the first entry on the vermagic line matches the output of `uname -r`, so the kernel versions should be the same.  The dmesg entry for that command is 'rotary_encoder: disagrees about version of symbol module_layout'.
--Had to replace *.ko, *.mod.c, *.mod.o, *.o, modules.order in ~/build/linux-omap-3.5/drivers/omap3-pwm and ~/build/linux-omap-3.5/drivers/gpio-event/module from old git commits (from January).  These were the kernel modules for the PWM (servos) and gpio-event monitor (bump switches), respectively.  They were apparently deleted during the make process on Friday.
----
*******JUST REVERTED LAST 3 COMMITS****************
--Reverted 27 May, 23 May, 22 May commits because I rebooted the Gumstix and discovered that the kernel module compilation work done on those days actually deleted/destroyed all of my previously functional kernel modules, probably somewhere in the make process.  Gumstix was unable to boot with correct drivers for USB, wifi, etc.  Reverting back to 21 May commit fixed the problem.
---
--Was able to recompile pwm.ko in /omap3-pwm using command 'make ARCH=arm CROSS_COMPILE=<EMPTYQUOTES> -C /root/build/linux-omap-3.5 M=`pwd` modules', but it would not load with either insmod or modprobe.  Looking at modinfo for both versions of pwm.ko, I see the difference in the vermagic string is that the one that works has ARMv7 and the one that doesn't has ARMv6 as the second-to-last entry.  Also, the working pwm.ko is significantly smaller (17K vs. 134K).
--Look more closely at realtek folder--the install.sh there was able to compile the wifi kernel module (8192cu.ko) that has the correct vermagic string.  Need to see what it does that the other modules need to do.

28 May 14
--Was able to recompile pwm.ko in /omap3-pwm and get 17K file using command 'make ARCH=arm CROSS_COMPILE= -C /lib/modules/3.5.0-2-linaro-omap/build M=`pwd` modules' (note blank (NO QUOTES) after CROSS_COMPILE=).  Also works with ARCH=armv7l (symlinked to arm).  Running modinfo on the new file shows identical output to the (working) regular pwm.ko module located in /root/build/linux-omap-3.5/drivers/omap3-pwm/, so it seems reasonable to assume that it would work the same way.  Also able to recompile gpio-event-drv.ko (from /root/build/linux-omap-3.5/drivers/gpio-event/module) the same way in a temp directory, with file size and modinfo matching original.
--After editing Makefile in /root/build/linux-omap-3.5/drivers/input/misc to add 'obj-m := rotary_encoder.o' on its own line, was able to compile rotary encoder module using command 'make ARCH=arm CROSS_COMPILE= -C /lib/modules/3.5.0-2-linaro-omap/build M=`pwd` modules'.  After linking it to modules directory with 'ln -s `pwd`/rotary_encoder.ko /lib/modules/3.5.0-2-linaro-omap/kernel/drivers/input/rotary_encoder.ko' and running 'depmod -a', was able to check modinfo and see a vermagic line that matched the working modules.  Was able to load module with 'modprobe rotary_encoder', verify it was loaded with lsmod, and remove it with 'modprobe -r rotary_encoder'.  It appears that I have figured out the correct commands to make a loadable module.  Now I need to figure out how to modify and/or configure this module to monitor the gpio pins that I'm using for the encoders.
--Taking rover down to machine shop for mounting of microphone and speakers.  Will see if it is possible to mount speakers on the underside of the rover.

29 May 14
--Mounting of microphone and speakers complete.  Mic is mounted on left rear corner of rover.  Speakers (the smaller, separate pair measuring approx. 3in x 2in each) are mounted underneath the rover, between the front and middle wheels, angled out towards the sides of the rover.  Should get a natural echo effect off the ground from this positioning.  Angle of the speakers is somewhat variable due to hinges on the backs of the speakers.
--Installed Arduino IDE (arduino-1.0.5-linux32.tgz from www.arduino.cc)and Teensyduino (teensyduino.32bit from http://www.pjrc.com/teensy/td_download.html) on rover.  Also tried the following:
	    #apt-get install arduino-core arduino openjdk-7-jre openjdk-7-jdk
	    #cd /usr/lib/jvm/java-7-openjdk-armhf/jre/lib/arm
	    #ln -s jamvm/libjvm.so .
	    #apt-get purge openjdk-7-* (looks like it automatically installs openjdk-6)
	    #apt-get install openjdk-6-jdk openjdk-6-*
Was unable to get this version of arduino to run, always throwing the error 'java.lang.UnsatisfiedLinkError: /root/arduino-1.0.5/lib/librxtxSerial.so: /root/arduino-1.0.5/lib/librxtxSerial.so: cannot open shared object file: No such file or directory (Possible cause: can't load IA 32-bit .so on a ARM-bit platform) thrown while loading gnu.io.RXTXCommDriver'.  Believe this is a dead end because the libraries are not built for ARM.
However, was able to get the packaged version to run.
Also able to get the UDOO version for ARM (v1.5.4) downloaded from http://www.udoo.org/install-the-arduino-ide-hfp/ to run as well.
The teensyduino.32bit was also unable to run, and I found out after some research that it also is not built for ARM.
Will try to manually copy the files that appear to be installed by the Teensyduino installer to see if I can hack a working Teensy programming environment together on the Gumstix.
Copied 49-teensy.rules to /etc/udev/rules.d

30 May 14
--Started trying to copy Teensyduino-specific files from seykhl to rover using a diff of a sorted find of the respective directores, first with the updated arduino-1.5.4 version on the rover.  Tried to launch this version of arduino after copying some of the files over and got the following error:
	  Could not find boards.txt in /root/arduino-1.5.4/hardware/teensy/cores/boards.txt. Is it pre-1.5?
	  WARNING: Error loading hardware folder teensy
	    No valid hardware definitions found in folder teensy.
After looking at the old and new boards.txt files, there is a significant difference in the format, so I don't think further work here will be fruitful.  Changing over to trying to copy the files into the package-installed version of arduino (1.0, vs. 1.0.5 on seykhl)
--Copied over files added by Teensyduino from seykhl using a diff of ~/arduino-stuff/sorted-seykhl-arduino.txt and ~/arduino-stuff/sorted-arduino-package.txt.  It appears to have worked--I was able to start the package-installed arduino IDE, select the Teensy 3.1 board from the boards menu, and see the specific Teensy libraries (specifically, the Encoder library).
---
--Connected audio connectors for speakers and mic.  J7 is speaker and J6 is mic, according to Summit board schematic found at https://pubs.gumstix.com/boards/SUMMIT/PCB30001-R2734/PCB30001.pdf.  Also connected USB power for speakers to 5V DC-DC converter.  Tested speakers using phone as audio source--sound quality is fair, but volume is good.
--Started work on getting IMU up and running.  Found a good tutorial at https://github.com/ptrbrtz/razor-9dof-ahrs/wiki/Tutorial and started working through it to test the IMU.  Currently reading data from the IMU in the form of Euler angles.  Not sure if Euler angles are what we want, or if we want things like compass heading, etc...  Need to run through the calibration procedure and figure out a way to adjust to the coordinate system set up in the software, since it is different from the axes printed on the board
--Discovered that on the Gumstix, the IMU is at /dev/ttyUSB1 and the GPS is at /dev/ttyUSB0. **NOT SURE IF THIS IS CONSTANT**
--Modified the mounting of the IMU.  Changed the USB breakout board from being mounted perpendicular to the IMU with a straight header to being mounted parallel and attached to the bottom of the IMU using a right-angle header and double-sided tape.  I thought the perpendicular mounting might be too vulnerable to breakage and I didn't like the cable routing in that setup.  The parallel mounting is much more compact and secure, and keeps the USB cable out of the way.

2 Jun 14
--Did more research on 9DOF Razor IMU in general and the AHRS code found on Friday in particular.  Figured out that I can use the yaw angle computed in AHRS for the rover's heading.  Not sure if the pitch or roll angles will be useful at all.  Also need to consider what information I can get from the accelerometers and gyros and what purpose it can serve. 

3 Jun 14
--Completed configuration procedure for accelerometer and  gyro.  Completed deprecated config procedure for magnetometer for reference.  Installed Oracle JDK, Processing, and EJML library on vader-ubuntu (Ubuntu laptop) in order to run new magnetometer config procedure.
--Calibration values for accel, gyro, and (old) mag:
  accel:
    x: max = 254, min = -287
    y: max = 282, min = -257
    z: max = 240, min = -293
  gyro: (average values)
    x = 18.76
    y = 15.96
    z = 6.58
  mag: (OLD)
    x: max = 620, min = -309
    y: max = 414, min = -487
    z: max = 480, min = -420
--Calibration data from new magnetometer calibration procedure (saved in  ~/razor-9dof-ahrs-Release-v1.4.2/Processing/Magnetometer_calibration/output.txt):
   
   In the Razor_AHRS.ino, under 'SENSOR CALIBRATION' find the section that reads 'Magnetometer (extended calibration)'
   Replace the existing 3 lines with these:

   #define CALIBRATION__MAGN_USE_EXTENDED true
   const float magn_ellipsoid_center[3] = {-4.09438, -259.976, -97.1897};
   const float magn_ellipsoid_transform[3][3] = {{0.774906, -0.125709, -0.0731712}, {-0.125709, 0.748713, 0.00420121}, {-0.0731712, 0.00420121, 0.964999}};

--Currently have IMU mounted roughly midway back on the rover on the left side about 3.5 cm from the edge.  Orientation of IMU (axes with AHRS are different than originally marked on board; I marked new axes with marker): positive x axis (short side of board with header soldering holes) pointed to left of rover; positive y axis (long side of board to the right of positive x) pointed forward; positive z axis pointing down.  
--With this orientation, the Yaw (Y) angle given by the AHRS should be my heading, with a fixed offset of -90 degrees, since the positive x axis (pointing left) should be 0 degrees on the z axis.
--Quick testing does not bear the above out.  Heading changes of ~90 degrees (eyeballed) gave a Y reading change of less than 10 degrees.  Of course, this is testing done prior to inputting the calibration data, and using the compass app on my iPhone as a reference.  However, the large variability I observed with the compass on my iPhone makes me wonder if my calibration environment here in the office has too much magnetic interference.  I also think that I should use an actual lensatic compass for a reference (not sure if I have one at home in my Army gear or not).  I need to test in a more EM-free environment, which I unfortunately think will have to be outdoors, a reasonable distance away from the EE building.

4 Jun 14
--Further testing showed that previous magnetometer calibration seemed faulty.  Redid calibration procedure and got the following: (saved in  ~/razor-9dof-ahrs-Release-v1.4.2/Processing/Magnetometer_calibration/output2.txt)
	  #define CALIBRATION__MAGN_USE_EXTENDED true
	  const float magn_ellipsoid_center[3] = {150.519, -45.9270, -79.4291};
	  const float magn_ellipsoid_transform[3][3] = {{0.926888, 0.0181419, 0.0232870}, {0.0181419, 0.979668, 0.0126558}, {0.0232870, 0.0126558, 0.971117}};
Entered this into Razor_AHRS.ino and reprogrammed.
--Mag update improved yaw/heading tracking when board was separated from rover, but still had erroneous results when mounted. Some experimentation showed that the errors seem to be due to the proximity of the IMU to the motors.  When mounted over the left middle motor, 1 cm above the deck, heading tracking was bad (a 90 degree turn of the robot showed little to no change in heading).  However, when the IMU was held at the approximate center of mass of the rover (adjacent to and behind the panoramic camera) and ~4 cm above the deck, heading tracking seemed accurate.  Taking the rover down to the machine shop to see if they can assist with remounting the IMU.
---
--Created /etc/udev/rules.d/41-my-devices.rules to make fixed aliases for the ttyUSB* assigned to the Razor IMU and GPS.  IMU is now '/dev/RazorIMU' and GPS is now '/dev/GPS'.  This will allow me to use these fixed aliases in my code when accessing the IMU or GPS.  Also discovered that GPS automatically puts out ASCII data at 4800 bps, so just need to read that node (and parse data format).
--Need to think about creating my own data output format for the Razor in the *.ino code...All I should need would be the Yaw angle (heading) and the calibrated sensor data (3x3).

5 Jun 14
--Took rover to machine shop and got IMU remounted adjacent to the camera, ~4.5cm above the deck, in the position I tested yesterday that yielded minimal magnetic interference with heading readings.  Oriented the IMU so that the positive X axis is pointing forward, the positive Y axis to the right, and the positive Z axis down (so there should be no need to calculate an offset for heading).
--Re-ran calibration routine with the IMU mounted and the rover on the floor (except for extended mag calibration procedure) and got the following:
  accel:
    x: max = 249, min = -283
    y: max = 275, min = -254
    z: max = 232, min = -292
  gyro: (average values)
    x = 30.37
    y = 4.43
    z = 17.26
  mag: (OLD)
    x: max = 530, min = -453
    y: max = 518, min = -410
    z: max = 152, min = -768
--Calibration data from new magnetometer calibration procedure (saved in  ~/razor-9dof-ahrs-Release-v1.4.2/Processing/Magnetometer_calibration/output.txt):
    #define CALIBRATION__MAGN_USE_EXTENDED true
    const float magn_ellipsoid_center[3] = {45.1138, 41.8867, -296.532};
    const float magn_ellipsoid_transform[3][3] = {{0.900928, 0.0229865, 0.0139737}, {0.0229865, 0.980335, -0.0228203}, {0.0139737, -0.0228203, 0.971285}};
Accelerometer values were pretty similar to previous, but gyro and mag were very different.
--Tested Yaw (heading) with new calibration and rover on the ground and got good results.  Turning the rover ~90 degrees yielded a ~90 degree change in yaw.  Measured against lensatic compass and found that yaw degrees were about 17 or 18 degrees less than true heading(yaw = 30, compass = 47).  Need to test more thoroughly to ensure that this offset is consistent before writing it into the code.
--Shortened USB cable to IMU and plugged into the furthest forward port on the hub.
--Copied *.ino files from ~/razor-9dof-ahrs-Release-v1.4.2/Arduino/Razor_AHRS to ~/source/razor-imu/arduino/Razor_AHRS in order to consolidate this code with my other working code.
--Have first version of my output format written into Razor_AHRS.ino (under ~/source).  Still need to tweak it and get offset correct.

6 Jun 14
--Started working on data flow of RazorIMU->rover(gumstix)->seykhl->log.  Have started building razor-imu.{cpp,h} for the IMU-specific functions that will need to be called from emperor.  I am borrowing heavily from the C++ code included by Peter Bartz in razor-9dof-ahrs-Release-v1.4.2/C++, although I'm trying to reduce the complexity--Bartz passes his data from the IMU to C++ in binary, but I think that I'm going to stick with passing text, since that is easier to send across the network and log-->I can read it back into binary from text later, on seykhl.  Integrated razor-imu.{cpp,h} with the emperor Makefile and built the function to open the serial port to the IMU.  It compiles into the emperor executable, but I haven't tested it yet.

9 Jun 14
--Started on IMU data passing testing.  Can get port open and set up fine, and sending request for data seems to work.  However, the reading of that data does not seem to work--should be reading up to 256 bytes, but instead stops after reading between 1 and 5 bytes.  Need to look at this more.  Changing VTIME value in razor-imu.cpp did not seem to have an effect.
--Found that previous work on using SIGALRM in libbeagle/rotary for testing had gotten reverted in the 27 May debacle.  Manually downloaded 21 May versions and replaced them.

10 Jun 14
--Got a full line of data (as text) read from IMU by changing the termios c_cc[VMIN] in razor-imu.cpp to 143 (this value sets the minimum number of bytes per read).  However, I don't think this is a workable permanent solution, as the number of bytes on a line will change as the values change.  I wasn't able to figure out a method to tell the read to continue until it hits a newline.
--I think it's better to get the data from the IMU into emperor as binary (floats) and then deal with displaying/manipulating the data from there.  I think it will still be easier to send the data from the rover (emperor) to seykhl (and the log files) as text, since that's what I already have set up.
--Have IMU outputting data as 12x floats.  Currently working on getting data into emperor in binary format, following closely with RazorAHRS.cpp.  Have imu_fd as global var opened in razor-imu.cpp, need to implement _input_pos similarly in order to get _read_token working.

11 Jun 14
--Got first draft of razor-imu.cpp working with binary read into emperor.  Still need to clean it up and put in some initialization of the variables into razor_read_data().  Also need to implement the IMU reading as a thread on a timer (SIGALRM??) to read at about 10Hz.

12 Jun 14
--Finished up razor_read_data() in razor-imu.cpp
--Did some reading/thinking about how to integrate accelerometer data to get velocity and position.  Would be ideal if this could be done on-board the IMU, but not sure if the processor is powerful enough.
--Have emperor_run_imu thread implemented, but still need to implement a sleep or timer function to keep it from constantly polling the IMU and sending data to the log.  The first test (with the IMU read and send in a while loop) did not slow down the cameras (still ~13fps/cam), but the excessive logging created a 150MB log file that crashed gedit.  

13 Jun 14
--Debugged problems with getting IMU thread to run and log data back on seykhl.  Logging is now functional.
--Added a usleep into the emperor_run_imu thread to get ~10 IMU updates/sec on seykhl.  Have the usleep set at 80000, which seems to be very close to where it needs to be for updates at 10 Hz.  Still may need to tweak this some more.
--In addition to (or possibly instead of) using the usleep, I started looking into how to timestamp the data coming off the IMU.  Still trying to figure out if there is a real time clock on the IMU, and if so, how to access it.  If there isn't a RTC on the IMU, maybe I can timestamp it when it arrives on the Gumstix.
--Did some more research into methods of turning the IMU data into position data.  I have a few more papers to read on this.  Right now I think I might be able to do at least the first integration (acceleration to velocity) on the IMU, and then finish on the Gumstix (which would allow me to also use the GPS data the Gumstix will get).


17 Jun 14
--Ran new calibration for IMU outdoors (picnic table near south wing of EE building).  Added new calibration data to RazorAHRS.ino.  Observed through AHRS demo sketch that it appeared to be tracking horizontal rotation properly, whether on the desk or on the floor.  However, on the floor the yaw reading (i.e., compass heading) is off ~10-12 degrees to the left.  Incorporated offset of 11 in Output.ino.

30 Jun 14
--Modified emperor_log_data() in emperor.cpp to take a socket as a second argument in order to allow logging to two separate files (regular data and IMU) on seykhl.  After the split everything seems to be functioning properly--still getting ~11-12 fps per camera.
----
--Modified emperor.cpp to run the IMU data read as a signal handler (off of a SIGALRM timer) rather than a separate thread.  First tried the timer set at 50 Hz (the update rate of the IMU), but got weird results--cameras wouldn't start and IMU log file randomly had values that were way off from neighboring readings.  Tried dropping the rate to 20 Hz and everything seemed to work fine--camera frame rate was normal, camera looked normal, and IMU log had reasonable data throughout.  In regular data log, I did notice there were some extra newlines in random spots throughout the file.
--Also tried the IMU update rate at 25 Hz (half the internal IMU rate). It seemed to cause some strange errors with the bump switch monitoring thread--the SIGALRM timer caused an "interrupted system call" error on the select that I'm using as a timeout on the read of the GPIO file for the bump switches, which seems to cause spurious reads.  Tried rates between 25 and 50 Hz and got the same type of errors (bump switch problems and IMU log file lines with data that was obviously incorrect). Rechecked at 20 Hz, and things went back to normal (except for the extra newlines in the data log file), so it appears that the fastest we'll be able to get data from the IMU is at a rate of 20 Hz.
----
--Fixed extra newlines in data log file on seykhl side (**see other log**)
--Started working on run-imu.{cpp,h}, a standalone program to read IMU data as fast as possible, along with associated changes to emperor.{cpp,h} to remove IMU running from this program.

1 Jul 14
--Finished first draft of run-imu and associated changes to emperor, as well as a script (run-emperor) to start and stop them together.  The programs seem to work fine together. IMU logging, set to 50 Hz in run-imu, has sped up, but not all the way to 50 Hz.  Based on timestamps in the log file, the average update is at about 37.2 Hz, with a standard deviation of about 11.5 Hz.  I think this might be caused by the fact that the code is written for the Gumstix to poll the IMU for data every time the SIGALRM timer (set to 50 Hz) goes off.  Could it be as easy as setting the timer for a higher rate?  Or would it be better to change the code so that the IMU is constantly outputting data as fast as it can, and the run-imu is constantly listening?  Or maybe its the inaccuracy of timestamping based off the Gumstix clock (i.e., when the data finishes transferring)--maybe use the millis() function on the IMU to measure time between data points.
--Tried setting timer rate above 50 Hz and got bad results.  At both 60 and 55 Hz, observed intermittent slowdowns in frame rate (5-6 fps/camera in some seconds, with normal 11-12 fps/camera in others) as well as bogus data in the IMU log file (extra newlines, and lines that were cut off or missing the first part of the line).  Don't think this will work.  Next going to try adding a timestamp from the IMU.
--After much experimentation and frustration, got the IMU timestamp passed to the Gumstix and on to seykhl.  Started by trying to use the method that the readings from the IMU use, but I couldn't get that to work.  The IMU data are floats, which get read into their array using type-punning to char*.  However, the timestamp is an unsigned long int (32-bit), and I couldn't figure out how to get a correct value out of type-punning that.  I ended up breaking up the 32-bit int into 4 8-bit ints on the IMU (using bit shifting/masking) and sending each individually, then reconstructing the int on the Gumstix after receipt.  IMU log now has IMU timestamp as well as original Gumstix timestamp (and I discovered upon analysis of my data that the interval between the two timers is indeed fixed).
--Unfortunately, the extra computations on the IMU needed to break up the timestamp int seems to have slowed the IMU down--now I'm only getting updates at about 25 Hz, although the data is arriving at a much more consistent rate--the standard deviation dropped almost an order of magnitude to 1.5 Hz.  This actually might be helpful, since a consistent interval simplifies integration.  I'll spend a bit of time tomorrow seeing if I can find a faster way to send the IMU timestamp, and then I'll work on changing the IMU/Gumstix setup so that instead of the Gumstix polling the IMU at an interval, the Gumstix will merely listen while the IMU sends data as fast as it can.

2 Jul 14
--Got IMU to send the timestamp unsigned long int with a single Serial.write() call by using a memcpy to put the data into an unsigned char buf.  Modified the receiving side on the Gumstix accordingly and it works.  Unfortunately, it didn't seem to speed things up any--still getting a rate and standard deviation similar to yesterday (on a run of ~2 minutes, or ~2500 IMU samples).  It occasionally gets a single sample at 50 Hz, but the average rate is less than 1/10 of a standard deviation from the lowest rate observed.  Going to try some quick changes to slow down the rate at which the Gumstix is requesting data from the IMU to see if that makes things more uniform.
--Tested setting the SIGALRM timer to 25, 20, and 10 Hz, and did not get results that were any better than set at 50 Hz.  In fact, the results at 50 Hz and 25 Hz were nearly identical, which leads me to believe that the fastest that we can poll the IMU using SIGALRM is 25 Hz.  At 20 Hz and 10 Hz, the results were actually less uniform--a higher standard deviation, and a larger range between max and min rates.  Now going to try to rebuild the run-imu program and IMU firmware to have the Gumstix just listen on the port and have the IMU pump out data as fast as it computes it.
----
--Changed run-imu.cpp (executable) and razor-imu.cpp (function libraries) to support running the IMU in continuous output mode and having the Gumstix loop on a listen.  This worked extremely well.  In two runs (~1100 and ~3000 IMU samples, respectively), I was able to measure (using the clock on the IMU) the interval between each sample was either 20 or 21 ms (50 or 47.6 Hz).  The average interval was 20.48 ms with a standard deviation of 0.50 ms.  I also observed that there was significant drift between the Gumstix clock and IMU clock (Gumstix measured intervals ranged between 9 and 31 ms, although the average was close, 20.72 ms), so this confirmed that using the IMU clock for the integration interval is the better way to go.  Wit the IMU clock, the interval nearly alternates between 20 and 21 ms, so I think it's safe to use 20.5 ms as a fixed integration time (realizing that to minimize my floating point multiplies, I'll probably need to multiply that interval by 10 and then just divide the result by 10 when reporting the data).

3 July 14
--Implemented conversion of accelerometer output to cm/s^2.  Conversion seems to work correctly, but when the rover appears to be at rest and level, I get small acceleration readings in the x and y directions, and a reading of less than 1G in the z direction.  Still need to think some more about this and how it will affect the data that I'm collecting from the IMU, as well as how to compensate for it.  A simple linear offset (based on data sampled at startup) might be the easiest way to compensate, but I'm not sure if it will be correct in all cases.
--Started researching conversion factor for gyroscopes, but not convinced that it's fully necessary, since current DCM algorithm on IMU works without unit conversion.  Also started to think about a self-calibration function for the gyros, since I think it is a very safe assumption that when the rover starts up there will be no rotation about any axis.  Implemented a quick function that sampled the gyros for a fixed amount of time (tried both 1s and 10s), averaged that sample, and then subtracted that number from future gyro readings.  If the rover is at rest (rotationally), then all gyros should read 0.  When I tried my new function (under both time limits), I got readings on the gyros that were higher than the DCM algorithm's built-in gyro offset, which just takes a fixed number from an offline calibration routine and subtracts it from readings.  I think I might have some bug in my calibration routine, but I haven't been able to find it yet.

7 Jul 14
--Tried a few changes and still getting bogus data with my self-calibration routine on the gyros, so went back to static calibration that was built into the DCM algorithm.
--Experimented with tightening/loosening the IMU mounting screws while rover was on the ground and got at-rest accelerometer data that seemed to be closer to zero (at least in x-y plane).  Need to collect some data while driving and sitting still, then plot that data to see if it centers on 0--if so, I think that will be OK.
--Changed IMU output data format (both on IMU and rover) to output the full yaw, pitch, and roll angles from DCM algorithm to my log file.  I think those angles will be useful in keeping track of the rover frame orientation with respect to the earth frame.  Even if I can't get an absolute earth frame reference, I think I can still use the starting frame of the rover as a reference frame (since the rover will always start from a stopped position).

8 Jul 14
--Modified scale_sensors() function in Output.ino to normalize the acceleration vector prior to scaling it to g0 in cm/s^2.  The normalized output now is a full 1G, where the previous non-normalized output was ~50 cm/s^2 short.  Will need to retake data taken yesterday, since the non-normalized data will probably be useless.
--Started the process of mounting the Teensy and wiring the encoders to it.  Lots of redoing cable management and remounting small boards involved.  Should finish tomorrow.

9 Jul 14
--Finished mounting Teensy on rover, near the left middle wheel.  All wires (power and signal from the encoders) shortened and connected to board.
--Discovered that the Teensy board must be programmed from my Ubuntu laptop due to the Teensy loader program that actually uploads the hex files to the board (not available on ARM).  Shouldn't be much of an issue, since I don't anticipate needing to change the sketch on the Teensy once it is completed. **MUST REMEMBER TO COPY TEENSY SKETCH FILES TO EITHER SEYKHL OR ROVER IN ORDER TO HAVE THEM PUSHED TO GIT**
--Ran a sample sketch for the Teensy (TwoKnobs.ino) that showed both encoders as functional.  It also confirmed that each rotation of the wheel is 12,000 ticks on the encoder (400 ticks/rev for encoder * 30:1 gear ratio on motor).
--Implemented udev rules to give Teensy board the fixed alias of '/dev/Teensy'

10 Jul 14
--Acquired 12V/12A power supply from ECE electronics shop for rover.  Connected output wire to a plug that matches the battery, so now I can power the entire rover from wall power just by unplugging the battery and plugging in the power supply (which lets me switch between wall and battery power without having to physically unplug the connections to the Gumstix and USB hub).
--Tested the encoders by driving over a known distance and counting the ticks on that drive.  Plotted the data (ticks vs. distance) and found the data to be exceptionally linear, although each side was slightly different.  Determined that the left encoder has 328.192 ticks per cm traveled, and the right encoder has 325.209 ticks per cm traveled.  Did a common sense check--computed wheel circumference from (ticks/rotation)/(ticks/cm) and from pi*diameter--and got results that were very close.

12 Jul 14
--Replaced broken Teensy with new device--working normally.
--Replaced broken DC-DC adapter with new one--added insulation, better connectors, wire strain relief, and support padding to the bottom of auxiliary circuit boards.  Seems to be working fine now.
--Replaced broken USB Wifi adapter with new one.  Had to change /etc/udev/rules.d/70-persistent-net.rules to remove old wlan1 (and unused wlan2) and replace it with new wlan1 since devices are given the 'wlan*' names based on MAC address.  Rebooted and network is back to working normally.

15 Jul 14
--Finished replacing broken components (GPS, Wifi, USB hub, Teensy, DC-DC converter).  All appear to be working normally.
--Started working on run-gps.cpp (started from clone of run-imu.cpp)

16 Jul 14
--Have first draft of run-gps.cpp running, sending raw NMEA sentences (of the GPRMC and GPGGA types) back to the imu-log.txt file on seykhl.  Need to modify rover_server_log to allow multiple connections to the log_imu_sockfd port for logging, since now only one or the other of GPS and IMU (but not both) can log (need 3: IMU, GPS, encoders).

17 Jul 14
--Completed mods to allow GPS and IMU to log simultaneously--logging works well.  

19 Jul 14
--Started work on run-encoders.{cpp,h} to run on rover and read data from encoders (via Teensy) and send it back to seykhl to be logged.  Have all of the boilerplate stuff adapted from run-imu and run-gps, just need to write the functions to initialize the Teensy, listen for and read the data, and the handler function that runs in the main loop (which all should be fairly straightforward adaptations from razor-imu.cpp).  
--Dan was in for a while today and we spoke about adapting his old Kalman filter code to my project.  It seems like it won't be too difficult to go from the data that I'm logging in my log file to a series of (x, y, orientation) positions, which will form the trace of the robot's path.

20 Jul 14
--Completed first draft of run-encoders.  Have binary data read of timestamp (ms), dt (ms), left distance (cm) and right distance (cm) from Teensy working.
--Added another field to IMU data, dt, to record ms between readings.
--Removed extra printfs from run-encoders and run-imu.

21 Jul 14
--Changed IMU update timing/logic in Razor_AHRS.ino to use microseconds (micros() function) instead of millis() to fix problem of updates not coming at exactly 20 ms each time.  Had to put in logic to deal with the micros() rollover case (every ~70 minutes).  Believe the logic is correct, but need to run a test for > 70 minutes to confirm.
--Found logic error in first draft of rollover logic...testing fix.

22 Jul 14
--Fix appeared to work, no rollovers of IMU time and no nan's in YPR output.
--Need to implement fixes in run-imu and run-encoders to ignore the first ~500 ms of output from the microcontrollers, since they are arriving at the Gumstix at an interval < 20 ms--looks like the serial buffer is just filling up once the connection is made.  Need to have a loop that runs for ~500 ms and just receives the messages and does nothing with them.
--Having weird network/socket errors between sensor executables and log thread on seykhl.  Going to try to consolidate run-imu, run-encoders, and run-gps into a single program that polls each sensor on a schedule and then sends one consolidated message.

**TODO**

 
***RANDOM NOTES
--may need to use a function similar to initport() in motor_control_functions.cpp in order to initialize fd used to read from and write to IMU and GPS
--LOOK AT C++ examples in Razor code

..udev stuff to write new *.rules file lines to reference a device with a fixed alias
  #udevadm info --query all --name /dev/ttyUSB1 --attribute-walk
  --GIVES info about the device to make a udev rule
  #udevadm control --reload-rules; udevadm trigger 
  --reloads udev rules so newly written ones can take effect
..USE A SOCKET INSTEAD OF FILE DESCRIPTOR TO COMMUNICATE BETWEEN GPIO AND MONITOR!!!!  READ WILL BLOCK!!!


Buffers
----------------------------------------
.   today.text           59668  Text		  ~/today.text
    run-imu.h              748  C++/l		  ~/source/razor-imu/run-imu.h
    run-encoders.h        1593  C++/l		  ~/source/encoders/run-encoders.h
    razor-imu.h           1475  C++/l		  ~/source/razor-imu/razor-imu.h
    run-imu.cpp           5524  C++/l		  ~/source/razor-imu/run-imu.cpp
    run-encoders.cpp      8037  C++/l		  ~/source/encoders/run-encoders.cpp
    razor-imu.cpp        12379  C++/l		  ~/source/razor-imu/razor-imu.cpp

  * *shell*               4259  Shell:run	  ~/source/razor-imu/
  * *shell*<2>           12810  Shell:run	  /
    run-gps.cpp           7479  C++/l		  ~/source/gps/run-gps.cpp
    run-emperor            327  Shell-script[bas  ~/bin/run-emperor
    run-gps.h             1257  C++/l		  ~/source/gps/run-gps.h

---old---
.   Sensors.ino           6483  C/l		  ~/source/razor-imu/arduino/Razor_AHRS/Sensors.ino
    Razor_AHRS.ino       28879  C/l		  ~/source/razor-imu/arduino/Razor_AHRS/Razor_AHRS.ino
    Output.ino            6445  C/l		  ~/source/razor-imu/arduino/Razor_AHRS/Output.ino
    DCM.ino               4673  C/l		  ~/source/razor-imu/arduino/Razor_AHRS/DCM.ino
    Math.ino              2187  C/l		  ~/source/razor-imu/arduino/Razor_AHRS/Math.ino
    Compass.ino            595  C/l		  ~/source/razor-imu/arduino/Razor_AHRS/Compass.ino

---old----
    emperor.cpp          21021  C++/l		  ~/source/emperor/emperor.cpp
    emperor.h             2197  C++/l		  ~/source/emperor/emperor.h
    rotary.cpp|rotary     2813  C++/l		  ~/source/libbeagle/examples/rotary/rotary.cpp
    rotary.h               975  C++/l		  ~/source/libbeagle/main/src/rotary.h
    rotary.cpp|src        4049  C++/l		  ~/source/libbeagle/main/src/rotary.cpp
    RazorAHRS.cpp         9139  C++/l		  ~/razor-9dof-ahrs-Release-v1.4.2/C++/RazorAHRS.cpp
    Example.cpp           4487  C++/l		  ~/razor-9dof-ahrs-Release-v1.4.2/C++/Example.cpp
    toollib-camera.cpp   21748  C++/l		  ~/source/camera/toollib-camera.cpp
    toollib-camera.h      3487  C++/l		  ~/source/camera/toollib-camera.h
    RazorAHRS.h           4341  C++/l		  ~/razor-9dof-ahrs-Release-v1.4.2/C++/RazorAHRS.h
    motor_control_functi: 7126  C++/l		  ~/source/motor_control/motor_control_functions.cpp
    Makefile              1725  GNUmakefile	  ~/source/emperor/Makefile
    gpio.cpp              3953  C++/l		  ~/source/libbeagle/main/src/gpio.cpp
    motor_control.h       4786  C++/l		  ~/source/motor_control/motor_control.h
    Math.ino              2187  C/l		  ~/source/razor-imu/arduino/Razor_AHRS/Math.ino
    *scratch*              191  Lisp Interaction
  * *Messages*            3464  Fundamental



Older:
    servo-control.sh       630  Shell-script[bas  /etc/init.d/servo-control.sh
    gpio-monitor.sh       1137  Shell-script[bas  /etc/init.d/gpio-monitor.sh
    servo-control.sh       630  Shell-script[bas  /etc/init.d/servo-control.sh
    g-multi.sh             531  Shell-script[bas  /etc/init.d/g-multi.sh
    toollib-camera.h      3356  C++/l		  ~/source/camera/toollib-camera.h
    toollib-camera.cpp   18914  C++/l		  ~/source/camera/toollib-camera.cpp
-->aren't all below replaced by emperor????
    monitor.h             1161  C++/l		  ~/source/monitor/monitor.h
    monitor.cpp           3064  C++/l		  ~/source/monitor/monitor.cpp
    run_cameras.cpp       1640  C++/l		  ~/source/camera/run_cameras.cpp


