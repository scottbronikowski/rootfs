//=============================================================================
// Copyright © 2008 Point Grey Research, Inc. All Rights Reserved.
//
// This software is the confidential and proprietary information of Point
// Grey Research, Inc. ("Confidential Information").  You shall not
// disclose such Confidential Information and shall use it only in
// accordance with the terms of the license agreement you entered into
// with PGR.
//
// PGR MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF THE
// SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
// PURPOSE, OR NON-INFRINGEMENT. PGR SHALL NOT BE LIABLE FOR ANY DAMAGES
// SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING
// THIS SOFTWARE OR ITS DERIVATIVES.
//=============================================================================
//=============================================================================
// $Id: CustomImageEx.cpp,v 1.20 2010-02-26 23:24:47 soowei Exp $
//=============================================================================

//#include "stdafx.h"
//#include "stdio.h"

#include "FlyCapture2.h"

#include <stdio.h>
#include <sys/time.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>

using namespace FlyCapture2;

//defines
#ifndef TRUE
#define TRUE (0==0)
#endif
#ifndef FALSE
#define FALSE (0!=0)
#endif


//globals
const unsigned int k_FrontCamSerial = 12262775;
const unsigned int k_PanoCamSerial = 13282227;
const Mode k_fmt7Mode = MODE_0;
const PixelFormat k_fmt7PixFmt = PIXEL_FORMAT_RAW8;
const char k_OutputDir[] = "/tmp/images/";
const float k_FrameRate = 8.5;
const unsigned int k_FrontCamWidth = 640;//800;//1200;//fmt7Info.maxWidth;
//const unsigned int k_FrontCamWidth = 960;//1248;//1072;//fmt7Info.maxWidth;
const unsigned int k_FrontCamHeight = 480;//600;//720;//820;//fmt7Info.maxHeight;
const unsigned int k_PanoCamWidth = 1240;//fmt7Info.maxWidth;
const unsigned int k_PanoCamHeight = 934;//fmt7Info.maxHeight;
const unsigned int k_PanoCamOffsetX = 34;
const unsigned int k_PanoCamOffsetY = 14;

//structures
struct PointGrey_t {
  Camera camera;
  CameraInfo cameraInfo;
  Format7Info format7Info;
  Format7ImageSettings imageSettings;
  Format7PacketInfo packetInfo;
  Image rawImage, convertedImage;  
  PixelFormat pixFormat;
  unsigned int rows, cols, stride;
  
};


//prototypes
void PrintBuildInfo();
void PrintCameraInfo( CameraInfo* pCamInfo );
void PrintFormat7Capabilities( Format7Info fmt7Info );
void PrintError( Error error );
double current_time(void);
void CheckPGR(Error error);
int CheckSaving(const char *dir);
void SetFrameRate(Camera* cam);
void PGR_StopAndCleanup(PointGrey_t* PG, unsigned int numCameras);
unsigned int PGR_Init(BusManager* busMgr);
int PGR_SetCamera(PointGrey_t* PG);

int main(int /*argc*/, char** /*argv*/)
{
    PrintBuildInfo();

    const int k_numImages = 100;
 
    BusManager busMgr;
    unsigned int numCameras = PGR_Init(&busMgr);
    printf( "Number of cameras detected: %u\n", numCameras );
    if ( numCameras < 1 )
    {
        printf( "Insufficient number of cameras... exiting\n" );
        return -1;
    }

    PointGrey_t* PG = new PointGrey_t[numCameras];
    PGRGuid tmpGuid;
    for (unsigned int i = 0; i < numCameras; i++) //setup/init loop
    {
      // Connect to a camera
      CheckPGR(busMgr.GetCameraFromIndex(i, &tmpGuid));
      CheckPGR(PG[i].camera.Connect(&tmpGuid));

      if (PGR_SetCamera(&PG[i]) != 0)
      {
	printf("Error in setting camera");
	return -1;
      }
      // // Get the camera information
      // CheckPGR(PG[i].camera.GetCameraInfo(&PG[i].cameraInfo));
      
      // //PrintCameraInfo(&PG[i].cameraInfo);

      // // Query for available Format 7 modes
      // bool supported;
      // PG[i].format7Info.mode = k_fmt7Mode;
      // CheckPGR(PG[i].camera.GetFormat7Info(&PG[i].format7Info, &supported));
      
      // //PrintFormat7Capabilities(PG[i].format7Info);

      // if ( (k_fmt7PixFmt & PG[i].format7Info.pixelFormatBitField) == 0 )
      // {
      //   // Pixel format not supported!
      // 	printf("Pixel format is not supported\n");
      //   return -1;
      // }
    
      // PG[i].imageSettings.mode = k_fmt7Mode;
      // PG[i].imageSettings.pixelFormat = k_fmt7PixFmt;

      // if (PG[i].cameraInfo.serialNumber == k_FrontCamSerial)
      // {
      // 	PG[i].imageSettings.width = k_FrontCamWidth;
      // 	PG[i].imageSettings.height = k_FrontCamHeight;
      // 	PG[i].imageSettings.offsetX = (PG[i].format7Info.maxWidth - 
      // 				       PG[i].imageSettings.width) / 2;
      // 	PG[i].imageSettings.offsetY = (PG[i].format7Info.maxHeight - 
      // 				       PG[i].imageSettings.height) / 2;
      // }
      // else if (PG[i].cameraInfo.serialNumber == k_PanoCamSerial)
      // {
      // 	PG[i].imageSettings.width = k_PanoCamWidth;
      // 	PG[i].imageSettings.height = k_PanoCamHeight;
      // 	PG[i].imageSettings.offsetX = k_PanoCamOffsetX;
      // 	PG[i].imageSettings.offsetY = k_PanoCamOffsetY;
      // }
      // else
      // {
      // 	printf("ERROR! Camera serial number not recognized!");
      // 	return -1;
      // }
      
      // printf("Image size: %d x %d\n", PG[i].imageSettings.width, PG[i].imageSettings.height);

      // bool valid;
      // // Validate the settings to make sure that they are valid
      // CheckPGR(PG[i].camera.ValidateFormat7Settings(&PG[i].imageSettings,
      // 					       &valid,
      // 					       &PG[i].packetInfo ));
      
      // if ( !valid )
      // { // Settings are not valid
      // 	printf("Format7 settings are not valid\n");
      //   return -1;
      // }
      
      // // Set the settings to the camera
      // CheckPGR(PG[i].camera.SetFormat7Configuration(&PG[i].imageSettings,
      // 					       PG[i].packetInfo.recommendedBytesPerPacket ));
      // SetFrameRate(&PG[i].camera);


      // Start capturing images
      CheckPGR(PG[i].camera.StartCapture());
  
      // Retrieve frame rate property
      Property frmRate;
      frmRate.type = FRAME_RATE;

      // //set frame rate to automatic mode
      // frmRate.autoManualMode = true;
      // frmRate.absControl = false;
      // CheckPGR(cam[i].SetProperty(&frmRate));

      CheckPGR(PG[i].camera.GetProperty( &frmRate ));
      printf("Frame rate for Camera %u is %3.2f fps\n", 
	     PG[i].cameraInfo.serialNumber,
	     frmRate.absValue);

    }

    printf( "Grabbing %d images\n", k_numImages );


    double start = current_time();
    for ( int imageCount=0; imageCount < k_numImages; imageCount++ )
    {
      for (unsigned int i = 0; i < numCameras; i++)
      {
        // Retrieve an image
	CheckPGR(PG[i].camera.RetrieveBuffer(&PG[i].rawImage));
	
        // Get the raw image dimensions
	PG[i].rawImage.GetDimensions(&PG[i].rows, &PG[i].cols, 
				     &PG[i].stride, &PG[i].pixFormat );

        // Convert the raw image
	CheckPGR(PG[i].rawImage.Convert(PIXEL_FORMAT_BGRU, 
					&PG[i].convertedImage));
    	if (imageCount % 10 == 0)
    	  printf("Captured %u-%d\n",PG[i].cameraInfo.serialNumber, imageCount);
      }
    }
    double stop = current_time();
    //check elapsed time
    double elapsed = stop - start;
    double images_per_sec = (double)k_numImages / elapsed;
    printf( "\nFinished grabbing images\n" );
    printf("%d images per camera taken in %f seconds (%f images/sec/cam)\n",
    	   k_numImages, elapsed, images_per_sec);

    
    //grab and save one last image from each camera, after time has been measured
    // Since this section of code saves images in the k_OutputDir folder,
    // must ensure that this folder exists and we have permissions to write to it
   
    if (CheckSaving(k_OutputDir) != 0)
    {
      printf("Cannot save to %s, please check permissions\n",k_OutputDir);
      return -1;
    }

    for (unsigned int i = 0; i < numCameras; i++)
    {
      // Retrieve an image
      CheckPGR(PG[i].camera.RetrieveBuffer(&PG[i].rawImage));
      
      // Get the raw image dimensions
      PG[i].rawImage.GetDimensions(&PG[i].rows, &PG[i].cols, 
				   &PG[i].stride, &PG[i].pixFormat );

      // Convert the raw image
      CheckPGR(PG[i].rawImage.Convert(PIXEL_FORMAT_BGRU, 
				      &PG[i].convertedImage));
   
     
      // Create a unique filename
      char filename[512];
      sprintf(filename, "%s%u-final.ppm", k_OutputDir, 
	       PG[i].cameraInfo.serialNumber);

      // Save the image. If a file format is not passed in, then the file
      // extension is parsed to attempt to determine the file format.
      CheckPGR(PG[i].convertedImage.Save(filename));
      printf("Saved %s\n",filename);
    }
      

    PGR_StopAndCleanup(PG, numCameras);

    printf( "Done!\n" );
 
    delete[] PG;
    return 0;
}


void PrintBuildInfo()
{
    FC2Version fc2Version;
    Utilities::GetLibraryVersion( &fc2Version );
    char version[128];
    sprintf( 
        version, 
        "FlyCapture2 library version: %d.%d.%d.%d\n", 
        fc2Version.major, fc2Version.minor, fc2Version.type, fc2Version.build );

    printf( "%s", version );

    char timeStamp[512];
    sprintf( timeStamp, "Application build date: %s %s\n\n", __DATE__, __TIME__ );

    printf( "%s", timeStamp );
}

void PrintCameraInfo( CameraInfo* pCamInfo )
{
    printf(
        "\n*** CAMERA INFORMATION ***\n"
        "Serial number - %u\n"
        "Camera model - %s\n"
        "Camera vendor - %s\n"
        "Sensor - %s\n"
        "Resolution - %s\n"
        "Firmware version - %s\n"
        "Firmware build time - %s\n\n",
        pCamInfo->serialNumber,
        pCamInfo->modelName,
        pCamInfo->vendorName,
        pCamInfo->sensorInfo,
        pCamInfo->sensorResolution,
        pCamInfo->firmwareVersion,
        pCamInfo->firmwareBuildTime );
}

void PrintFormat7Capabilities( Format7Info fmt7Info )
{
    printf(
        "Max image pixels: (%u, %u)\n"
        "Image Unit size: (%u, %u)\n"
        "Offset Unit size: (%u, %u)\n"
        "Pixel format bitfield: 0x%08x\n",
        fmt7Info.maxWidth,
        fmt7Info.maxHeight,
        fmt7Info.imageHStepSize,
        fmt7Info.imageVStepSize,
        fmt7Info.offsetHStepSize,
        fmt7Info.offsetVStepSize,
        fmt7Info.pixelFormatBitField );
    printf("Mode: %d\n"
	   "Packet Size: %u\n"
	   "Min Packet Size: %u\n"
	   "Max Packet Size: %u\n",
	   fmt7Info.mode,
	   fmt7Info.packetSize,
	   fmt7Info.minPacketSize,
	   fmt7Info.maxPacketSize);
}

void PrintError( Error error )
{
    error.PrintErrorTrace();
}

double current_time(void) 
{
  struct timeval time;
  if (gettimeofday(&time, NULL)!=0) printf("gettimeofday failed");
  return ((double)time.tv_sec)+((double)time.tv_usec)/1e6;
}

void CheckPGR(Error error)
{
  if (error != PGRERROR_OK)
  {
    PrintError( error );
    abort();
    //return -1;
  }
  // else
  // {
  //   return 0;
  // }
}

int CheckSaving(const char *dir)
{
  struct stat sb;
  if (!(stat(dir, &sb) == 0 && S_ISDIR(sb.st_mode)))
  {
    if (mkdir(dir, S_IRWXU | S_IRGRP | S_IROTH | S_IXGRP | S_IXOTH) != 0)
    {
      printf("Error creating directory %s\n",dir);
      return -1;
    }
  }
  char tempFileName[512];
  sprintf(tempFileName, "%stest.txt",dir);
  FILE* tempFile = fopen(tempFileName, "w+");
  if (tempFile == NULL)
  {
    printf("Failed to create file in %s.  Please check permissions.\n", dir);
    return -1;
  }
  fclose(tempFile);
  remove(tempFileName);
  //if we get here, we know the directory exists and we can write to it
  return 0;
}

void SetFrameRate(Camera* cam)
{
  // Retrieve frame rate property
  Property frameRate;
  frameRate.type = FRAME_RATE;
  CheckPGR(cam->GetProperty(&frameRate));
  //printf( "Frame rate FIRST is %3.2f fps\n", frameRate.absValue );
  
  //set frame rate to global constant k_FrameRate
  frameRate.autoManualMode = false;
  frameRate.absControl = true;
  frameRate.absValue = k_FrameRate;
  //printf("frameRate.absValue = %3.2f\n",frameRate.absValue);
  CheckPGR(cam->SetProperty(&frameRate));
  
  //check frame rate after setting
  // CheckPGR(cam[i].GetProperty(&frameRate));
  // printf( "Frame rate SECOND is %3.2f fps\n", frameRate.absValue );
}


void PGR_StopAndCleanup(PointGrey_t* PG, unsigned int numCameras)
{
  for (unsigned int i = 0; i < numCameras; i++)
  {
    // Stop capturing images
    CheckPGR(PG[i].camera.StopCapture()); 
    // Disconnect the camera
    CheckPGR(PG[i].camera.Disconnect());
  }
}     

unsigned int PGR_Init(BusManager* busMgr)
{
  unsigned int numCameras;
  CheckPGR(busMgr->GetNumOfCameras(&numCameras));
  return numCameras;
}

int PGR_SetCamera(PointGrey_t* PG)
{
  // Get the camera information
  CheckPGR(PG->camera.GetCameraInfo(&PG->cameraInfo));
  
  PrintCameraInfo(&PG->cameraInfo);
  
  // Query for available Format 7 modes
  bool supported;
  PG->format7Info.mode = k_fmt7Mode;
  CheckPGR(PG->camera.GetFormat7Info(&PG->format7Info, &supported));
  
  PrintFormat7Capabilities(PG->format7Info);
  
  if ( (k_fmt7PixFmt & PG->format7Info.pixelFormatBitField) == 0 )
  {
    // Pixel format not supported!
    printf("Pixel format is not supported\n");
    return -1;
  }
  
  PG->imageSettings.mode = k_fmt7Mode;
  PG->imageSettings.pixelFormat = k_fmt7PixFmt;
  
  if (PG->cameraInfo.serialNumber == k_FrontCamSerial)
  {
    PG->imageSettings.width = k_FrontCamWidth;
    PG->imageSettings.height = k_FrontCamHeight;
    PG->imageSettings.offsetX = (PG->format7Info.maxWidth - 
				   PG->imageSettings.width) / 2;
    PG->imageSettings.offsetY = (PG->format7Info.maxHeight - 
				   PG->imageSettings.height) / 2;
  }
  else if (PG->cameraInfo.serialNumber == k_PanoCamSerial)
  {
    PG->imageSettings.width = k_PanoCamWidth;
    PG->imageSettings.height = k_PanoCamHeight;
    PG->imageSettings.offsetX = k_PanoCamOffsetX;
    PG->imageSettings.offsetY = k_PanoCamOffsetY;
  }
  else
  {
    printf("ERROR! Camera serial number not recognized!");
    return -1;
  }
  
  printf("Image size: %d x %d\n", PG->imageSettings.width, PG->imageSettings.height);
  
  bool valid;
  // Validate the settings to make sure that they are valid
  CheckPGR(PG->camera.ValidateFormat7Settings(&PG->imageSettings,
						&valid,
						&PG->packetInfo ));
  
  if ( !valid )
  { // Settings are not valid
    printf("Format7 settings are not valid\n");
    return -1;
  }
  
  // Set the settings to the camera
  CheckPGR(PG->camera.SetFormat7Configuration(&PG->imageSettings,
						PG->packetInfo.recommendedBytesPerPacket ));
  SetFrameRate(&PG->camera);
  return 0;
}
