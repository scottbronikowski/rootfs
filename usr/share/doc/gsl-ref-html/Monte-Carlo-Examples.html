<html lang="en">
<head>
<title>Monte Carlo Examples - GNU Scientific Library -- Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Scientific Library -- Reference Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Monte-Carlo-Integration.html" title="Monte Carlo Integration">
<link rel="prev" href="VEGAS.html" title="VEGAS">
<link rel="next" href="Monte-Carlo-Integration-References-and-Further-Reading.html" title="Monte Carlo Integration References and Further Reading">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 The GSL Team.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Free Software
Needs Free Documentation'', the Front-Cover text being ``A GNU Manual'',
and with the Back-Cover Text being (a) (see below).  A copy of the
license is included in the section entitled ``GNU Free Documentation
License''.

(a) The Back-Cover Text is: ``You have the freedom to copy and modify this
GNU Manual.''-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Monte-Carlo-Examples"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Monte-Carlo-Integration-References-and-Further-Reading.html">Monte Carlo Integration References and Further Reading</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="VEGAS.html">VEGAS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Monte-Carlo-Integration.html">Monte Carlo Integration</a>
<hr>
</div>

<h3 class="section">24.5 Examples</h3>

<p>The example program below uses the Monte Carlo routines to estimate the
value of the following 3-dimensional integral from the theory of random
walks,
The analytic value of this integral can be shown to be I =
\Gamma(1/4)^4/(4 \pi^3) = 1.393203929685676859....  The integral gives
the mean time spent at the origin by a random walk on a body-centered
cubic lattice in three dimensions.

   <p>For simplicity we will compute the integral over the region
(0,0,0) to (\pi,\pi,\pi) and multiply by 8 to obtain the
full result.  The integral is slowly varying in the middle of the region
but has integrable singularities at the corners (0,0,0),
(0,\pi,\pi), (\pi,0,\pi) and (\pi,\pi,0).  The
Monte Carlo routines only select points which are strictly within the
integration region and so no special measures are needed to avoid these
singularities.

<pre class="smallexample"><pre class="verbatim">     #include &lt;stdlib.h>
     #include &lt;gsl/gsl_math.h>
     #include &lt;gsl/gsl_monte.h>
     #include &lt;gsl/gsl_monte_plain.h>
     #include &lt;gsl/gsl_monte_miser.h>
     #include &lt;gsl/gsl_monte_vegas.h>
     
     /* Computation of the integral,
     
           I = int (dx dy dz)/(2pi)^3  1/(1-cos(x)cos(y)cos(z))
     
        over (-pi,-pi,-pi) to (+pi, +pi, +pi).  The exact answer
        is Gamma(1/4)^4/(4 pi^3).  This example is taken from
        C.Itzykson, J.M.Drouffe, "Statistical Field Theory -
        Volume 1", Section 1.1, p21, which cites the original
        paper M.L.Glasser, I.J.Zucker, Proc.Natl.Acad.Sci.USA 74
        1800 (1977) */
     
     /* For simplicity we compute the integral over the region 
        (0,0,0) -> (pi,pi,pi) and multiply by 8 */
     
     double exact = 1.3932039296856768591842462603255;
     
     double
     g (double *k, size_t dim, void *params)
     {
       double A = 1.0 / (M_PI * M_PI * M_PI);
       return A / (1.0 - cos (k[0]) * cos (k[1]) * cos (k[2]));
     }
     
     void
     display_results (char *title, double result, double error)
     {
       printf ("%s ==================\n", title);
       printf ("result = % .6f\n", result);
       printf ("sigma  = % .6f\n", error);
       printf ("exact  = % .6f\n", exact);
       printf ("error  = % .6f = %.2g sigma\n", result - exact,
               fabs (result - exact) / error);
     }
     
     int
     main (void)
     {
       double res, err;
     
       double xl[3] = { 0, 0, 0 };
       double xu[3] = { M_PI, M_PI, M_PI };
     
       const gsl_rng_type *T;
       gsl_rng *r;
     
       gsl_monte_function G = { &amp;g, 3, 0 };
     
       size_t calls = 500000;
     
       gsl_rng_env_setup ();
     
       T = gsl_rng_default;
       r = gsl_rng_alloc (T);
     
       {
         gsl_monte_plain_state *s = gsl_monte_plain_alloc (3);
         gsl_monte_plain_integrate (&amp;G, xl, xu, 3, calls, r, s, 
                                    &amp;res, &amp;err);
         gsl_monte_plain_free (s);
     
         display_results ("plain", res, err);
       }
     
       {
         gsl_monte_miser_state *s = gsl_monte_miser_alloc (3);
         gsl_monte_miser_integrate (&amp;G, xl, xu, 3, calls, r, s,
                                    &amp;res, &amp;err);
         gsl_monte_miser_free (s);
     
         display_results ("miser", res, err);
       }
     
       {
         gsl_monte_vegas_state *s = gsl_monte_vegas_alloc (3);
     
         gsl_monte_vegas_integrate (&amp;G, xl, xu, 3, 10000, r, s,
                                    &amp;res, &amp;err);
         display_results ("vegas warm-up", res, err);
     
         printf ("converging...\n");
     
         do
           {
             gsl_monte_vegas_integrate (&amp;G, xl, xu, 3, calls/5, r, s,
                                        &amp;res, &amp;err);
             printf ("result = % .6f sigma = % .6f "
                     "chisq/dof = %.1f\n", res, err, gsl_monte_vegas_chisq (s));
           }
         while (fabs (gsl_monte_vegas_chisq (s) - 1.0) > 0.5);
     
         display_results ("vegas final", res, err);
     
         gsl_monte_vegas_free (s);
       }
     
       gsl_rng_free (r);
     
       return 0;
     }
</pre></pre>
   <p class="noindent">With 500,000 function calls the plain Monte Carlo algorithm achieves a
fractional error of 1%.  The estimated error <code>sigma</code> is roughly
consistent with the actual error&ndash;the computed result differs from
the true result by about 1.4 standard deviations,

<pre class="example">     plain ==================
     result =  1.412209
     sigma  =  0.013436
     exact  =  1.393204
     error  =  0.019005 = 1.4 sigma
</pre>
   <p class="noindent">The <span class="sc">miser</span> algorithm reduces the error by a factor of four, and also
correctly estimates the error,

<pre class="example">     miser ==================
     result =  1.391322
     sigma  =  0.003461
     exact  =  1.393204
     error  = -0.001882 = 0.54 sigma
</pre>
   <p class="noindent">In the case of the <span class="sc">vegas</span> algorithm the program uses an initial
warm-up run of 10,000 function calls to prepare, or &ldquo;warm up&rdquo;, the grid. 
This is followed by a main run with five iterations of 100,000 function
calls. The chi-squared per degree of freedom for the five iterations are
checked for consistency with 1, and the run is repeated if the results
have not converged. In this case the estimates are consistent on the
first pass.

<pre class="example">     vegas warm-up ==================
     result =  1.392673
     sigma  =  0.003410
     exact  =  1.393204
     error  = -0.000531 = 0.16 sigma
     converging...
     result =  1.393281 sigma =  0.000362 chisq/dof = 1.5
     vegas final ==================
     result =  1.393281
     sigma  =  0.000362
     exact  =  1.393204
     error  =  0.000077 = 0.21 sigma
</pre>
   <p class="noindent">If the value of <code>chisq</code> had differed significantly from 1 it would
indicate inconsistent results, with a correspondingly underestimated
error.  The final estimate from <span class="sc">vegas</span> (using a similar number of
function calls) is significantly more accurate than the other two
algorithms.

<hr>The GNU Scientific Library - a free numerical library licensed under the GNU GPL<br>Back to the <a href="/software/gsl/">GNU Scientific Library Homepage</a></body></html>

