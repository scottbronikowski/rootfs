<html lang="en">
<head>
<title>Representation of floating point numbers - GNU Scientific Library -- Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Scientific Library -- Reference Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="IEEE-floating_002dpoint-arithmetic.html" title="IEEE floating-point arithmetic">
<link rel="next" href="Setting-up-your-IEEE-environment.html" title="Setting up your IEEE environment">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 The GSL Team.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Free Software
Needs Free Documentation'', the Front-Cover text being ``A GNU Manual'',
and with the Back-Cover Text being (a) (see below).  A copy of the
license is included in the section entitled ``GNU Free Documentation
License''.

(a) The Back-Cover Text is: ``You have the freedom to copy and modify this
GNU Manual.''-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Representation-of-floating-point-numbers"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Setting-up-your-IEEE-environment.html">Setting up your IEEE environment</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="IEEE-floating_002dpoint-arithmetic.html">IEEE floating-point arithmetic</a>
<hr>
</div>

<h3 class="section">41.1 Representation of floating point numbers</h3>

<p><a name="index-IEEE-format-for-floating-point-numbers-2678"></a><a name="index-bias_002c-IEEE-format-2679"></a><a name="index-exponent_002c-IEEE-format-2680"></a><a name="index-sign-bit_002c-IEEE-format-2681"></a><a name="index-mantissa_002c-IEEE-format-2682"></a>The IEEE Standard for Binary Floating-Point Arithmetic defines binary
formats for single and double precision numbers.  Each number is composed
of three parts: a <dfn>sign bit</dfn> (s), an <dfn>exponent</dfn>
(E) and a <dfn>fraction</dfn> (f).  The numerical value of the
combination (s,E,f) is given by the following formula,
<a name="index-normalized-form_002c-IEEE-format-2683"></a><a name="index-denormalized-form_002c-IEEE-format-2684"></a>The sign bit is either zero or one.  The exponent ranges from a minimum value
<!-- {$E_{min}$} -->
E_min
to a maximum value
<!-- {$E_{max}$} -->
E_max depending on the precision.  The exponent is converted to an
unsigned number
e, known as the <dfn>biased exponent</dfn>, for storage by adding a
<dfn>bias</dfn> parameter,
<!-- {$e = E + \hbox{\it bias}$} -->
e = E + bias. 
The sequence fffff... represents the digits of the binary
fraction f.  The binary digits are stored in <dfn>normalized
form</dfn>, by adjusting the exponent to give a leading digit of 1. 
Since the leading digit is always 1 for normalized numbers it is
assumed implicitly and does not have to be stored. 
Numbers smaller than
<!-- {$2^{E_{min}}$} -->
2^(E_min)
are be stored in <dfn>denormalized form</dfn> with a leading zero,
<a name="index-zero_002c-IEEE-format-2685"></a><a name="index-infinity_002c-IEEE-format-2686"></a>This allows gradual underflow down to
<!-- {$2^{E_{min} - p}$} -->
2^(E_min - p) for p bits of precision. 
A zero is encoded with the special exponent of
<!-- {$2^{E_{min}-1}$} -->
2^(E_min - 1) and infinities with the exponent of
<!-- {$2^{E_{max}+1}$} -->
2^(E_max + 1).

<p class="noindent"><a name="index-single-precision_002c-IEEE-format-2687"></a>The format for single precision numbers uses 32 bits divided in the
following way,

<pre class="smallexample">     seeeeeeeefffffffffffffffffffffff
     
     s = sign bit, 1 bit
     e = exponent, 8 bits  (E_min=-126, E_max=127, bias=127)
     f = fraction, 23 bits
</pre>
   <p class="noindent"><a name="index-double-precision_002c-IEEE-format-2688"></a>The format for double precision numbers uses 64 bits divided in the
following way,

<pre class="smallexample">     seeeeeeeeeeeffffffffffffffffffffffffffffffffffffffffffffffffffff
     
     s = sign bit, 1 bit
     e = exponent, 11 bits  (E_min=-1022, E_max=1023, bias=1023)
     f = fraction, 52 bits
</pre>
   <p class="noindent">It is often useful to be able to investigate the behavior of a
calculation at the bit-level and the library provides functions for
printing the IEEE representations in a human-readable form.

<!-- float vs double vs long double -->
<!-- (how many digits are available for each) -->
<div class="defun">
&mdash; Function: void <b>gsl_ieee_fprintf_float</b> (<var>FILE * stream, const float * x</var>)<var><a name="index-gsl_005fieee_005ffprintf_005ffloat-2689"></a></var><br>
&mdash; Function: void <b>gsl_ieee_fprintf_double</b> (<var>FILE * stream, const double * x</var>)<var><a name="index-gsl_005fieee_005ffprintf_005fdouble-2690"></a></var><br>
<blockquote><p>These functions output a formatted version of the IEEE floating-point
number pointed to by <var>x</var> to the stream <var>stream</var>. A pointer is
used to pass the number indirectly, to avoid any undesired promotion
from <code>float</code> to <code>double</code>.  The output takes one of the
following forms,

          <dl>
<dt><code>NaN</code><dd>the Not-a-Number symbol

          <br><dt><code>Inf, -Inf</code><dd>positive or negative infinity

          <br><dt><code>1.fffff...*2^E, -1.fffff...*2^E</code><dd>a normalized floating point number

          <br><dt><code>0.fffff...*2^E, -0.fffff...*2^E</code><dd>a denormalized floating point number

          <br><dt><code>0, -0</code><dd>positive or negative zero

          <!-- @item [non-standard IEEE float], [non-standard IEEE double] -->
          <!-- an unrecognized encoding -->
        </dl>

        <p>The output can be used directly in GNU Emacs Calc mode by preceding it
with <code>2#</code> to indicate binary. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>gsl_ieee_printf_float</b> (<var>const float * x</var>)<var><a name="index-gsl_005fieee_005fprintf_005ffloat-2691"></a></var><br>
&mdash; Function: void <b>gsl_ieee_printf_double</b> (<var>const double * x</var>)<var><a name="index-gsl_005fieee_005fprintf_005fdouble-2692"></a></var><br>
<blockquote><p>These functions output a formatted version of the IEEE floating-point
number pointed to by <var>x</var> to the stream <code>stdout</code>. 
</p></blockquote></div>

<p class="noindent">The following program demonstrates the use of the functions by printing
the single and double precision representations of the fraction
1/3.  For comparison the representation of the value promoted from
single to double precision is also printed.

<pre class="example"><pre class="verbatim">     #include &lt;stdio.h>
     #include &lt;gsl/gsl_ieee_utils.h>
     
     int
     main (void) 
     {
       float f = 1.0/3.0;
       double d = 1.0/3.0;
     
       double fd = f; /* promote from float to double */
       
       printf (" f="); gsl_ieee_printf_float(&amp;f); 
       printf ("\n");
     
       printf ("fd="); gsl_ieee_printf_double(&amp;fd); 
       printf ("\n");
     
       printf (" d="); gsl_ieee_printf_double(&amp;d); 
       printf ("\n");
     
       return 0;
     }
</pre></pre>
   <p class="noindent">The binary representation of 1/3 is 0.01010101... .  The
output below shows that the IEEE format normalizes this fraction to give
a leading digit of 1,

<pre class="smallexample">      f= 1.01010101010101010101011*2^-2
     fd= 1.0101010101010101010101100000000000000000000000000000*2^-2
      d= 1.0101010101010101010101010101010101010101010101010101*2^-2
</pre>
   <p class="noindent">The output also shows that a single-precision number is promoted to
double-precision by adding zeros in the binary representation.

<!-- importance of using 1.234L in long double calculations -->
<!-- @example -->
<!-- int main (void) -->
<!-- @{ -->
<!-- long double x = 1.0, y = 1.0; -->
<!-- x = x + 0.2; -->
<!-- y = y + 0.2L; -->
<!-- printf(" d %.20Lf\n",x); -->
<!-- printf("ld %.20Lf\n",y); -->
<!-- return 1; -->
<!-- @} -->
<!-- d 1.20000000000000001110 -->
<!-- ld 1.20000000000000000004 -->
<!-- @end example -->
<hr>The GNU Scientific Library - a free numerical library licensed under the GNU GPL<br>Back to the <a href="/software/gsl/">GNU Scientific Library Homepage</a></body></html>

