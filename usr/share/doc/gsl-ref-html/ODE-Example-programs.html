<html lang="en">
<head>
<title>ODE Example programs - GNU Scientific Library -- Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Scientific Library -- Reference Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Ordinary-Differential-Equations.html" title="Ordinary Differential Equations">
<link rel="prev" href="Driver.html" title="Driver">
<link rel="next" href="ODE-References-and-Further-Reading.html" title="ODE References and Further Reading">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 The GSL Team.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Free Software
Needs Free Documentation'', the Front-Cover text being ``A GNU Manual'',
and with the Back-Cover Text being (a) (see below).  A copy of the
license is included in the section entitled ``GNU Free Documentation
License''.

(a) The Back-Cover Text is: ``You have the freedom to copy and modify this
GNU Manual.''-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="ODE-Example-programs"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="ODE-References-and-Further-Reading.html">ODE References and Further Reading</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Driver.html">Driver</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Ordinary-Differential-Equations.html">Ordinary Differential Equations</a>
<hr>
</div>

<h3 class="section">26.6 Examples</h3>

<p><a name="index-Van-der-Pol-oscillator_002c-example-2235"></a>The following program solves the second-order nonlinear Van der Pol
oscillator equation,
This can be converted into a first order system suitable for use with
the routines described in this chapter by introducing a separate
variable for the velocity, y = x'(t),
The program begins by defining functions for these derivatives and
their Jacobian. The main function uses driver level functions to solve
the problem. The program evolves the solution from (y, y\prime) = (1,
0) at t=0 to t=100.  The step-size h is
automatically adjusted by the controller to maintain an absolute
accuracy of <!-- {$10^{-6}$} -->
10^{-6} in the function values
<var>y</var>.  The loop in the example prints the solution at the points
t_i = 1, 2, \dots, 100.

<pre class="example"><pre class="verbatim">     #include &lt;stdio.h>
     #include &lt;gsl/gsl_errno.h>
     #include &lt;gsl/gsl_matrix.h>
     #include &lt;gsl/gsl_odeiv2.h>
     
     int
     func (double t, const double y[], double f[],
           void *params)
     {
       double mu = *(double *)params;
       f[0] = y[1];
       f[1] = -y[0] - mu*y[1]*(y[0]*y[0] - 1);
       return GSL_SUCCESS;
     }
     
     int
     jac (double t, const double y[], double *dfdy, 
          double dfdt[], void *params)
     {
       double mu = *(double *)params;
       gsl_matrix_view dfdy_mat 
         = gsl_matrix_view_array (dfdy, 2, 2);
       gsl_matrix * m = &amp;dfdy_mat.matrix; 
       gsl_matrix_set (m, 0, 0, 0.0);
       gsl_matrix_set (m, 0, 1, 1.0);
       gsl_matrix_set (m, 1, 0, -2.0*mu*y[0]*y[1] - 1.0);
       gsl_matrix_set (m, 1, 1, -mu*(y[0]*y[0] - 1.0));
       dfdt[0] = 0.0;
       dfdt[1] = 0.0;
       return GSL_SUCCESS;
     }
     
     int
     main (void)
     {
       double mu = 10;
       gsl_odeiv2_system sys = {func, jac, 2, &amp;mu};
     
       gsl_odeiv2_driver * d = 
         gsl_odeiv2_driver_alloc_y_new (&amp;sys, gsl_odeiv2_step_rk8pd,
     				  1e-6, 1e-6, 0.0);
       int i;
       double t = 0.0, t1 = 100.0;
       double y[2] = { 1.0, 0.0 };
     
       for (i = 1; i &lt;= 100; i++)
         {
           double ti = i * t1 / 100.0;
           int status = gsl_odeiv2_driver_apply (d, &amp;t, ti, y);
     
           if (status != GSL_SUCCESS)
     	{
     	  printf ("error, return value=%d\n", status);
     	  break;
     	}
     
           printf ("%.5e %.5e %.5e\n", t, y[0], y[1]);
         }
     
       gsl_odeiv2_driver_free (d);
       return 0;
     }
</pre></pre>
   <p class="noindent">The user can work with the lower level functions directly, as in
the following example. In this case an intermediate result is printed
after each successful step instead of equidistant time points.

<pre class="example"><pre class="verbatim">     int
     main (void)
     {
       const gsl_odeiv2_step_type * T 
         = gsl_odeiv2_step_rk8pd;
     
       gsl_odeiv2_step * s 
         = gsl_odeiv2_step_alloc (T, 2);
       gsl_odeiv2_control * c 
         = gsl_odeiv2_control_y_new (1e-6, 0.0);
       gsl_odeiv2_evolve * e 
         = gsl_odeiv2_evolve_alloc (2);
     
       double mu = 10;
       gsl_odeiv2_system sys = {func, jac, 2, &amp;mu};
     
       double t = 0.0, t1 = 100.0;
       double h = 1e-6;
       double y[2] = { 1.0, 0.0 };
     
       while (t &lt; t1)
         {
           int status = gsl_odeiv2_evolve_apply (e, c, s,
                                                &amp;sys, 
                                                &amp;t, t1,
                                                &amp;h, y);
     
           if (status != GSL_SUCCESS)
               break;
     
           printf ("%.5e %.5e %.5e\n", t, y[0], y[1]);
         }
     
       gsl_odeiv2_evolve_free (e);
       gsl_odeiv2_control_free (c);
       gsl_odeiv2_step_free (s);
       return 0;
     }
</pre></pre>
   <p class="noindent">For functions with multiple parameters, the appropriate information
can be passed in through the <var>params</var> argument in
<code>gsl_odeiv2_system</code> definition (<var>mu</var> in this example) by using
a pointer to a struct.

<p class="noindent">It is also possible to work with a non-adaptive integrator, using only
the stepping function itself,
<code>gsl_odeiv2_driver_apply_fixed_step</code> or
<code>gsl_odeiv2_evolve_apply_fixed_step</code>. The following program uses
the driver level function, with fourth-order
Runge-Kutta stepping function with a fixed stepsize of
0.001.

<pre class="example"><pre class="verbatim">     int
     main (void)
     {
       double mu = 10;
       gsl_odeiv2_system sys = { func, jac, 2, &amp;mu };
     
       gsl_odeiv2_driver *d =
         gsl_odeiv2_driver_alloc_y_new (&amp;sys, gsl_odeiv2_step_rk4,
                                        1e-3, 1e-8, 1e-8);
     
       double t = 0.0;
       double y[2] = { 1.0, 0.0 };
       int i, s;
     
       for (i = 0; i &lt; 100; i++)
         {
           s = gsl_odeiv2_driver_apply_fixed_step (d, &amp;t, 1e-3, 1000, y);
     
           if (s != GSL_SUCCESS)
             {
               printf ("error: driver returned %d\n", s);
               break;
             }
     
           printf ("%.5e %.5e %.5e\n", t, y[0], y[1]);
         }
     
       gsl_odeiv2_driver_free (d);
       return s;
     }
</pre></pre>
<hr>The GNU Scientific Library - a free numerical library licensed under the GNU GPL<br>Back to the <a href="/software/gsl/">GNU Scientific Library Homepage</a></body></html>

