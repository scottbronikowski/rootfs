<html lang="en">
<head>
<title>Singular Value Decomposition - GNU Scientific Library -- Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Scientific Library -- Reference Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Linear-Algebra.html" title="Linear Algebra">
<link rel="prev" href="QR-Decomposition-with-Column-Pivoting.html" title="QR Decomposition with Column Pivoting">
<link rel="next" href="Cholesky-Decomposition.html" title="Cholesky Decomposition">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 The GSL Team.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Free Software
Needs Free Documentation'', the Front-Cover text being ``A GNU Manual'',
and with the Back-Cover Text being (a) (see below).  A copy of the
license is included in the section entitled ``GNU Free Documentation
License''.

(a) The Back-Cover Text is: ``You have the freedom to copy and modify this
GNU Manual.''-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Singular-Value-Decomposition"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Cholesky-Decomposition.html">Cholesky Decomposition</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="QR-Decomposition-with-Column-Pivoting.html">QR Decomposition with Column Pivoting</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Linear-Algebra.html">Linear Algebra</a>
<hr>
</div>

<h3 class="section">14.4 Singular Value Decomposition</h3>

<p><a name="index-SVD-1336"></a><a name="index-singular-value-decomposition-1337"></a>
A general rectangular M-by-N matrix A has a
singular value decomposition (<span class="sc">svd</span>) into the product of an
M-by-N orthogonal matrix U, an N-by-N
diagonal matrix of singular values S and the transpose of an
N-by-N orthogonal square matrix V,
The singular values
<!-- {$\sigma_i = S_{ii}$} -->
\sigma_i = S_{ii} are all non-negative and are
generally chosen to form a non-increasing sequence
<!-- {$\sigma_1 \ge \sigma_2 \ge ... \ge \sigma_N \ge 0$} -->
\sigma_1 &gt;= \sigma_2 &gt;= ... &gt;= \sigma_N &gt;= 0.

   <p>The singular value decomposition of a matrix has many practical uses. 
The condition number of the matrix is given by the ratio of the largest
singular value to the smallest singular value. The presence of a zero
singular value indicates that the matrix is singular. The number of
non-zero singular values indicates the rank of the matrix.  In practice
singular value decomposition of a rank-deficient matrix will not produce
exact zeroes for singular values, due to finite numerical
precision.  Small singular values should be edited by choosing a suitable
tolerance.

   <p>For a rank-deficient matrix, the null space of A is given by
the columns of V corresponding to the zero singular values. 
Similarly, the range of A is given by columns of U
corresponding to the non-zero singular values.

   <p>Note that the routines here compute the &ldquo;thin&rdquo; version of the SVD
with U as M-by-N orthogonal matrix. This allows
in-place computation and is the most commonly-used form in practice. 
Mathematically, the &ldquo;full&rdquo; SVD is defined with U as an
M-by-M orthogonal matrix and S as an
M-by-N diagonal matrix (with additional rows of zeros).

<div class="defun">
&mdash; Function: int <b>gsl_linalg_SV_decomp</b> (<var>gsl_matrix * A, gsl_matrix * V, gsl_vector * S, gsl_vector * work</var>)<var><a name="index-gsl_005flinalg_005fSV_005fdecomp-1338"></a></var><br>
<blockquote><p>This function factorizes the M-by-N matrix <var>A</var> into
the singular value decomposition A = U S V^T for <!-- {$M \ge N$} -->
M &gt;= N.  On output the matrix <var>A</var> is replaced by
U. The diagonal elements of the singular value matrix S
are stored in the vector <var>S</var>. The singular values are non-negative
and form a non-increasing sequence from S_1 to S_N. The
matrix <var>V</var> contains the elements of V in untransposed
form. To form the product U S V^T it is necessary to take the
transpose of <var>V</var>.  A workspace of length <var>N</var> is required in
<var>work</var>.

        <p>This routine uses the Golub-Reinsch SVD algorithm. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>gsl_linalg_SV_decomp_mod</b> (<var>gsl_matrix * A, gsl_matrix * X, gsl_matrix * V, gsl_vector * S, gsl_vector * work</var>)<var><a name="index-gsl_005flinalg_005fSV_005fdecomp_005fmod-1339"></a></var><br>
<blockquote><p>This function computes the SVD using the modified Golub-Reinsch
algorithm, which is faster for <!-- {$M \gg N$} -->
M&gt;&gt;N.  It requires the vector <var>work</var> of length <var>N</var> and the
N-by-N matrix <var>X</var> as additional working space. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>gsl_linalg_SV_decomp_jacobi</b> (<var>gsl_matrix * A, gsl_matrix * V, gsl_vector * S</var>)<var><a name="index-gsl_005flinalg_005fSV_005fdecomp_005fjacobi-1340"></a></var><br>
<blockquote><p><a name="index-Jacobi-orthogonalization-1341"></a>This function computes the SVD of the M-by-N matrix <var>A</var>
using one-sided Jacobi orthogonalization for <!-- {$M \ge N$} -->
M &gt;= N.  The Jacobi method can compute singular values to higher
relative accuracy than Golub-Reinsch algorithms (see references for
details). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>gsl_linalg_SV_solve</b> (<var>const gsl_matrix * U, const gsl_matrix * V, const gsl_vector * S, const gsl_vector * b, gsl_vector * x</var>)<var><a name="index-gsl_005flinalg_005fSV_005fsolve-1342"></a></var><br>
<blockquote><p>This function solves the system A x = b using the singular value
decomposition (<var>U</var>, <var>S</var>, <var>V</var>) of A which must
have been computed previously with <code>gsl_linalg_SV_decomp</code>.

        <p>Only non-zero singular values are used in computing the solution. The
parts of the solution corresponding to singular values of zero are
ignored.  Other singular values can be edited out by setting them to
zero before calling this function.

        <p>In the over-determined case where <var>A</var> has more rows than columns the
system is solved in the least squares sense, returning the solution
<var>x</var> which minimizes ||A x - b||_2. 
</p></blockquote></div>

<hr>The GNU Scientific Library - a free numerical library licensed under the GNU GPL<br>Back to the <a href="/software/gsl/">GNU Scientific Library Homepage</a></body></html>

