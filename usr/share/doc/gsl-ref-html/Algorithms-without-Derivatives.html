<html lang="en">
<head>
<title>Algorithms without Derivatives - GNU Scientific Library -- Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Scientific Library -- Reference Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Multidimensional-Root_002dFinding.html" title="Multidimensional Root-Finding">
<link rel="prev" href="Algorithms-using-Derivatives.html" title="Algorithms using Derivatives">
<link rel="next" href="Example-programs-for-Multidimensional-Root-finding.html" title="Example programs for Multidimensional Root finding">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 The GSL Team.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Free Software
Needs Free Documentation'', the Front-Cover text being ``A GNU Manual'',
and with the Back-Cover Text being (a) (see below).  A copy of the
license is included in the section entitled ``GNU Free Documentation
License''.

(a) The Back-Cover Text is: ``You have the freedom to copy and modify this
GNU Manual.''-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Algorithms-without-Derivatives"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Example-programs-for-Multidimensional-Root-finding.html">Example programs for Multidimensional Root finding</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Algorithms-using-Derivatives.html">Algorithms using Derivatives</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Multidimensional-Root_002dFinding.html">Multidimensional Root-Finding</a>
<hr>
</div>

<h3 class="section">35.7 Algorithms without Derivatives</h3>

<p>The algorithms described in this section do not require any derivative
information to be supplied by the user.  Any derivatives needed are
approximated by finite differences.  Note that if the
finite-differencing step size chosen by these routines is inappropriate,
an explicit user-supplied numerical derivative can always be used with
the algorithms described in the previous section.

<div class="defun">
&mdash; Solver: <b>gsl_multiroot_fsolver_hybrids</b><var><a name="index-gsl_005fmultiroot_005ffsolver_005fhybrids-2503"></a></var><br>
<blockquote><p><a name="index-HYBRIDS-algorithm_002c-scaled-without-derivatives-2504"></a>This is a version of the Hybrid algorithm which replaces calls to the
Jacobian function by its finite difference approximation.  The finite
difference approximation is computed using <code>gsl_multiroots_fdjac</code>
with a relative step size of <code>GSL_SQRT_DBL_EPSILON</code>.  Note that
this step size will not be suitable for all problems. 
</p></blockquote></div>

<div class="defun">
&mdash; Solver: <b>gsl_multiroot_fsolver_hybrid</b><var><a name="index-gsl_005fmultiroot_005ffsolver_005fhybrid-2505"></a></var><br>
<blockquote><p><a name="index-HYBRID-algorithm_002c-unscaled-without-derivatives-2506"></a>This is a finite difference version of the Hybrid algorithm without
internal scaling. 
</p></blockquote></div>

<!-- ============================================================ -->
<div class="defun">
&mdash; Solver: <b>gsl_multiroot_fsolver_dnewton</b><var><a name="index-gsl_005fmultiroot_005ffsolver_005fdnewton-2507"></a></var><br>
<blockquote>
        <p><a name="index-Discrete-Newton-algorithm-for-multidimensional-roots-2508"></a><a name="index-Newton-algorithm_002c-discrete-2509"></a>
The <dfn>discrete Newton algorithm</dfn> is the simplest method of solving a
multidimensional system.  It uses the Newton iteration
     where the Jacobian matrix J is approximated by taking finite
differences of the function <var>f</var>.  The approximation scheme used by
this implementation is,
     where \delta_j is a step of size \sqrt\epsilon |x_j| with
\epsilon being the machine precision
(<!-- {$\epsilon \approx 2.22 \times 10^{-16}$} -->
\epsilon \approx 2.22 \times 10^-16). 
The order of convergence of Newton's algorithm is quadratic, but the
finite differences require n^2 function evaluations on each
iteration.  The algorithm may become unstable if the finite differences
are not a good approximation to the true derivatives. 
</p></blockquote></div>

<!-- ============================================================ -->
<div class="defun">
&mdash; Solver: <b>gsl_multiroot_fsolver_broyden</b><var><a name="index-gsl_005fmultiroot_005ffsolver_005fbroyden-2510"></a></var><br>
<blockquote><p><a name="index-Broyden-algorithm-for-multidimensional-roots-2511"></a><a name="index-multidimensional-root-finding_002c-Broyden-algorithm-2512"></a>
The <dfn>Broyden algorithm</dfn> is a version of the discrete Newton
algorithm which attempts to avoids the expensive update of the Jacobian
matrix on each iteration.  The changes to the Jacobian are also
approximated, using a rank-1 update,
     where the vectors dx and df are the changes in x
and f.  On the first iteration the inverse Jacobian is estimated
using finite differences, as in the discrete Newton algorithm.

        <p>This approximation gives a fast update but is unreliable if the changes
are not small, and the estimate of the inverse Jacobian becomes worse as
time passes.  The algorithm has a tendency to become unstable unless it
starts close to the root.  The Jacobian is refreshed if this instability
is detected (consult the source for details).

        <p>This algorithm is included only for demonstration purposes, and is not
recommended for serious use. 
</p></blockquote></div>

<!-- ============================================================ -->
<hr>The GNU Scientific Library - a free numerical library licensed under the GNU GPL<br>Back to the <a href="/software/gsl/">GNU Scientific Library Homepage</a></body></html>

