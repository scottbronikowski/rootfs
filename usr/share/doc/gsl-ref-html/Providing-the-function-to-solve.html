<html lang="en">
<head>
<title>Providing the function to solve - GNU Scientific Library -- Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Scientific Library -- Reference Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="One-dimensional-Root_002dFinding.html" title="One dimensional Root-Finding">
<link rel="prev" href="Initializing-the-Solver.html" title="Initializing the Solver">
<link rel="next" href="Search-Bounds-and-Guesses.html" title="Search Bounds and Guesses">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 The GSL Team.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Free Software
Needs Free Documentation'', the Front-Cover text being ``A GNU Manual'',
and with the Back-Cover Text being (a) (see below).  A copy of the
license is included in the section entitled ``GNU Free Documentation
License''.

(a) The Back-Cover Text is: ``You have the freedom to copy and modify this
GNU Manual.''-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Providing-the-function-to-solve"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Search-Bounds-and-Guesses.html">Search Bounds and Guesses</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Initializing-the-Solver.html">Initializing the Solver</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="One-dimensional-Root_002dFinding.html">One dimensional Root-Finding</a>
<hr>
</div>

<h3 class="section">33.4 Providing the function to solve</h3>

<p><a name="index-root-finding_002c-providing-a-function-to-solve-2395"></a>
You must provide a continuous function of one variable for the root
finders to operate on, and, sometimes, its first derivative.  In order
to allow for general parameters the functions are defined by the
following data types:

<div class="defun">
&mdash; Data Type: <b>gsl_function</b><var><a name="index-gsl_005ffunction-2396"></a></var><br>
<blockquote><p>This data type defines a general function with parameters.

          <dl>
<dt><code>double (* function) (double </code><var>x</var><code>, void * </code><var>params</var><code>)</code><dd>this function should return the value
<!-- {$f(x,\hbox{\it params})$} -->
f(x,params) for argument <var>x</var> and parameters <var>params</var>

          <br><dt><code>void * params</code><dd>a pointer to the parameters of the function
</dl>
        </p></blockquote></div>

   <p>Here is an example for the general quadratic function,
with a = 3, b = 2, c = 1.  The following code
defines a <code>gsl_function</code> <code>F</code> which you could pass to a root
finder as a function pointer:

<pre class="example">     struct my_f_params { double a; double b; double c; };
     
     double
     my_f (double x, void * p) {
        struct my_f_params * params
          = (struct my_f_params *)p;
        double a = (params-&gt;a);
        double b = (params-&gt;b);
        double c = (params-&gt;c);
     
        return  (a * x + b) * x + c;
     }
     
     gsl_function F;
     struct my_f_params params = { 3.0, 2.0, 1.0 };
     
     F.function = &amp;my_f;
     F.params = &amp;params;
</pre>
   <p class="noindent">The function f(x) can be evaluated using the macro
<code>GSL_FN_EVAL(&amp;F,x)</code> defined in <samp><span class="file">gsl_math.h</span></samp>.

<div class="defun">
&mdash; Data Type: <b>gsl_function_fdf</b><var><a name="index-gsl_005ffunction_005ffdf-2397"></a></var><br>
<blockquote><p>This data type defines a general function with parameters and its first
derivative.

          <dl>
<dt><code>double (* f) (double </code><var>x</var><code>, void * </code><var>params</var><code>)</code><dd>this function should return the value of
<!-- {$f(x,\hbox{\it params})$} -->
f(x,params) for argument <var>x</var> and parameters <var>params</var>

          <br><dt><code>double (* df) (double </code><var>x</var><code>, void * </code><var>params</var><code>)</code><dd>this function should return the value of the derivative of <var>f</var> with
respect to <var>x</var>,
<!-- {$f'(x,\hbox{\it params})$} -->
f'(x,params), for argument <var>x</var> and parameters <var>params</var>

          <br><dt><code>void (* fdf) (double </code><var>x</var><code>, void * </code><var>params</var><code>, double * </code><var>f</var><code>, double * </code><var>df</var><code>)</code><dd>this function should set the values of the function <var>f</var> to
<!-- {$f(x,\hbox{\it params})$} -->
f(x,params)
and its derivative <var>df</var> to
<!-- {$f'(x,\hbox{\it params})$} -->
f'(x,params)
for argument <var>x</var> and parameters <var>params</var>.  This function
provides an optimization of the separate functions for f(x) and
f'(x)&mdash;it is always faster to compute the function and its
derivative at the same time.

          <br><dt><code>void * params</code><dd>a pointer to the parameters of the function
</dl>
        </p></blockquote></div>

   <p>Here is an example where
<!-- {$f(x) = \exp(2x)$} -->
f(x) = 2\exp(2x):

<pre class="example">     double
     my_f (double x, void * params)
     {
        return exp (2 * x);
     }
     
     double
     my_df (double x, void * params)
     {
        return 2 * exp (2 * x);
     }
     
     void
     my_fdf (double x, void * params,
             double * f, double * df)
     {
        double t = exp (2 * x);
     
        *f = t;
        *df = 2 * t;   /* uses existing value */
     }
     
     gsl_function_fdf FDF;
     
     FDF.f = &amp;my_f;
     FDF.df = &amp;my_df;
     FDF.fdf = &amp;my_fdf;
     FDF.params = 0;
</pre>
   <p class="noindent">The function f(x) can be evaluated using the macro
<code>GSL_FN_FDF_EVAL_F(&amp;FDF,x)</code> and the derivative f'(x) can
be evaluated using the macro <code>GSL_FN_FDF_EVAL_DF(&amp;FDF,x)</code>.  Both
the function y = f(x) and its derivative dy = f'(x) can
be evaluated at the same time using the macro
<code>GSL_FN_FDF_EVAL_F_DF(&amp;FDF,x,y,dy)</code>.  The macro stores
f(x) in its <var>y</var> argument and f'(x) in its <var>dy</var>
argument&mdash;both of these should be pointers to <code>double</code>.

<hr>The GNU Scientific Library - a free numerical library licensed under the GNU GPL<br>Back to the <a href="/software/gsl/">GNU Scientific Library Homepage</a></body></html>

