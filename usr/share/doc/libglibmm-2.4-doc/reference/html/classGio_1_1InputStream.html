<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>glibmm: Gio::InputStream Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="/home/murrayc/checkouts/gnome30/glibmm/docs/doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.32.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceGio.html">Gio</a> </li>
      <li class="navelem"><a class="el" href="classGio_1_1InputStream.html">InputStream</a> </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> </div>
  <div class="headertitle">
<div class="title">Gio::InputStream Class Reference<div class="ingroups"><a class="el" href="group__Streams.html">Stream Classes</a></div></div> </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Gio::InputStream" --><!-- doxytag: inherits="Glib::Object" -->
<p>Base class for implementing streaming input.  <a href="classGio_1_1InputStream.html#details">More...</a></p>

<p><code>#include &lt;giomm/inputstream.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gio::InputStream:</div>
<div class="dyncontent">
<div class="center"><img src="classGio_1_1InputStream__inherit__graph.png" border="0" usemap="#Gio_1_1InputStream_inherit__map" alt="Inheritance graph"/></div>
<map name="Gio_1_1InputStream_inherit__map" id="Gio_1_1InputStream_inherit__map">
<area shape="rect" id="node9" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file." alt="" coords="684,5,833,35"/><area shape="rect" id="node11" href="classGio_1_1FilterInputStream.html" title="Filter Input Stream." alt="" coords="679,59,839,88"/><area shape="rect" id="node17" href="classGio_1_1MemoryInputStream.html" title="MemoryInputStream implements InputStream for arbitrary memory chunks." alt="" coords="668,112,849,141"/><area shape="rect" id="node19" href="classGio_1_1UnixInputStream.html" title="UnixInputStream implements InputStream for reading from a unix file descriptor, including asynchronou..." alt="" coords="680,165,837,195"/><area shape="rect" id="node2" href="classGlib_1_1Object.html" title="Glib::Object" alt="" coords="345,85,439,115"/><area shape="rect" id="node4" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="169,85,295,115"/><area shape="rect" id="node6" href="../../../libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="5,85,120,115"/><area shape="rect" id="node13" href="classGio_1_1BufferedInputStream.html" title="The buffered input stream implements FilterInputStream and provides for buffered reads." alt="" coords="900,59,1084,88"/><area shape="rect" id="node15" href="classGio_1_1DataInputStream.html" title="An implementation of BufferedInputStream that allows for high&#45;level data manipulation of arbitrary da..." alt="" coords="1133,59,1296,88"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGio_1_1InputStream-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#afff624e3125add13c88e8a99907ba903">~InputStream</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GInputStream*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a2ed1120b3d03a12086e7f0ed3946aba1">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a2ed1120b3d03a12086e7f0ed3946aba1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GInputStream*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a1b0ef82ab81b3ded607584c7029fe1e9">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a1b0ef82ab81b3ded607584c7029fe1e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GInputStream*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a28a9394b07e9183c0c79798ea344c65c">gobj_copy</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. <a href="#a28a9394b07e9183c0c79798ea344c65c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a49a1f4219f96c7fafdcf1ed12eb443e2">read</a> (void* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. <a href="#a49a1f4219f96c7fafdcf1ed12eb443e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a42ab2486116d40f6ef828277befb508a">read</a> (void* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. <a href="#a42ab2486116d40f6ef828277befb508a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a1dc8a2babf32f93a0a5dccc0c39e0959">read_all</a> (void* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, gsize&amp; bytes_read, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. <a href="#a1dc8a2babf32f93a0a5dccc0c39e0959"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a6da0fc57d1a5df7107370c67e84aa496">read_all</a> (void* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, gsize&amp; bytes_read)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. <a href="#a6da0fc57d1a5df7107370c67e84aa496"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a17ea65f35c15043156db90af831a44a3">skip</a> (gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to skip <em>count</em> bytes from the stream. <a href="#a17ea65f35c15043156db90af831a44a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a1ea9146d612c666168886734b79a5d65">skip</a> (gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to skip <em>count</em> bytes from the stream. <a href="#a1ea9146d612c666168886734b79a5d65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a1b76b2503e607475f63731a886456e09">close</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the stream, releasing resources related to it. <a href="#a1b76b2503e607475f63731a886456e09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a7a3202cf7014bcfb2c0a7f301448ae50">close</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the stream, releasing resources related to it. <a href="#a7a3202cf7014bcfb2c0a7f301448ae50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a5b7762ee3f3c571fbc59a0c9af6e879e">read_async</a> (void* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request an asynchronous read of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. <a href="#a5b7762ee3f3c571fbc59a0c9af6e879e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a05bea76fa9ac3c098a167d2b377e36a6">read_async</a> (void* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request an asynchronous read of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. <a href="#a05bea76fa9ac3c098a167d2b377e36a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#ac089ab220e671ba0af2dd97f2405c0c5">read_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous stream read operation. <a href="#ac089ab220e671ba0af2dd97f2405c0c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a1bf7a4a30005813b0a46e069215907a2">skip_async</a> (gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request an asynchronous skip of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. <a href="#a1bf7a4a30005813b0a46e069215907a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a111e86dad4548394edcff16d7735d2d5">skip_async</a> (gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request an asynchronous skip of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. <a href="#a111e86dad4548394edcff16d7735d2d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#a1522468bd203ab3082ab54e9eba68b03">skip_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes a stream skip operation. <a href="#a1522468bd203ab3082ab54e9eba68b03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#af66159778ee2d577e9df52063ced53bf">close_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests an asynchronous closes of the stream, releasing resources related to it. <a href="#af66159778ee2d577e9df52063ced53bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#ab5160982124f34ed6e475776acd126d2">close_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests an asynchronous closes of the stream, releasing resources related to it. <a href="#ab5160982124f34ed6e475776acd126d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#ae5a0d2c3ccf27661e374f151117a8fb7">close_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes closing a stream asynchronously, started from g_input_stream_close_async(). <a href="#ae5a0d2c3ccf27661e374f151117a8fb7"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InputStream.html">Gio::InputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#aec580b0fc1e0807d7ccba6cbb7e302db">wrap</a> (GInputStream* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#aec580b0fc1e0807d7ccba6cbb7e302db"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Base class for implementing streaming input. </p>
<dl class="since_2_16"><dt><b><a class="el" href="since_2_16.html#_since_2_16000036">Since glibmm 2.16:</a></b></dt><dd></dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afff624e3125add13c88e8a99907ba903"></a><!-- doxytag: member="Gio::InputStream::~InputStream" ref="afff624e3125add13c88e8a99907ba903" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGio_1_1InputStream.html#afff624e3125add13c88e8a99907ba903">Gio::InputStream::~InputStream</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1b76b2503e607475f63731a886456e09"></a><!-- doxytag: member="Gio::InputStream::close" ref="a1b76b2503e607475f63731a886456e09" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1InputStream.html#a1b76b2503e607475f63731a886456e09">Gio::InputStream::close</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the stream, releasing resources related to it. </p>
<p>Once the stream is closed, all other operations will throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CLOSED. Closing a stream multiple times will not return an error.</p>
<p>Streams will be automatically closed when the last reference is dropped, but you might want to call this function to make sure resources are released as early as possible.</p>
<p>Some streams might keep the backing store of the stream (e.g. a file descriptor) open after the stream is closed. See the documentation for the individual stream for details.</p>
<p>On failure the first error that happened will be reported, but the close operation will finish as much as possible. A stream that failed to close will still throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CLOSED for all operations. Still, it is important to check and report the error to the user.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. Cancelling a close will still leave the stream closed, but some streams can use a faster close that doesn't block to e.g. check errors. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a3202cf7014bcfb2c0a7f301448ae50"></a><!-- doxytag: member="Gio::InputStream::close" ref="a7a3202cf7014bcfb2c0a7f301448ae50" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1InputStream.html#a1b76b2503e607475f63731a886456e09">Gio::InputStream::close</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the stream, releasing resources related to it. </p>
<p>Once the stream is closed, all other operations will throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CLOSED. Closing a stream multiple times will not return an error.</p>
<p>Streams will be automatically closed when the last reference is dropped, but you might want to call this make sure resources are released as early as possible.</p>
<p>Some streams might keep the backing store of the stream (e.g. a file descriptor) open after the stream is closed. See the documentation for the individual stream for details.</p>
<p>On failure the first error that happened will be reported, but the close operation will finish as much as possible. A stream that failed to close will still throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CLOSED for all operations. Still, it is important to check and report the error to the user.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="af66159778ee2d577e9df52063ced53bf"></a><!-- doxytag: member="Gio::InputStream::close_async" ref="af66159778ee2d577e9df52063ced53bf" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1InputStream.html#af66159778ee2d577e9df52063ced53bf">Gio::InputStream::close_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Requests an asynchronous closes of the stream, releasing resources related to it. </p>
<p>When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#ae5a0d2c3ccf27661e374f151117a8fb7" title="Finishes closing a stream asynchronously, started from g_input_stream_close_async().">close_finish()</a> to get the result of the operation.</p>
<p>For behaviour details see <a class="el" href="classGio_1_1InputStream.html#a7a3202cf7014bcfb2c0a7f301448ae50" title="Closes the stream, releasing resources related to it.">close()</a>.</p>
<p>The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5160982124f34ed6e475776acd126d2"></a><!-- doxytag: member="Gio::InputStream::close_async" ref="ab5160982124f34ed6e475776acd126d2" args="(const SlotAsyncReady &amp;slot, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1InputStream.html#af66159778ee2d577e9df52063ced53bf">Gio::InputStream::close_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Requests an asynchronous closes of the stream, releasing resources related to it. </p>
<p>When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#ae5a0d2c3ccf27661e374f151117a8fb7" title="Finishes closing a stream asynchronously, started from g_input_stream_close_async().">close_finish()</a> to get the result of the operation.</p>
<p>For behaviour details see <a class="el" href="classGio_1_1InputStream.html#a7a3202cf7014bcfb2c0a7f301448ae50" title="Closes the stream, releasing resources related to it.">close()</a>.</p>
<p>The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5a0d2c3ccf27661e374f151117a8fb7"></a><!-- doxytag: member="Gio::InputStream::close_finish" ref="ae5a0d2c3ccf27661e374f151117a8fb7" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean <a class="el" href="classGio_1_1InputStream.html#ae5a0d2c3ccf27661e374f151117a8fb7">Gio::InputStream::close_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes closing a stream asynchronously, started from g_input_stream_close_async(). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the stream was closed successfully. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ed1120b3d03a12086e7f0ed3946aba1"></a><!-- doxytag: member="Gio::InputStream::gobj" ref="a2ed1120b3d03a12086e7f0ed3946aba1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GInputStream* <a class="el" href="classGio_1_1InputStream.html#a2ed1120b3d03a12086e7f0ed3946aba1">Gio::InputStream::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#a4c6efc18be8cb9c56e58fc0bd20fafbe">Glib::ObjectBase</a>.</p>

<p>Reimplemented in <a class="el" href="classGio_1_1BufferedInputStream.html#aa9d0c1e643650b9a45831865f06e21be">Gio::BufferedInputStream</a>, <a class="el" href="classGio_1_1FileInputStream.html#a5411e06810e06ad339d7a21257772219">Gio::FileInputStream</a>, <a class="el" href="classGio_1_1DataInputStream.html#ad788764326462190e900785f50a50740">Gio::DataInputStream</a>, <a class="el" href="classGio_1_1FilterInputStream.html#a6db43589745dcd172f4ca4082bc5d914">Gio::FilterInputStream</a>, <a class="el" href="classGio_1_1MemoryInputStream.html#a076380153e01599446bd991e0985db69">Gio::MemoryInputStream</a>, and <a class="el" href="classGio_1_1UnixInputStream.html#aa0b863b654d38a9e10f7d7d49b82c5ea">Gio::UnixInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a1b0ef82ab81b3ded607584c7029fe1e9"></a><!-- doxytag: member="Gio::InputStream::gobj" ref="a1b0ef82ab81b3ded607584c7029fe1e9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GInputStream* <a class="el" href="classGio_1_1InputStream.html#a2ed1120b3d03a12086e7f0ed3946aba1">Gio::InputStream::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#a778a94181132976bbfb0519793f3b32e">Glib::ObjectBase</a>.</p>

<p>Reimplemented in <a class="el" href="classGio_1_1BufferedInputStream.html#ad6b09565f69b4c1cf1f0ca05ee53709e">Gio::BufferedInputStream</a>, <a class="el" href="classGio_1_1FileInputStream.html#ab1afea7b758100ca02a6aa5b89d57662">Gio::FileInputStream</a>, <a class="el" href="classGio_1_1DataInputStream.html#a5d8f01998854eac791a3089acef051c0">Gio::DataInputStream</a>, <a class="el" href="classGio_1_1FilterInputStream.html#ac8fbd2cc879bfab4854d952b27ce271c">Gio::FilterInputStream</a>, <a class="el" href="classGio_1_1MemoryInputStream.html#af9ea44af840fc0d29d460498c8ce7d0e">Gio::MemoryInputStream</a>, and <a class="el" href="classGio_1_1UnixInputStream.html#adc7b87c43606f90378a521df99220971">Gio::UnixInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a28a9394b07e9183c0c79798ea344c65c"></a><!-- doxytag: member="Gio::InputStream::gobj_copy" ref="a28a9394b07e9183c0c79798ea344c65c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GInputStream* <a class="el" href="classGio_1_1InputStream.html#a28a9394b07e9183c0c79798ea344c65c">Gio::InputStream::gobj_copy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

<p>Reimplemented in <a class="el" href="classGio_1_1BufferedInputStream.html#a47dc5f78b1faed25cdaaafe42b526d6d">Gio::BufferedInputStream</a>, <a class="el" href="classGio_1_1FileInputStream.html#aa35ad981b6f18b1e5ece395970c5991b">Gio::FileInputStream</a>, <a class="el" href="classGio_1_1DataInputStream.html#a8252806b8ac5548c51a0418162ddb6ab">Gio::DataInputStream</a>, <a class="el" href="classGio_1_1FilterInputStream.html#a55ef3320e423245cc69066c90785328e">Gio::FilterInputStream</a>, <a class="el" href="classGio_1_1MemoryInputStream.html#af63cbdce2036e383cb7e77a7df83651c">Gio::MemoryInputStream</a>, and <a class="el" href="classGio_1_1UnixInputStream.html#a5f05de3f98b2dd8e7f0f2c5038fbc69f">Gio::UnixInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a49a1f4219f96c7fafdcf1ed12eb443e2"></a><!-- doxytag: member="Gio::InputStream::read" ref="a49a1f4219f96c7fafdcf1ed12eb443e2" args="(void *buffer, gsize count, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1InputStream.html#a49a1f4219f96c7fafdcf1ed12eb443e2">Gio::InputStream::read</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. </p>
<p>Will block during this read.</p>
<p>If count is zero returns zero and does nothing. A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.</p>
<p>On success, the number of bytes read into the buffer is returned. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. If an operation was partially finished when the operation was cancelled the partial result will be returned, without an error. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes read, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a42ab2486116d40f6ef828277befb508a"></a><!-- doxytag: member="Gio::InputStream::read" ref="a42ab2486116d40f6ef828277befb508a" args="(void *buffer, gsize count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1InputStream.html#a49a1f4219f96c7fafdcf1ed12eb443e2">Gio::InputStream::read</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. </p>
<p>Will block during this read.</p>
<p>If count is zero returns zero and does nothing. A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.</p>
<p>On success, the number of bytes read into the buffer is returned. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.</p>
<p>On error -1 is returned. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes that will be read from the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes read, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a1dc8a2babf32f93a0a5dccc0c39e0959"></a><!-- doxytag: member="Gio::InputStream::read_all" ref="a1dc8a2babf32f93a0a5dccc0c39e0959" args="(void *buffer, gsize count, gsize &amp;bytes_read, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1InputStream.html#a1dc8a2babf32f93a0a5dccc0c39e0959">Gio::InputStream::read_all</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>bytes_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. </p>
<p>Will block during this read.</p>
<p>This function is similar to g_input_stream_read(), except it tries to read as many bytes as requested, only stopping on an error or end of stream.</p>
<p>On a successful read of <em>count</em> bytes, or if we reached the end of the stream, <code>true</code> is returned, and <em>bytes_read</em> is set to the number of bytes read into <em>buffer</em>.</p>
<p>If there is an error during the operation <code>false</code> is returned and <em>error</em> is set to indicate the error status, <em>bytes_read</em> is updated to contain the number of bytes read into <em>buffer</em> before the error occurred. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td class="paramname">bytes_read</td><td>Location to store the number of bytes that was read from the stream. </td></tr>
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a6da0fc57d1a5df7107370c67e84aa496"></a><!-- doxytag: member="Gio::InputStream::read_all" ref="a6da0fc57d1a5df7107370c67e84aa496" args="(void *buffer, gsize count, gsize &amp;bytes_read)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1InputStream.html#a1dc8a2babf32f93a0a5dccc0c39e0959">Gio::InputStream::read_all</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>bytes_read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. </p>
<p>Will block during this read.</p>
<p>This function is similar to <a class="el" href="classGio_1_1InputStream.html#a49a1f4219f96c7fafdcf1ed12eb443e2" title="Tries to read count bytes from the stream into the buffer starting at buffer.">read()</a>, except it tries to read as many bytes as requested, only stopping on an error or end of stream.</p>
<p>On a successful read of <em>count</em> bytes, or if we reached the end of the stream, <code>true</code> is returned, and <em>bytes_read</em> is set to the number of bytes read into <em>buffer</em> .</p>
<p>If there is an error during the operation <code>false</code> is returned and a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> is thrown to indicate the error status, <em>bytes_read</em> is updated to contain the number of bytes read into <em>buffer</em> before the error occured. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td class="paramname">bytes_read</td><td>Location to store the number of bytes that was read from the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b7762ee3f3c571fbc59a0c9af6e879e"></a><!-- doxytag: member="Gio::InputStream::read_async" ref="a5b7762ee3f3c571fbc59a0c9af6e879e" args="(void *buffer, gsize count, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1InputStream.html#a5b7762ee3f3c571fbc59a0c9af6e879e">Gio::InputStream::read_async</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request an asynchronous read of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. </p>
<p>When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#ac089ab220e671ba0af2dd97f2405c0c5" title="Finishes an asynchronous stream read operation.">read_finish()</a> to get the result of the operation.</p>
<p>During an async request no other sync and async calls are allowed, and will result in <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with PENDING being thrown.</p>
<p>A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.</p>
<p>On success, the number of bytes read into the buffer will be passed to the <em>slot</em> callback. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file, but generally we try to read as many bytes as requested. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.</p>
<p>Any outstanding i/o request with higher priority (lower numerical value) will be executed before an outstanding request with lower priority. Default priority is PRIORITY_DEFAULT.</p>
<p>The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td class="paramname">slot</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05bea76fa9ac3c098a167d2b377e36a6"></a><!-- doxytag: member="Gio::InputStream::read_async" ref="a05bea76fa9ac3c098a167d2b377e36a6" args="(void *buffer, gsize count, const SlotAsyncReady &amp;slot, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1InputStream.html#a5b7762ee3f3c571fbc59a0c9af6e879e">Gio::InputStream::read_async</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request an asynchronous read of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. </p>
<p>When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#ac089ab220e671ba0af2dd97f2405c0c5" title="Finishes an asynchronous stream read operation.">read_finish()</a> to get the result of the operation.</p>
<p>During an async request no other sync and async calls are allowed, and will result in a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with PENDING being thrown.</p>
<p>A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.</p>
<p>On success, the number of bytes read into the buffer will be passed to the <em>slot</em> callback. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file, but generally we try to read as many bytes as requested. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.</p>
<p>Any outstanding i/o request with higher priority (lower numerical value) will be executed before an outstanding request with lower priority. Default priority is PRIORITY_DEFAULT.</p>
<p>The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td class="paramname">slot</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac089ab220e671ba0af2dd97f2405c0c5"></a><!-- doxytag: member="Gio::InputStream::read_finish" ref="ac089ab220e671ba0af2dd97f2405c0c5" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1InputStream.html#ac089ab220e671ba0af2dd97f2405c0c5">Gio::InputStream::read_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous stream read operation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes read in, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a17ea65f35c15043156db90af831a44a3"></a><!-- doxytag: member="Gio::InputStream::skip" ref="a17ea65f35c15043156db90af831a44a3" args="(gsize count, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1InputStream.html#a17ea65f35c15043156db90af831a44a3">Gio::InputStream::skip</a> </td>
          <td>(</td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to skip <em>count</em> bytes from the stream. </p>
<p>Will block during the operation.</p>
<p>This is identical to g_input_stream_read(), from a behaviour standpoint, but the bytes that are skipped are not returned to the user. Some streams have an implementation that is more efficient than reading the data.</p>
<p>This function is optional for inherited classes, as the default implementation emulates it using read.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. If an operation was partially finished when the operation was cancelled the partial result will be returned, without an error. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of bytes that will be skipped from the stream. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes skipped, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ea9146d612c666168886734b79a5d65"></a><!-- doxytag: member="Gio::InputStream::skip" ref="a1ea9146d612c666168886734b79a5d65" args="(gsize count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1InputStream.html#a17ea65f35c15043156db90af831a44a3">Gio::InputStream::skip</a> </td>
          <td>(</td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to skip <em>count</em> bytes from the stream. </p>
<p>Will block during the operation.</p>
<p>This is identical to <a class="el" href="classGio_1_1InputStream.html#a49a1f4219f96c7fafdcf1ed12eb443e2" title="Tries to read count bytes from the stream into the buffer starting at buffer.">read()</a>, from a behaviour standpoint, but the bytes that are skipped are not returned to the user. Some streams have an implementation that is more efficient than reading the data.</p>
<p>This function is optional for inherited classes, as the default implementation emulates it using read.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of bytes that will be skipped from the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes skipped, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a1bf7a4a30005813b0a46e069215907a2"></a><!-- doxytag: member="Gio::InputStream::skip_async" ref="a1bf7a4a30005813b0a46e069215907a2" args="(gsize count, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1InputStream.html#a1bf7a4a30005813b0a46e069215907a2">Gio::InputStream::skip_async</a> </td>
          <td>(</td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request an asynchronous skip of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. </p>
<p>When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#a1522468bd203ab3082ab54e9eba68b03" title="Finishes a stream skip operation.">skip_finish()</a> to get the result of the operation.</p>
<p>During an async request no other sync and async calls are allowed, and will result in <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with PENDING being thrown.</p>
<p>A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.</p>
<p>On success, the number of bytes skipped will be passed to the callback. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file, but generally we try to skip as many bytes as requested. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.</p>
<p>Any outstanding i/o request with higher priority (lower numerical value) will be executed before an outstanding request with lower priority. Default priority is PRIORITY_DEFAULT.</p>
<p>The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of bytes that will be skipped from the stream. </td></tr>
    <tr><td class="paramname">slot</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a111e86dad4548394edcff16d7735d2d5"></a><!-- doxytag: member="Gio::InputStream::skip_async" ref="a111e86dad4548394edcff16d7735d2d5" args="(gsize count, const SlotAsyncReady &amp;slot, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1InputStream.html#a1bf7a4a30005813b0a46e069215907a2">Gio::InputStream::skip_async</a> </td>
          <td>(</td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request an asynchronous skip of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. </p>
<p>When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#a1522468bd203ab3082ab54e9eba68b03" title="Finishes a stream skip operation.">skip_finish()</a> to get the result of the operation.</p>
<p>During an async request no other sync and async calls are allowed, and will result in <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with PENDING being thrown.</p>
<p>A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.</p>
<p>On success, the number of bytes skipped will be passed to the callback. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file, but generally we try to skip as many bytes as requested. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.</p>
<p>Any outstanding i/o request with higher priority (lower numerical value) will be executed before an outstanding request with lower priority. Default priority is PRIORITY_DEFAULT.</p>
<p>The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of bytes that will be skipped from the stream. </td></tr>
    <tr><td class="paramname">slot</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1522468bd203ab3082ab54e9eba68b03"></a><!-- doxytag: member="Gio::InputStream::skip_finish" ref="a1522468bd203ab3082ab54e9eba68b03" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1InputStream.html#a1522468bd203ab3082ab54e9eba68b03">Gio::InputStream::skip_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes a stream skip operation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The size of the bytes skipped, or %-1 on error. </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="aec580b0fc1e0807d7ccba6cbb7e302db"></a><!-- doxytag: member="Gio::InputStream::wrap" ref="aec580b0fc1e0807d7ccba6cbb7e302db" args="(GInputStream *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InputStream.html">Gio::InputStream</a> &gt; <a class="el" href="classGio_1_1InputStream.html#aec580b0fc1e0807d7ccba6cbb7e302db">wrap</a> </td>
          <td>(</td>
          <td class="paramtype">GInputStream *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 10 2012 14:20:37 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
