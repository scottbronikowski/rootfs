<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>glibmm: Gio::Socket Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="/home/murrayc/checkouts/gnome30/glibmm/docs/doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.32.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceGio.html">Gio</a> </li>
      <li class="navelem"><a class="el" href="classGio_1_1Socket.html">Socket</a> </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> </div>
  <div class="headertitle">
<div class="title">Gio::Socket Class Reference<div class="ingroups"><a class="el" href="group__NetworkIO.html">Portable Network I/O Functionality</a></div></div> </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Gio::Socket" --><!-- doxytag: inherits="Glib::Object,Gio::Initable" -->
<p>Low-level socket object.  <a href="classGio_1_1Socket.html#details">More...</a></p>

<p><code>#include &lt;giomm/socket.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gio::Socket:</div>
<div class="dyncontent">
<div class="center"><img src="classGio_1_1Socket__inherit__graph.png" border="0" usemap="#Gio_1_1Socket_inherit__map" alt="Inheritance graph"/></div>
<map name="Gio_1_1Socket_inherit__map" id="Gio_1_1Socket_inherit__map">
<area shape="rect" id="node2" href="classGlib_1_1Object.html" title="Glib::Object" alt="" coords="5,237,99,267"/><area shape="rect" id="node4" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="41,83,167,112"/><area shape="rect" id="node10" href="classGlib_1_1Interface.html" title="Glib::Interface" alt="" coords="109,160,219,189"/><area shape="rect" id="node6" href="../../../libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="47,5,161,35"/><area shape="rect" id="node8" href="classGio_1_1Initable.html" title="Failable object initialization interface." alt="" coords="123,237,219,267"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGio_1_1Socket-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a8efac59d8562ceb635b76fe70087572d">~Socket</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GSocket*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a1d51f7bcd83450331d7261898e9007d6">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a1d51f7bcd83450331d7261898e9007d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GSocket*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a51c7fa832ce1c984a7bbceb4d7ba93a8">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a51c7fa832ce1c984a7bbceb4d7ba93a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GSocket*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ae2fe06b1a579c40b596933da0ded4e37">gobj_copy</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. <a href="#ae2fe06b1a579c40b596933da0ded4e37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a16044bba5924c183cff90f0a4cf47394">bind</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, bool allow_reuse)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">When a socket is created it is attached to an address family, but it doesn't have an address in this family. <a href="#a16044bba5924c183cff90f0a4cf47394"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#af16eed3fd42f3769b5e608f96db214fd">listen</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the socket as a server socket, i.e. a socket that is used to accept incoming requests using g_socket_accept(). <a href="#af16eed3fd42f3769b5e608f96db214fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a137ae34a8f211eaed11f9a58ca6b3f5e">accept</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept incoming connections on a connection-based socket. <a href="#a137ae34a8f211eaed11f9a58ca6b3f5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4b6c036db4e484e6b7f0419962254888">accept</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a9ab220f5714a6116d35e846b00f4ad23">connect</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the socket to the specified remote address. <a href="#a9ab220f5714a6116d35e846b00f4ad23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a0828763fe472d46aed833fad30af1c0b">connect</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a06b68dc0948e6dfa158487c314f9a521">check_connect_result</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks and resets the pending connect error for the socket. <a href="#a06b68dc0948e6dfa158487c314f9a521"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a742403f4d076ba9050a435d95fea5d1c">receive</a> (char* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01616.html#ga445a43f417432dd1b9aed90ef239c700">size</a>, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data (up to <em>size</em> bytes) from a socket. <a href="#a742403f4d076ba9050a435d95fea5d1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a73463b7677ffdfddaced49bdf170b4b6">receive</a> (char* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01616.html#ga445a43f417432dd1b9aed90ef239c700">size</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4d2d4382139553881ae139920e8db93e">receive_from</a> (<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, char* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01616.html#ga445a43f417432dd1b9aed90ef239c700">size</a>, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a056fd2c3609971d5befcf2b4ccf51aa3">receive_from</a> (<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, char* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01616.html#ga445a43f417432dd1b9aed90ef239c700">size</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#adc5c3145109841e0406150ad0b7f547c">send</a> (const gchar* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01616.html#ga445a43f417432dd1b9aed90ef239c700">size</a>, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to send <em>size</em> bytes from <em>buffer</em> on the socket. <a href="#adc5c3145109841e0406150ad0b7f547c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a986efa2a33528ce5aba0d7c6a7be1b65">send</a> (const gchar* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01616.html#ga445a43f417432dd1b9aed90ef239c700">size</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a8b2d4ff883535e696b6cdaacd730f729">send_to</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, const char* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01616.html#ga445a43f417432dd1b9aed90ef239c700">size</a>, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to send <em>size</em> bytes from <em>buffer</em> to <em>address</em>. <a href="#a8b2d4ff883535e696b6cdaacd730f729"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a929c8c4e0c10a39d65358853e94d9c4f">send_to</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, const char* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01616.html#ga445a43f417432dd1b9aed90ef239c700">size</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aab30d39b9e73fef6401c76d1d4edc118">close</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the socket, shutting down any active connection. <a href="#aab30d39b9e73fef6401c76d1d4edc118"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a7ac925f7e6592ad4a96afe0f75411a96">is_closed</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a socket is closed. <a href="#a7ac925f7e6592ad4a96afe0f75411a96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4f685bc040e9e10abe093deec0719fd7">shutdown</a> (bool shutdown_read, bool shutdown_write)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down part of a full-duplex connection. <a href="#a4f685bc040e9e10abe093deec0719fd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aea9561511b77e652271705fbfdb2f8f2">is_connected</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the socket is connected. <a href="#aea9561511b77e652271705fbfdb2f8f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a86fdc5d814fd61abab15ec03c7da20ec">condition_check</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks on the readiness of <em>socket</em> to perform operations. <a href="#a86fdc5d814fd61abab15ec03c7da20ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aaae28fa63035c05396064f5f4bb4fc36">condition_wait</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for <em>condition</em> to become true on <em>socket</em>. <a href="#aaae28fa63035c05396064f5f4bb4fc36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a9ae420715a2050cc09112f178bae88ba">condition_wait</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#adc7b9d6cecc1c2234f9979b2ffb1b309">set_listen_backlog</a> (int backlog)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of outstanding connections allowed when listening on this socket. <a href="#adc7b9d6cecc1c2234f9979b2ffb1b309"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a22a9e70db9abc7fc6383641afde8ee6f">get_listen_backlog</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the listen backlog setting of the socket. <a href="#a22a9e70db9abc7fc6383641afde8ee6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a51d5a174441c255b69be9e809cdb96b3">set_blocking</a> (bool blocking)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the blocking mode of the socket. <a href="#a51d5a174441c255b69be9e809cdb96b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a1ffcbc226b08ae14856ea0dfe4d580e9">get_blocking</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the blocking mode of the socket. <a href="#a1ffcbc226b08ae14856ea0dfe4d580e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a6cfac67927584ae7afe53006eebb06d7">set_keepalive</a> (bool keepalive)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or unsets the So::KEEPALIVE flag on the underlying socket. <a href="#a6cfac67927584ae7afe53006eebb06d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a530b4adc3d295f7c000981286dee8019">get_keepalive</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the keepalive mode of the socket. <a href="#a530b4adc3d295f7c000981286dee8019"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aac1e2a576e62d1e339eefae1fe12e24b">get_family</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the socket family of the socket. <a href="#aac1e2a576e62d1e339eefae1fe12e24b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#af3bb5076efcb022e31db9622a1c6e0ae">get_fd</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying OS socket object. <a href="#af3bb5076efcb022e31db9622a1c6e0ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a654e36f8577b61a4df93a0a70479a7f1">get_local_address</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the local address of a bound socket. <a href="#a654e36f8577b61a4df93a0a70479a7f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#adce45788b8ac674bdf32a3ec8fb683c1">get_remote_address</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the remove address of a connected socket. <a href="#adce45788b8ac674bdf32a3ec8fb683c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4ecd966ee71eb956258b289cf63eb43e">get_protocol</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the socket protocol id the socket was created with. <a href="#a4ecd966ee71eb956258b289cf63eb43e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a05cd563d5bc68362f3a574054ce63481">get_socket_type</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the socket type of the socket. <a href="#a05cd563d5bc68362f3a574054ce63481"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ae33e646694bf6c5062683ba4b79d4fe1">speaks_ipv4</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a socket is capable of speaking IPv4. <a href="#ae33e646694bf6c5062683ba4b79d4fe1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Credentials.html">Credentials</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a2fcda0eba8fcb30bd020624ce3f14d8f">get_credentials</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the credentials of the foreign process connected to this socket, if any (e.g. it is only supported for SOCKET_FAMILY_UNIX sockets). <a href="#a2fcda0eba8fcb30bd020624ce3f14d8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1Credentials.html">Credentials</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#afcc5b5f562eb0255d846a41bde23d0f7">get_credentials</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the credentials of the foreign process connected to this socket, if any (e.g. it is only supported for SOCKET_FAMILY_UNIX sockets). <a href="#afcc5b5f562eb0255d846a41bde23d0f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a0c05cab954287b392d6c60bc347ca5d8">get_timeout</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the timeout setting of the socket. <a href="#a0c05cab954287b392d6c60bc347ca5d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#afe942e5157528b217d7af4a7839a9e7a">set_timeout</a> (guint timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the time in seconds after which I/O operations on <em>socket</em> will time out if they have not yet completed. <a href="#afe942e5157528b217d7af4a7839a9e7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a812c649ac510471833c7e3bc82e79d26">receive_with_blocking</a> (gchar* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01616.html#ga445a43f417432dd1b9aed90ef239c700">size</a>, bool blocking, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable=<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This behaves exactly the same as g_socket_receive(), except that the choice of blocking or non-blocking behavior is determined by the <em>blocking</em> argument rather than by <em>socket's</em> properties. <a href="#a812c649ac510471833c7e3bc82e79d26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ad350079b590c05387736a0fd21e6e0ec">send_with_blocking</a> (gchar* buffer, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01616.html#ga445a43f417432dd1b9aed90ef239c700">size</a>, bool blocking, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable=<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This behaves exactly the same as g_socket_send(), except that the choice of blocking or non-blocking behavior is determined by the <em>blocking</em> argument rather than by <em>socket's</em> properties. <a href="#ad350079b590c05387736a0fd21e6e0ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a33e80070bf40ed9bff3d6e82fd6bc403">property_blocking</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not I/O on this socket is blocking. <a href="#a33e80070bf40ed9bff3d6e82fd6bc403"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ad4d697455cc099f37e06550d9a6b244c">property_blocking</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not I/O on this socket is blocking. <a href="#ad4d697455cc099f37e06550d9a6b244c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a83a9ca8602e7d1c500cf9f4f4ab45aee">property_family</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The sockets address family. <a href="#a83a9ca8602e7d1c500cf9f4f4ab45aee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a92f0ebc8891cdcccf8e16d0845921beb">property_fd</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The sockets file descriptor. <a href="#a92f0ebc8891cdcccf8e16d0845921beb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aab16cc7a80fbbf288732298017f21a5f">property_keepalive</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep connection alive by sending periodic pings. <a href="#aab16cc7a80fbbf288732298017f21a5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a545a19bc5664e66900d1ca8c29f7d0e6">property_keepalive</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep connection alive by sending periodic pings. <a href="#a545a19bc5664e66900d1ca8c29f7d0e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a7c7ef3aff95f2f829af2d3ce2ef36836">property_listen_backlog</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Outstanding connections in the listen queue. <a href="#a7c7ef3aff95f2f829af2d3ce2ef36836"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ad08f21c5f7bd408e63815581bbfb48ab">property_listen_backlog</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Outstanding connections in the listen queue. <a href="#ad08f21c5f7bd408e63815581bbfb48ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ac52bc9e13993758922ce0d3683f336af">property_local_address</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The local address the socket is bound to. <a href="#ac52bc9e13993758922ce0d3683f336af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a0affc1f63146a265a1d1c2b884091708">property_remote_address</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The remote address the socket is connected to. <a href="#a0affc1f63146a265a1d1c2b884091708"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; guint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4042172bae49d0a2721546e31141d572">property_timeout</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The timeout in seconds on socket I/O. <a href="#a4042172bae49d0a2721546e31141d572"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; guint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a19433af6a2d3b85920a709559d81e4a3">property_timeout</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The timeout in seconds on socket I/O. <a href="#a19433af6a2d3b85920a709559d81e4a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a89ebb99f61c167a77fe06572a9128cb4">property_protocol</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The id of the protocol to use, or -1 for unknown. <a href="#a89ebb99f61c167a77fe06572a9128cb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#afa658ba9c5796b7b5da36734b9c031e0">property_type</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The sockets type. <a href="#afa658ba9c5796b7b5da36734b9c031e0"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aad87b57121a04302e4d9b41c322f59ca">create</a> (<a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> family, <a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a> <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01612.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, <a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a> protocol, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable=<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> with the defined family, type and protocol. <a href="#aad87b57121a04302e4d9b41c322f59ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a8d0268c13028a8e3eeb551ca14b83b8e">create_from_fd</a> (int fd, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable=<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> from a native file descriptor or winsock SOCKET handle. <a href="#a8d0268c13028a8e3eeb551ca14b83b8e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a9d2455e8d617dc7a828480d65db7b473">Socket</a> (<a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> family, <a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a> <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01612.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, <a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a> protocol, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a74d7c4338fcf53743f23926fccc8c6d6">Socket</a> (int fd, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Gio::Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4b4f2145105f84580f0a2659a9e8e5db">wrap</a> (GSocket* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#a4b4f2145105f84580f0a2659a9e8e5db"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Low-level socket object. </p>
<p>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> is a low-level networking primitive. It is a more or less direct mapping of the BSD socket API in a portable GObject based API. It supports both the UNIX socket implementations and winsock2 on Windows.</p>
<p><a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> is the platform independent base upon which the higher level network primitives are based. Applications are not typically meant to use it directly, but rather through classes like <a class="el" href="classGio_1_1SocketClient.html" title="Helper for connecting to a network service.">SocketClient</a>, <a class="el" href="classGio_1_1SocketService.html" title="Make it easy to implement a network service.">SocketService</a> and <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a>. However there may be cases where direct use of <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> is useful.</p>
<p><a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> implements the <a class="el" href="classGio_1_1Initable.html" title="Failable object initialization interface.">Initable</a> interface, and since initialization can fail, the constructor may throw an exception.</p>
<p>Sockets operate in two general modes, blocking or non-blocking. When in blocking mode all operations block until the requested operation is finished or there is an error. In non-blocking mode all calls that would block return immediately with a <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a4041bd40a7ec2e6dc8dae84c30065fec">Gio::Error::WOULD_BLOCK</a> error. To know when a call would successfully run you can call <a class="el" href="classGio_1_1Socket.html#a86fdc5d814fd61abab15ec03c7da20ec" title="Checks on the readiness of socket to perform operations.">condition_check()</a>, or <a class="el" href="classGio_1_1Socket.html#aaae28fa63035c05396064f5f4bb4fc36" title="Waits for condition to become true on socket.">condition_wait()</a>. You can also use create_source() and attach it to a <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">Glib::MainContext</a> to get callbacks when I/O is possible. Note that all sockets are always set to non blocking mode in the system, and blocking mode is emulated in <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>.</p>
<p>When working in non-blocking mode applications should always be able to handle getting a <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a4041bd40a7ec2e6dc8dae84c30065fec">Gio::Error::WOULD_BLOCK</a> error even when some other function said that I/O was possible. This can easily happen in case of a race condition in the application, but it can also happen for other reasons. For instance, on Windows a socket is always seen as writable until a write returns <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a4041bd40a7ec2e6dc8dae84c30065fec">Gio::Error::WOULD_BLOCK</a>.</p>
<p>Sockets can be either connection oriented or datagram based. For connection oriented types you must first establish a connection by either connecting to an address or accepting a connection from another address. For connectionless socket types the target/source address is specified or received in each I/O operation.</p>
<p>All socket file descriptors are set to be close-on-exec.</p>
<p>Note that creating a <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> causes the signal SIGPIPE to be ignored for the remainder of the program. If you are writing a command-line utility that uses <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>, you may need to take into account the fact that your program will not automatically be killed if it tries to write to stdout after it has been closed.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000029">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8efac59d8562ceb635b76fe70087572d"></a><!-- doxytag: member="Gio::Socket::~Socket" ref="a8efac59d8562ceb635b76fe70087572d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGio_1_1Socket.html#a8efac59d8562ceb635b76fe70087572d">Gio::Socket::~Socket</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9d2455e8d617dc7a828480d65db7b473"></a><!-- doxytag: member="Gio::Socket::Socket" ref="a9d2455e8d617dc7a828480d65db7b473" args="(SocketFamily family, SocketType type, SocketProtocol protocol, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1Socket.html#a9d2455e8d617dc7a828480d65db7b473">Gio::Socket::Socket</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a>&#160;</td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a>&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a74d7c4338fcf53743f23926fccc8c6d6"></a><!-- doxytag: member="Gio::Socket::Socket" ref="a74d7c4338fcf53743f23926fccc8c6d6" args="(int fd, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1Socket.html#a9d2455e8d617dc7a828480d65db7b473">Gio::Socket::Socket</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a137ae34a8f211eaed11f9a58ca6b3f5e"></a><!-- doxytag: member="Gio::Socket::accept" ref="a137ae34a8f211eaed11f9a58ca6b3f5e" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; <a class="el" href="classGio_1_1Socket.html#a137ae34a8f211eaed11f9a58ca6b3f5e">Gio::Socket::accept</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accept incoming connections on a connection-based socket. </p>
<p>This removes the first outstanding connection request from the listening socket and creates a <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> object for it.</p>
<p>The <em>socket</em> must be bound to a local address with g_socket_bind() and must be listening for incoming connections (g_socket_listen()).</p>
<p>If there are no outstanding connections then the operation will block or return IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled. To be notified of an incoming connection, wait for the IO_IN condition.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000087">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>, or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a4b6c036db4e484e6b7f0419962254888"></a><!-- doxytag: member="Gio::Socket::accept" ref="a4b6c036db4e484e6b7f0419962254888" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; <a class="el" href="classGio_1_1Socket.html#a137ae34a8f211eaed11f9a58ca6b3f5e">Gio::Socket::accept</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a16044bba5924c183cff90f0a4cf47394"></a><!-- doxytag: member="Gio::Socket::bind" ref="a16044bba5924c183cff90f0a4cf47394" args="(const Glib::RefPtr&lt; SocketAddress &gt; &amp;address, bool allow_reuse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Socket.html#a16044bba5924c183cff90f0a4cf47394">Gio::Socket::bind</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_reuse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When a socket is created it is attached to an address family, but it doesn't have an address in this family. </p>
<p>g_socket_bind() assigns the address (sometimes called name) of the socket.</p>
<p>It is generally required to bind to a local address before you can receive connections. (See g_socket_listen() and g_socket_accept() ). In certain situations, you may also want to bind a socket that will be used to initiate connections, though this is not normally required.</p>
<p><em>allow_reuse</em> should be <code>true</code> for server sockets (sockets that you will eventually call g_socket_accept() on), and <code>false</code> for client sockets. (Specifically, if it is <code>true</code>, then g_socket_bind() will set the So::REUSEADDR flag on the socket, allowing it to bind <em>address</em> even if that address was previously used by another socket that has not yet been fully cleaned-up by the kernel. Failing to set this flag on a server socket may cause the bind call to return IO_ERROR_ADDRESS_IN_USE if the server program is stopped and then immediately restarted.)</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000085">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a> specifying the local address. </td></tr>
    <tr><td class="paramname">allow_reuse</td><td>Whether to allow reusing this address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a06b68dc0948e6dfa158487c314f9a521"></a><!-- doxytag: member="Gio::Socket::check_connect_result" ref="a06b68dc0948e6dfa158487c314f9a521" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Socket.html#a06b68dc0948e6dfa158487c314f9a521">Gio::Socket::check_connect_result</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks and resets the pending connect error for the socket. </p>
<p>This is used to check for errors when g_socket_connect() is used in non-blocking mode.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000089">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if no error, <code>false</code> otherwise, setting <em>error</em> to the error. </dd></dl>

</div>
</div>
<a class="anchor" id="aab30d39b9e73fef6401c76d1d4edc118"></a><!-- doxytag: member="Gio::Socket::close" ref="aab30d39b9e73fef6401c76d1d4edc118" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Socket.html#aab30d39b9e73fef6401c76d1d4edc118">Gio::Socket::close</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the socket, shutting down any active connection. </p>
<p>Closing a socket does not wait for all outstanding I/O operations to finish, so the caller should not rely on them to be guaranteed to complete even if the close returns with no error.</p>
<p>Once the socket is closed, all other operations will return IO_ERROR_CLOSED. Closing a socket multiple times will not return an error.</p>
<p>Sockets will be automatically closed when the last reference is dropped, but you might want to call this function to make sure resources are released as early as possible.</p>
<p>Beware that due to the way that TCP works, it is possible for recently-sent data to be lost if either you close a socket while the IO_IN condition is set, or else if the remote connection tries to send something to you after you close the socket but before it has finished reading all of the data you sent. There is no easy generic way to avoid this problem; the easiest fix is to design the network protocol such that the client will never send data "out of turn". Another solution is for the server to half-close the connection by calling g_socket_shutdown() with only the <em>shutdown_write</em> flag set, and then wait for the client to notice this and close its side of the connection, after which the server can safely call g_socket_close(). (This is what <a class="el" href="classGio_1_1TcpConnection.html" title="A TCP SocketConnection.">TcpConnection</a> does if you call g_tcp_connection_set_graceful_disconnect(). But of course, this only works if the client will close its connection after the server does.)</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000093">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a86fdc5d814fd61abab15ec03c7da20ec"></a><!-- doxytag: member="Gio::Socket::condition_check" ref="a86fdc5d814fd61abab15ec03c7da20ec" args="(Glib::IOCondition condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> <a class="el" href="classGio_1_1Socket.html#a86fdc5d814fd61abab15ec03c7da20ec">Gio::Socket::condition_check</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks on the readiness of <em>socket</em> to perform operations. </p>
<p>The operations specified in <em>condition</em> are checked for and masked against the currently-satisfied conditions on <em>socket</em>. The result is returned.</p>
<p>Note that on Windows, it is possible for an operation to return IO_ERROR_WOULD_BLOCK even immediately after g_socket_condition_check() has claimed that the socket is ready for writing. Rather than calling g_socket_condition_check() and then writing to the socket if it succeeds, it is generally better to simply try writing to the socket right away, and try again later if the initial attempt returns IO_ERROR_WOULD_BLOCK.</p>
<p>It is meaningless to specify IO_ERR or IO_HUP in condition; these conditions will always be set in the output if they are true.</p>
<p>This call never blocks.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000097">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>A IOCondition mask to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <em>GIOCondition</em> mask of the current state. </dd></dl>

</div>
</div>
<a class="anchor" id="aaae28fa63035c05396064f5f4bb4fc36"></a><!-- doxytag: member="Gio::Socket::condition_wait" ref="aaae28fa63035c05396064f5f4bb4fc36" args="(Glib::IOCondition condition, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Socket.html#aaae28fa63035c05396064f5f4bb4fc36">Gio::Socket::condition_wait</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits for <em>condition</em> to become true on <em>socket</em>. </p>
<p>When the condition is met, <code>true</code> is returned.</p>
<p>If <em>cancellable</em> is cancelled before the condition is met, or if the socket has a timeout set and it is reached before the condition is met, then <code>false</code> is returned and <em>error</em>, if non-<code>0</code>, is set to the appropriate value (IO_ERROR_CANCELLED or IO_ERROR_TIMED_OUT).</p>
<p>See also g_socket_condition_timed_wait().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000098">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>A IOCondition mask to wait for. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the condition was met, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ae420715a2050cc09112f178bae88ba"></a><!-- doxytag: member="Gio::Socket::condition_wait" ref="a9ae420715a2050cc09112f178bae88ba" args="(Glib::IOCondition condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Socket.html#aaae28fa63035c05396064f5f4bb4fc36">Gio::Socket::condition_wait</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9ab220f5714a6116d35e846b00f4ad23"></a><!-- doxytag: member="Gio::Socket::connect" ref="a9ab220f5714a6116d35e846b00f4ad23" args="(const Glib::RefPtr&lt; SocketAddress &gt; &amp;address, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Socket.html#a9ab220f5714a6116d35e846b00f4ad23">Gio::Socket::connect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect the socket to the specified remote address. </p>
<p>For connection oriented socket this generally means we attempt to make a connection to the <em>address</em>. For a connection-less socket it sets the default address for g_socket_send() and discards all incoming datagrams from other sources.</p>
<p>Generally connection oriented sockets can only connect once, but connection-less sockets can connect multiple times to change the default address.</p>
<p>If the connect call needs to do network I/O it will block, unless non-blocking I/O is enabled. Then IO_ERROR_PENDING is returned and the user can be notified of the connection finishing by waiting for the G_IO_OUT condition. The result of the connection must then be checked with g_socket_check_connect_result().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000088">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a> specifying the remote address. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if connected, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a0828763fe472d46aed833fad30af1c0b"></a><!-- doxytag: member="Gio::Socket::connect" ref="a0828763fe472d46aed833fad30af1c0b" args="(const Glib::RefPtr&lt; SocketAddress &gt; &amp;address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Socket.html#a9ab220f5714a6116d35e846b00f4ad23">Gio::Socket::connect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aad87b57121a04302e4d9b41c322f59ca"></a><!-- doxytag: member="Gio::Socket::create" ref="aad87b57121a04302e4d9b41c322f59ca" args="(SocketFamily family, SocketType type, SocketProtocol protocol, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable=Glib::RefPtr&lt; Cancellable &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; <a class="el" href="classGio_1_1Socket.html#aad87b57121a04302e4d9b41c322f59ca">Gio::Socket::create</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a>&#160;</td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a>&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em> = <code><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;&#160;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> with the defined family, type and protocol. </p>
<p>If <em>protocol</em> is 0 (SOCKET_PROTOCOL_DEFAULT) the default protocol type for the family and type is used.</p>
<p>The <em>protocol</em> is a family and type specific int that specifies what kind of protocol to use. SocketProtocol lists several common ones. Many families only support one protocol, and use 0 for this, others support several and using 0 means to use the default protocol for the family and type.</p>
<p>The protocol id is passed directly to the operating system, so you can use protocols not listed in SocketProtocol if you know the protocol number used for it.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000083">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">family</td><td>The socket family to use, e.g. SOCKET_FAMILY_IPV4. </td></tr>
    <tr><td class="paramname">type</td><td>The socket type to use. </td></tr>
    <tr><td class="paramname">protocol</td><td>The id of the protocol to use, or 0 for default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d0268c13028a8e3eeb551ca14b83b8e"></a><!-- doxytag: member="Gio::Socket::create_from_fd" ref="a8d0268c13028a8e3eeb551ca14b83b8e" args="(int fd, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable=Glib::RefPtr&lt; Cancellable &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; <a class="el" href="classGio_1_1Socket.html#a8d0268c13028a8e3eeb551ca14b83b8e">Gio::Socket::create_from_fd</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em> = <code><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;&#160;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> from a native file descriptor or winsock SOCKET handle. </p>
<p>This reads all the settings from the file descriptor so that all properties should work. Note that the file descriptor will be set to non-blocking mode, independent on the blocking mode of the <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000084">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A native socket file descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ffcbc226b08ae14856ea0dfe4d580e9"></a><!-- doxytag: member="Gio::Socket::get_blocking" ref="a1ffcbc226b08ae14856ea0dfe4d580e9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1Socket.html#a1ffcbc226b08ae14856ea0dfe4d580e9">Gio::Socket::get_blocking</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the blocking mode of the socket. </p>
<p>For details on blocking I/O, see g_socket_set_blocking().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000102">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if blocking I/O is used, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fcda0eba8fcb30bd020624ce3f14d8f"></a><!-- doxytag: member="Gio::Socket::get_credentials" ref="a2fcda0eba8fcb30bd020624ce3f14d8f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Credentials.html">Credentials</a>&gt; <a class="el" href="classGio_1_1Socket.html#a2fcda0eba8fcb30bd020624ce3f14d8f">Gio::Socket::get_credentials</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the credentials of the foreign process connected to this socket, if any (e.g. it is only supported for SOCKET_FAMILY_UNIX sockets). </p>
<p>If this operation isn't supported on the OS, the method fails with the IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented by reading the So::PEERCRED option on the underlying socket.</p>
<p>Other ways to obtain credentials from a foreign peer includes the <a class="el" href="classGio_1_1UnixCredentialsMessage.html" title="UnixCredentialsMessage - A SocketControlMessage containing credentials.">UnixCredentialsMessage</a> type and g_unix_connection_send_credentials() / g_unix_connection_receive_credentials() functions.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000250">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0</code> if <em>error</em> is set, otherwise a <a class="el" href="classGio_1_1Credentials.html" title="An object containing credentials.">Credentials</a> object that must be freed with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="afcc5b5f562eb0255d846a41bde23d0f7"></a><!-- doxytag: member="Gio::Socket::get_credentials" ref="afcc5b5f562eb0255d846a41bde23d0f7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;const <a class="el" href="classGio_1_1Credentials.html">Credentials</a>&gt; <a class="el" href="classGio_1_1Socket.html#a2fcda0eba8fcb30bd020624ce3f14d8f">Gio::Socket::get_credentials</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the credentials of the foreign process connected to this socket, if any (e.g. it is only supported for SOCKET_FAMILY_UNIX sockets). </p>
<p>If this operation isn't supported on the OS, the method fails with the IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented by reading the So::PEERCRED option on the underlying socket.</p>
<p>Other ways to obtain credentials from a foreign peer includes the <a class="el" href="classGio_1_1UnixCredentialsMessage.html" title="UnixCredentialsMessage - A SocketControlMessage containing credentials.">UnixCredentialsMessage</a> type and g_unix_connection_send_credentials() / g_unix_connection_receive_credentials() functions.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000251">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0</code> if <em>error</em> is set, otherwise a <a class="el" href="classGio_1_1Credentials.html" title="An object containing credentials.">Credentials</a> object that must be freed with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="aac1e2a576e62d1e339eefae1fe12e24b"></a><!-- doxytag: member="Gio::Socket::get_family" ref="aac1e2a576e62d1e339eefae1fe12e24b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> <a class="el" href="classGio_1_1Socket.html#aac1e2a576e62d1e339eefae1fe12e24b">Gio::Socket::get_family</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the socket family of the socket. </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000105">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A SocketFamily. </dd></dl>

</div>
</div>
<a class="anchor" id="af3bb5076efcb022e31db9622a1c6e0ae"></a><!-- doxytag: member="Gio::Socket::get_fd" ref="af3bb5076efcb022e31db9622a1c6e0ae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGio_1_1Socket.html#af3bb5076efcb022e31db9622a1c6e0ae">Gio::Socket::get_fd</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the underlying OS socket object. </p>
<p>On unix this is a socket file descriptor, and on windows this is a Winsock2 SOCKET handle. This may be useful for doing platform specific or otherwise unusual operations on the socket.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000106">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The file descriptor of the socket. </dd></dl>

</div>
</div>
<a class="anchor" id="a530b4adc3d295f7c000981286dee8019"></a><!-- doxytag: member="Gio::Socket::get_keepalive" ref="a530b4adc3d295f7c000981286dee8019" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1Socket.html#a530b4adc3d295f7c000981286dee8019">Gio::Socket::get_keepalive</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the keepalive mode of the socket. </p>
<p>For details on this, see g_socket_set_keepalive().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000104">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if keepalive is active, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a22a9e70db9abc7fc6383641afde8ee6f"></a><!-- doxytag: member="Gio::Socket::get_listen_backlog" ref="a22a9e70db9abc7fc6383641afde8ee6f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGio_1_1Socket.html#a22a9e70db9abc7fc6383641afde8ee6f">Gio::Socket::get_listen_backlog</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the listen backlog setting of the socket. </p>
<p>For details on this, see g_socket_set_listen_backlog().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000100">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The maximum number of pending connections. </dd></dl>

</div>
</div>
<a class="anchor" id="a654e36f8577b61a4df93a0a70479a7f1"></a><!-- doxytag: member="Gio::Socket::get_local_address" ref="a654e36f8577b61a4df93a0a70479a7f1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a>&gt; <a class="el" href="classGio_1_1Socket.html#a654e36f8577b61a4df93a0a70479a7f1">Gio::Socket::get_local_address</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to get the local address of a bound socket. </p>
<p>This is only useful if the socket has been bound to a local address, either explicitly or implicitly when connecting.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000107">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a4ecd966ee71eb956258b289cf63eb43e"></a><!-- doxytag: member="Gio::Socket::get_protocol" ref="a4ecd966ee71eb956258b289cf63eb43e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a> <a class="el" href="classGio_1_1Socket.html#a4ecd966ee71eb956258b289cf63eb43e">Gio::Socket::get_protocol</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the socket protocol id the socket was created with. </p>
<p>In case the protocol is unknown, -1 is returned.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000109">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A protocol id, or -1 if unknown. </dd></dl>

</div>
</div>
<a class="anchor" id="adce45788b8ac674bdf32a3ec8fb683c1"></a><!-- doxytag: member="Gio::Socket::get_remote_address" ref="adce45788b8ac674bdf32a3ec8fb683c1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a>&gt; <a class="el" href="classGio_1_1Socket.html#adce45788b8ac674bdf32a3ec8fb683c1">Gio::Socket::get_remote_address</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to get the remove address of a connected socket. </p>
<p>This is only useful for connection oriented sockets that have been connected.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000108">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a05cd563d5bc68362f3a574054ce63481"></a><!-- doxytag: member="Gio::Socket::get_socket_type" ref="a05cd563d5bc68362f3a574054ce63481" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a> <a class="el" href="classGio_1_1Socket.html#a05cd563d5bc68362f3a574054ce63481">Gio::Socket::get_socket_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the socket type of the socket. </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000110">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A SocketType. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c05cab954287b392d6c60bc347ca5d8"></a><!-- doxytag: member="Gio::Socket::get_timeout" ref="a0c05cab954287b392d6c60bc347ca5d8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint <a class="el" href="classGio_1_1Socket.html#a0c05cab954287b392d6c60bc347ca5d8">Gio::Socket::get_timeout</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the timeout setting of the socket. </p>
<p>For details on this, see g_socket_set_timeout().</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000252">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The timeout in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d51f7bcd83450331d7261898e9007d6"></a><!-- doxytag: member="Gio::Socket::gobj" ref="a1d51f7bcd83450331d7261898e9007d6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSocket* <a class="el" href="classGio_1_1Socket.html#a1d51f7bcd83450331d7261898e9007d6">Gio::Socket::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGio_1_1Initable.html#a90206d58591c674e03c5de57623bac18">Gio::Initable</a>.</p>

</div>
</div>
<a class="anchor" id="a51c7fa832ce1c984a7bbceb4d7ba93a8"></a><!-- doxytag: member="Gio::Socket::gobj" ref="a51c7fa832ce1c984a7bbceb4d7ba93a8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GSocket* <a class="el" href="classGio_1_1Socket.html#a1d51f7bcd83450331d7261898e9007d6">Gio::Socket::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGio_1_1Initable.html#a30665fda96b812e27231ec5abc47b789">Gio::Initable</a>.</p>

</div>
</div>
<a class="anchor" id="ae2fe06b1a579c40b596933da0ded4e37"></a><!-- doxytag: member="Gio::Socket::gobj_copy" ref="ae2fe06b1a579c40b596933da0ded4e37" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSocket* <a class="el" href="classGio_1_1Socket.html#ae2fe06b1a579c40b596933da0ded4e37">Gio::Socket::gobj_copy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a class="anchor" id="a7ac925f7e6592ad4a96afe0f75411a96"></a><!-- doxytag: member="Gio::Socket::is_closed" ref="a7ac925f7e6592ad4a96afe0f75411a96" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1Socket.html#a7ac925f7e6592ad4a96afe0f75411a96">Gio::Socket::is_closed</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether a socket is closed. </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000094">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if socket is closed, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aea9561511b77e652271705fbfdb2f8f2"></a><!-- doxytag: member="Gio::Socket::is_connected" ref="aea9561511b77e652271705fbfdb2f8f2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1Socket.html#aea9561511b77e652271705fbfdb2f8f2">Gio::Socket::is_connected</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether the socket is connected. </p>
<p>This is only useful for connection-oriented sockets.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000096">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if socket is connected, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af16eed3fd42f3769b5e608f96db214fd"></a><!-- doxytag: member="Gio::Socket::listen" ref="af16eed3fd42f3769b5e608f96db214fd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Socket.html#af16eed3fd42f3769b5e608f96db214fd">Gio::Socket::listen</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks the socket as a server socket, i.e. a socket that is used to accept incoming requests using g_socket_accept(). </p>
<p>Before calling this the socket must be bound to a local address using g_socket_bind().</p>
<p>To set the maximum amount of outstanding clients, use g_socket_set_listen_backlog().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000086">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a33e80070bf40ed9bff3d6e82fd6bc403"></a><!-- doxytag: member="Gio::Socket::property_blocking" ref="a33e80070bf40ed9bff3d6e82fd6bc403" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt; <a class="el" href="classGio_1_1Socket.html#a33e80070bf40ed9bff3d6e82fd6bc403">Gio::Socket::property_blocking</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether or not I/O on this socket is blocking. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4d697455cc099f37e06550d9a6b244c"></a><!-- doxytag: member="Gio::Socket::property_blocking" ref="ad4d697455cc099f37e06550d9a6b244c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; bool &gt; <a class="el" href="classGio_1_1Socket.html#a33e80070bf40ed9bff3d6e82fd6bc403">Gio::Socket::property_blocking</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether or not I/O on this socket is blocking. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a83a9ca8602e7d1c500cf9f4f4ab45aee"></a><!-- doxytag: member="Gio::Socket::property_family" ref="a83a9ca8602e7d1c500cf9f4f4ab45aee" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> &gt; <a class="el" href="classGio_1_1Socket.html#a83a9ca8602e7d1c500cf9f4f4ab45aee">Gio::Socket::property_family</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The sockets address family. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a92f0ebc8891cdcccf8e16d0845921beb"></a><!-- doxytag: member="Gio::Socket::property_fd" ref="a92f0ebc8891cdcccf8e16d0845921beb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; int &gt; <a class="el" href="classGio_1_1Socket.html#a92f0ebc8891cdcccf8e16d0845921beb">Gio::Socket::property_fd</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The sockets file descriptor. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="aab16cc7a80fbbf288732298017f21a5f"></a><!-- doxytag: member="Gio::Socket::property_keepalive" ref="aab16cc7a80fbbf288732298017f21a5f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt; <a class="el" href="classGio_1_1Socket.html#aab16cc7a80fbbf288732298017f21a5f">Gio::Socket::property_keepalive</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Keep connection alive by sending periodic pings. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a545a19bc5664e66900d1ca8c29f7d0e6"></a><!-- doxytag: member="Gio::Socket::property_keepalive" ref="a545a19bc5664e66900d1ca8c29f7d0e6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; bool &gt; <a class="el" href="classGio_1_1Socket.html#aab16cc7a80fbbf288732298017f21a5f">Gio::Socket::property_keepalive</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Keep connection alive by sending periodic pings. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c7ef3aff95f2f829af2d3ce2ef36836"></a><!-- doxytag: member="Gio::Socket::property_listen_backlog" ref="a7c7ef3aff95f2f829af2d3ce2ef36836" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; int &gt; <a class="el" href="classGio_1_1Socket.html#a7c7ef3aff95f2f829af2d3ce2ef36836">Gio::Socket::property_listen_backlog</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Outstanding connections in the listen queue. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="ad08f21c5f7bd408e63815581bbfb48ab"></a><!-- doxytag: member="Gio::Socket::property_listen_backlog" ref="ad08f21c5f7bd408e63815581bbfb48ab" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; int &gt; <a class="el" href="classGio_1_1Socket.html#a7c7ef3aff95f2f829af2d3ce2ef36836">Gio::Socket::property_listen_backlog</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Outstanding connections in the listen queue. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="ac52bc9e13993758922ce0d3683f336af"></a><!-- doxytag: member="Gio::Socket::property_local_address" ref="ac52bc9e13993758922ce0d3683f336af" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a>&gt; &gt; <a class="el" href="classGio_1_1Socket.html#ac52bc9e13993758922ce0d3683f336af">Gio::Socket::property_local_address</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The local address the socket is bound to. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a89ebb99f61c167a77fe06572a9128cb4"></a><!-- doxytag: member="Gio::Socket::property_protocol" ref="a89ebb99f61c167a77fe06572a9128cb4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a> &gt; <a class="el" href="classGio_1_1Socket.html#a89ebb99f61c167a77fe06572a9128cb4">Gio::Socket::property_protocol</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The id of the protocol to use, or -1 for unknown. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a0affc1f63146a265a1d1c2b884091708"></a><!-- doxytag: member="Gio::Socket::property_remote_address" ref="a0affc1f63146a265a1d1c2b884091708" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a>&gt; &gt; <a class="el" href="classGio_1_1Socket.html#a0affc1f63146a265a1d1c2b884091708">Gio::Socket::property_remote_address</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The remote address the socket is connected to. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a4042172bae49d0a2721546e31141d572"></a><!-- doxytag: member="Gio::Socket::property_timeout" ref="a4042172bae49d0a2721546e31141d572" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; guint &gt; <a class="el" href="classGio_1_1Socket.html#a4042172bae49d0a2721546e31141d572">Gio::Socket::property_timeout</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The timeout in seconds on socket I/O. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a19433af6a2d3b85920a709559d81e4a3"></a><!-- doxytag: member="Gio::Socket::property_timeout" ref="a19433af6a2d3b85920a709559d81e4a3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; guint &gt; <a class="el" href="classGio_1_1Socket.html#a4042172bae49d0a2721546e31141d572">Gio::Socket::property_timeout</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The timeout in seconds on socket I/O. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="afa658ba9c5796b7b5da36734b9c031e0"></a><!-- doxytag: member="Gio::Socket::property_type" ref="afa658ba9c5796b7b5da36734b9c031e0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a> &gt; <a class="el" href="classGio_1_1Socket.html#afa658ba9c5796b7b5da36734b9c031e0">Gio::Socket::property_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The sockets type. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a742403f4d076ba9050a435d95fea5d1c"></a><!-- doxytag: member="Gio::Socket::receive" ref="a742403f4d076ba9050a435d95fea5d1c" args="(char *buffer, gsize size, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1Socket.html#a742403f4d076ba9050a435d95fea5d1c">Gio::Socket::receive</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive data (up to <em>size</em> bytes) from a socket. </p>
<p>This is mainly used by connection-oriented sockets; it is identical to g_socket_receive_from() with <em>address</em> set to <code>0</code>.</p>
<p>For SOCKET_TYPE_DATAGRAM and SOCKET_TYPE_SEQPACKET sockets, g_socket_receive() will always read either 0 or 1 complete messages from the socket. If the received message is too large to fit in <em>buffer</em>, then the data beyond <em>size</em> bytes will be discarded, without any explicit indication that this has occurred.</p>
<p>For SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any number of bytes, up to <em>size</em>. If more than <em>size</em> bytes have been received, the additional data will be returned in future calls to g_socket_receive().</p>
<p>If the socket is in blocking mode the call will block until there is some data to receive, the connection is closed, or there is an error. If there is no data available and the socket is in non-blocking mode, a IO_ERROR_WOULD_BLOCK error will be returned. To be notified when data is available, wait for the IO_IN condition.</p>
<p>On error -1 is returned and <em>error</em> is set accordingly.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000090">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer to read data into (which should be at least <em>size</em> bytes long). </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes you want to read from the socket. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a73463b7677ffdfddaced49bdf170b4b6"></a><!-- doxytag: member="Gio::Socket::receive" ref="a73463b7677ffdfddaced49bdf170b4b6" args="(char *buffer, gsize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1Socket.html#a742403f4d076ba9050a435d95fea5d1c">Gio::Socket::receive</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d2d4382139553881ae139920e8db93e"></a><!-- doxytag: member="Gio::Socket::receive_from" ref="a4d2d4382139553881ae139920e8db93e" args="(Glib::RefPtr&lt; SocketAddress &gt; &amp;address, char *buffer, gsize size, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1Socket.html#a4d2d4382139553881ae139920e8db93e">Gio::Socket::receive_from</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a056fd2c3609971d5befcf2b4ccf51aa3"></a><!-- doxytag: member="Gio::Socket::receive_from" ref="a056fd2c3609971d5befcf2b4ccf51aa3" args="(Glib::RefPtr&lt; SocketAddress &gt; &amp;address, char *buffer, gsize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1Socket.html#a4d2d4382139553881ae139920e8db93e">Gio::Socket::receive_from</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a812c649ac510471833c7e3bc82e79d26"></a><!-- doxytag: member="Gio::Socket::receive_with_blocking" ref="a812c649ac510471833c7e3bc82e79d26" args="(gchar *buffer, gsize size, bool blocking, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable=Glib::RefPtr&lt; Cancellable &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1Socket.html#a812c649ac510471833c7e3bc82e79d26">Gio::Socket::receive_with_blocking</a> </td>
          <td>(</td>
          <td class="paramtype">gchar *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em> = <code><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;&#160;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This behaves exactly the same as g_socket_receive(), except that the choice of blocking or non-blocking behavior is determined by the <em>blocking</em> argument rather than by <em>socket's</em> properties. </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000254">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer to read data into (which should be at least <em>size</em> bytes long). </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes you want to read from the socket. </td></tr>
    <tr><td class="paramname">blocking</td><td>Whether to do blocking or non-blocking I/O. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="adc5c3145109841e0406150ad0b7f547c"></a><!-- doxytag: member="Gio::Socket::send" ref="adc5c3145109841e0406150ad0b7f547c" args="(const gchar *buffer, gsize size, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1Socket.html#adc5c3145109841e0406150ad0b7f547c">Gio::Socket::send</a> </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to send <em>size</em> bytes from <em>buffer</em> on the socket. </p>
<p>This is mainly used by connection-oriented sockets; it is identical to g_socket_send_to() with <em>address</em> set to <code>0</code>.</p>
<p>If the socket is in blocking mode the call will block until there is space for the data in the socket queue. If there is no space available and the socket is in non-blocking mode a IO_ERROR_WOULD_BLOCK error will be returned. To be notified when space is available, wait for the IO_OUT condition. Note though that you may still receive IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously notified of a IO_OUT condition. (On Windows in particular, this is very common due to the way the underlying APIs work.)</p>
<p>On error -1 is returned and <em>error</em> is set accordingly.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000091">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing the data to send. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to send. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes written (which may be less than <em>size</em>), or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a986efa2a33528ce5aba0d7c6a7be1b65"></a><!-- doxytag: member="Gio::Socket::send" ref="a986efa2a33528ce5aba0d7c6a7be1b65" args="(const gchar *buffer, gsize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1Socket.html#adc5c3145109841e0406150ad0b7f547c">Gio::Socket::send</a> </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8b2d4ff883535e696b6cdaacd730f729"></a><!-- doxytag: member="Gio::Socket::send_to" ref="a8b2d4ff883535e696b6cdaacd730f729" args="(const Glib::RefPtr&lt; SocketAddress &gt; &amp;address, const char *buffer, gsize size, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1Socket.html#a8b2d4ff883535e696b6cdaacd730f729">Gio::Socket::send_to</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to send <em>size</em> bytes from <em>buffer</em> to <em>address</em>. </p>
<p>If <em>address</em> is <code>0</code> then the message is sent to the default receiver (set by g_socket_connect()).</p>
<p>See g_socket_send() for additional information.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000092">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a>, or <code>0</code>. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer containing the data to send. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to send. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes written (which may be less than <em>size</em>), or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a929c8c4e0c10a39d65358853e94d9c4f"></a><!-- doxytag: member="Gio::Socket::send_to" ref="a929c8c4e0c10a39d65358853e94d9c4f" args="(const Glib::RefPtr&lt; SocketAddress &gt; &amp;address, const char *buffer, gsize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1Socket.html#a8b2d4ff883535e696b6cdaacd730f729">Gio::Socket::send_to</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad350079b590c05387736a0fd21e6e0ec"></a><!-- doxytag: member="Gio::Socket::send_with_blocking" ref="ad350079b590c05387736a0fd21e6e0ec" args="(gchar *buffer, gsize size, bool blocking, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable=Glib::RefPtr&lt; Cancellable &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1Socket.html#ad350079b590c05387736a0fd21e6e0ec">Gio::Socket::send_with_blocking</a> </td>
          <td>(</td>
          <td class="paramtype">gchar *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em> = <code><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;&#160;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This behaves exactly the same as g_socket_send(), except that the choice of blocking or non-blocking behavior is determined by the <em>blocking</em> argument rather than by <em>socket's</em> properties. </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000255">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing the data to send. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to send. </td></tr>
    <tr><td class="paramname">blocking</td><td>Whether to do blocking or non-blocking I/O. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes written (which may be less than <em>size</em>), or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a51d5a174441c255b69be9e809cdb96b3"></a><!-- doxytag: member="Gio::Socket::set_blocking" ref="a51d5a174441c255b69be9e809cdb96b3" args="(bool blocking)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Socket.html#a51d5a174441c255b69be9e809cdb96b3">Gio::Socket::set_blocking</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the blocking mode of the socket. </p>
<p>In blocking mode all operations block until they succeed or there is an error. In non-blocking mode all functions return results immediately or with a IO_ERROR_WOULD_BLOCK error.</p>
<p>All sockets are created in blocking mode. However, note that the platform level socket is always non-blocking, and blocking mode is a GSocket level feature.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000101">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">blocking</td><td>Whether to use blocking I/O or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6cfac67927584ae7afe53006eebb06d7"></a><!-- doxytag: member="Gio::Socket::set_keepalive" ref="a6cfac67927584ae7afe53006eebb06d7" args="(bool keepalive)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Socket.html#a6cfac67927584ae7afe53006eebb06d7">Gio::Socket::set_keepalive</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepalive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets or unsets the So::KEEPALIVE flag on the underlying socket. </p>
<p>When this flag is set on a socket, the system will attempt to verify that the remote socket endpoint is still present if a sufficiently long period of time passes with no data being exchanged. If the system is unable to verify the presence of the remote endpoint, it will automatically close the connection.</p>
<p>This option is only functional on certain kinds of sockets. (Notably, SOCKET_PROTOCOL_TCP sockets.)</p>
<p>The exact time between pings is system- and protocol-dependent, but will normally be at least two hours. Most commonly, you would set this flag on a server socket if you want to allow clients to remain idle for long periods of time, but also want to ensure that connections are eventually garbage-collected if clients crash or become unreachable.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000103">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keepalive</td><td>Value for the keepalive flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc7b9d6cecc1c2234f9979b2ffb1b309"></a><!-- doxytag: member="Gio::Socket::set_listen_backlog" ref="adc7b9d6cecc1c2234f9979b2ffb1b309" args="(int backlog)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Socket.html#adc7b9d6cecc1c2234f9979b2ffb1b309">Gio::Socket::set_listen_backlog</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the maximum number of outstanding connections allowed when listening on this socket. </p>
<p>If more clients than this are connecting to the socket and the application is not handling them on time then the new connections will be refused.</p>
<p>Note that this must be called before g_socket_listen() and has no effect if called after that.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000099">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">backlog</td><td>The maximum number of pending connections. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe942e5157528b217d7af4a7839a9e7a"></a><!-- doxytag: member="Gio::Socket::set_timeout" ref="afe942e5157528b217d7af4a7839a9e7a" args="(guint timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Socket.html#afe942e5157528b217d7af4a7839a9e7a">Gio::Socket::set_timeout</a> </td>
          <td>(</td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the time in seconds after which I/O operations on <em>socket</em> will time out if they have not yet completed. </p>
<p>On a blocking socket, this means that any blocking <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> operation will time out after <em>timeout</em> seconds of inactivity, returning IO_ERROR_TIMED_OUT.</p>
<p>On a non-blocking socket, calls to g_socket_condition_wait() will also fail with IO_ERROR_TIMED_OUT after the given time. Sources created with g_socket_create_source() will trigger after <em>timeout</em> seconds of inactivity, with the requested condition set, at which point calling g_socket_receive(), g_socket_send(), g_socket_check_connect_result(), etc, will fail with IO_ERROR_TIMED_OUT.</p>
<p>If <em>timeout</em> is 0 (the default), operations will never time out on their own.</p>
<p>Note that if an I/O operation is interrupted by a signal, this may cause the timeout to be reset.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000253">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout for <em>socket</em>, in seconds, or 0 for none. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f685bc040e9e10abe093deec0719fd7"></a><!-- doxytag: member="Gio::Socket::shutdown" ref="a4f685bc040e9e10abe093deec0719fd7" args="(bool shutdown_read, bool shutdown_write)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Socket.html#a4f685bc040e9e10abe093deec0719fd7">Gio::Socket::shutdown</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shutdown_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shutdown_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shut down part of a full-duplex connection. </p>
<p>If <em>shutdown_read</em> is <code>true</code> then the receiving side of the connection is shut down, and further reading is disallowed.</p>
<p>If <em>shutdown_write</em> is <code>true</code> then the sending side of the connection is shut down, and further writing is disallowed.</p>
<p>It is allowed for both <em>shutdown_read</em> and <em>shutdown_write</em> to be <code>true</code>.</p>
<p>One example where this is used is graceful disconnect for TCP connections where you close the sending side, then wait for the other side to close the connection, thus ensuring that the other side saw all sent data.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000095">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">shutdown_read</td><td>Whether to shut down the read side. </td></tr>
    <tr><td class="paramname">shutdown_write</td><td>Whether to shut down the write side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ae33e646694bf6c5062683ba4b79d4fe1"></a><!-- doxytag: member="Gio::Socket::speaks_ipv4" ref="ae33e646694bf6c5062683ba4b79d4fe1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1Socket.html#ae33e646694bf6c5062683ba4b79d4fe1">Gio::Socket::speaks_ipv4</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if a socket is capable of speaking IPv4. </p>
<p>IPv4 sockets are capable of speaking IPv4. On some operating systems and under some combinations of circumstances IPv6 sockets are also capable of speaking IPv4. See RFC 3493 section 3.7 for more information.</p>
<p>No other types of sockets are currently considered as being capable of speaking IPv4.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000111">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if this socket can be used with IPv4. </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a4b4f2145105f84580f0a2659a9e8e5db"></a><!-- doxytag: member="Gio::Socket::wrap" ref="a4b4f2145105f84580f0a2659a9e8e5db" args="(GSocket *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Gio::Socket</a> &gt; <a class="el" href="classGio_1_1Socket.html#a4b4f2145105f84580f0a2659a9e8e5db">wrap</a> </td>
          <td>(</td>
          <td class="paramtype">GSocket *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 10 2012 14:20:38 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
