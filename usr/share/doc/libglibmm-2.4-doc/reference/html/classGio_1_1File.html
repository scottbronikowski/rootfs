<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>glibmm: Gio::File Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="/home/murrayc/checkouts/gnome30/glibmm/docs/doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.32.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceGio.html">Gio</a> </li>
      <li class="navelem"><a class="el" href="classGio_1_1File.html">File</a> </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> </div>
  <div class="headertitle">
<div class="title">Gio::File Class Reference</div> </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Gio::File" --><!-- doxytag: inherits="Glib::Interface" -->
<p><a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> and directory handling.  <a href="classGio_1_1File.html#details">More...</a></p>

<p><code>#include &lt;giomm/file.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gio::File:</div>
<div class="dyncontent">
<div class="center"><img src="classGio_1_1File__inherit__graph.png" border="0" usemap="#Gio_1_1File_inherit__map" alt="Inheritance graph"/></div>
<map name="Gio_1_1File_inherit__map" id="Gio_1_1File_inherit__map">
<area shape="rect" id="node2" href="classGlib_1_1Interface.html" title="Glib::Interface" alt="" coords="13,160,123,189"/><area shape="rect" id="node4" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="5,83,131,112"/><area shape="rect" id="node6" href="../../../libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="11,5,125,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGio_1_1File-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void, <br class="typebreak"/>
goffset, goffset &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal handler would be, for instance: void on_file_progress(goffset current_num_bytes, goffset total_num_bytes);. <a href="#ac5ff32ee99845479d138eee49d92e59c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; bool, <br class="typebreak"/>
const char*, goffset &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#add182d22071784fc345adc757b3d687b">SlotReadMore</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal handler would be, for instance: bool on_read_more(const char* file_contents, goffset file_size);. <a href="#add182d22071784fc345adc757b3d687b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af17e8c7b30baa13aaa5d58ef4d56e383">~File</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GFile*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a96552cfbaf2e5fa3659a1568db8cca91">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a96552cfbaf2e5fa3659a1568db8cca91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GFile*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5437bc648d8b73451e8bee0bc902cfc0">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a5437bc648d8b73451e8bee0bc902cfc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a9ea238062cdc317ae982ffae5c226c9b">dup</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> handle. <a href="#a9ea238062cdc317ae982ffae5c226c9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0320bac72ecc9ced1f894f1af696856f">hash</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a hash value for a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. <a href="#a0320bac72ecc9ced1f894f1af696856f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8877115c870ea8f58b03d1d3c01a83e4">equal</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks equality of two given Files. <a href="#a8877115c870ea8f58b03d1d3c01a83e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac731bed45bb7fcfd411eb69c49d3b883">get_basename</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the base name (the last component of the path) for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. <a href="#ac731bed45bb7fcfd411eb69c49d3b883"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7b3edc7946b681b6db2cdcdad08d2b00">get_path</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the local pathname for <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>, if one exists. <a href="#a7b3edc7946b681b6db2cdcdad08d2b00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2d1313e4a4eb5de034b693ec1cc9fba0">get_uri</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the URI for the <em>file</em>. <a href="#a2d1313e4a4eb5de034b693ec1cc9fba0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aea4a78163e3085a35cbaacde9a3a7628">get_parse_name</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parse name of the <em>file</em>. <a href="#aea4a78163e3085a35cbaacde9a3a7628"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af39bbd5013b2dd675911df322e12ff94">get_parent</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parent directory for the <em>file</em>. <a href="#af39bbd5013b2dd675911df322e12ff94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae0b0d16b849b2f92699ad57ee7c935d9">has_parent</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; parent) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <em>file</em> has a parent, and optionally, if it is <em>parent</em>. <a href="#ae0b0d16b849b2f92699ad57ee7c935d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa1daee0498c403e83ac509e6157edd1c">has_parent</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the file has any parent at all. <a href="#aa1daee0498c403e83ac509e6157edd1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a53c533d6bbeaaadd1b5592cf1e5ef93c">get_child</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a child of <em>file</em> with basename equal to <em>name</em>. <a href="#a53c533d6bbeaaadd1b5592cf1e5ef93c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a479cfd632af30b29e125f904f809ed71">get_child_for_display_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the child of <em>file</em> for a given <em>display_name</em> (i.e. a UTF8 version of the name). <a href="#a479cfd632af30b29e125f904f809ed71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4c40ec88dfc4333f19e939d26a1e0332">has_prefix</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; prefix) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <em>file</em> has the prefix specified by <em>prefix</em>. <a href="#a4c40ec88dfc4333f19e939d26a1e0332"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a464248111fa2bc5df89c620354eb99bb">get_relative_path</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; descendant) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the path for <em>descendant</em> relative to <em>parent</em>. <a href="#a464248111fa2bc5df89c620354eb99bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac5e286d421c7236df39881f8ce0a4e03">resolve_relative_path</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; relative_path) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves a relative path for <em>file</em> to an absolute path. <a href="#ac5e286d421c7236df39881f8ce0a4e03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aaa3b910bc9f240d4ebd0efc70979f163">is_native</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a file is native to the platform. <a href="#aaa3b910bc9f240d4ebd0efc70979f163"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a90d71529e5b51b9ff73914eaf90be0f1">has_uri_scheme</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; uri_scheme) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> has a given URI scheme. <a href="#a90d71529e5b51b9ff73914eaf90be0f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aeecec6962f955bd72ac5595be37db7a4">get_uri_scheme</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the URI scheme for a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. <a href="#aeecec6962f955bd72ac5595be37db7a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a3ef959c7ad7096846f26eb8b282e3c68">read</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a file for reading. <a href="#a3ef959c7ad7096846f26eb8b282e3c68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1">read</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a file for reading. <a href="#a0395b3b0b8cec5dc1fd9953e52e5fbc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2826eed0b1e76c3771f6ad5f5b993991">read_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously opens the file for reading. <a href="#a2826eed0b1e76c3771f6ad5f5b993991"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab451a182a647408e697c9115e66f6194">read_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously opens the file for reading. <a href="#ab451a182a647408e697c9115e66f6194"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a64b10854ad1add1f888ecb19403eb921">read_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file read operation started with g_file_read_async(). <a href="#a64b10854ad1add1f888ecb19403eb921"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a91c93ee71eee738690cb551d11df9528">append_to</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an output stream for appending data to the file. <a href="#a91c93ee71eee738690cb551d11df9528"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8db337b93f3b9b9a6e163477391e6c89">append_to</a> (<a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an output stream for appending data to the file. <a href="#a8db337b93f3b9b9a6e163477391e6c89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a86258e11b2884422819d051c3cfd07a2">create_file</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new file and returns an output stream for writing to it. <a href="#a86258e11b2884422819d051c3cfd07a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5cf2b17b953ccfefb1d13c39bd1be72c">create_file</a> (<a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new file and returns an output stream for writing to it. <a href="#a5cf2b17b953ccfefb1d13c39bd1be72c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad5ec69c5360219bccb794bab6a128e88">create_file_readwrite</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new file and returns a stream for reading and writing to it. <a href="#ad5ec69c5360219bccb794bab6a128e88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#acf5673ceb9095405e458b5035b0986b4">create_file_readwrite</a> (<a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new file and returns a stream for reading and writing to it. <a href="#acf5673ceb9095405e458b5035b0986b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad7cf0360096504e40f799fde5cc8e9de">replace</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an output stream for overwriting the file, possibly creating a backup copy of the file first. <a href="#ad7cf0360096504e40f799fde5cc8e9de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#acf55f9291659566f6fd36271801b013b">replace</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an output stream for overwriting the file, possibly creating a backup copy of the file first. <a href="#acf55f9291659566f6fd36271801b013b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1e3dfb193e8f2ab69e24c4370de5335a">append_to_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously opens the file for appending. <a href="#a1e3dfb193e8f2ab69e24c4370de5335a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#abff3163e9bf8d8208cd0c0e568b777de">append_to_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously opens the file for appending. <a href="#abff3163e9bf8d8208cd0c0e568b777de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#acb1f2d32055b8da274ea241c69487dc6">append_to_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file append operation started with g_file_append_to_async(). <a href="#acb1f2d32055b8da274ea241c69487dc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae0c42446d37aa466173965b7db1a2053">create_file_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously creates a new file and returns an output stream for writing to it. <a href="#ae0c42446d37aa466173965b7db1a2053"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a3fe6ed015f3d2bb72aa7aceed8dc7ca1">create_file_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously creates a new file and returns an output stream for writing to it. <a href="#a3fe6ed015f3d2bb72aa7aceed8dc7ca1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a622b9f7aeaebe2ac53df0574c9c4211a">create_file_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file create operation started with g_file_create_async(). <a href="#a622b9f7aeaebe2ac53df0574c9c4211a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4c27a2460468aab1d3c3665234c24a56">create_file_readwrite_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously creates a new file and returns a stream for reading and writing to it. <a href="#a4c27a2460468aab1d3c3665234c24a56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5a5989cfdee54778de733a529c24607b">create_file_readwrite_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously creates a new file and returns a stream for reading and writing to it. <a href="#a5a5989cfdee54778de733a529c24607b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae75da0ef250a3b27c2811a5e70f58536">create_file_readwrite_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file create operation started with g_file_create_readwrite_async(). <a href="#ae75da0ef250a3b27c2811a5e70f58536"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad777cdaa404a6a668ee8d520299687ce">replace_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asyncronously overwrites the file, replacing the contents, possibly creating a backup copy of the file first. <a href="#ad777cdaa404a6a668ee8d520299687ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae51e51a2e3a45da4324230b4d5401a58">replace_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asyncronously overwrites the file, replacing the contents, possibly creating a backup copy of the file first. <a href="#ae51e51a2e3a45da4324230b4d5401a58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab28557d592f2c53df618728cf865e65e">replace_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file replace operation started with g_file_replace_async(). <a href="#ab28557d592f2c53df618728cf865e65e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a128757d6cf7b152c82bb378a095003ef">open_readwrite</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing file for reading and writing. <a href="#a128757d6cf7b152c82bb378a095003ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a73d95a731716c7ffaa86c3af90afe8d3">open_readwrite_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing file for reading and writing. <a href="#a73d95a731716c7ffaa86c3af90afe8d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a405af7082f531a7a39f3e7a453ab6267">open_readwrite_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing file for reading and writing. <a href="#a405af7082f531a7a39f3e7a453ab6267"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a9c501374d1257d5eeed903be20b66f63">open_readwrite_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file read operation started with g_file_open_readwrite_async(). <a href="#a9c501374d1257d5eeed903be20b66f63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af483e2ddc29cbb6cd1ad751403247bad">replace_readwrite</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy of the file first. <a href="#af483e2ddc29cbb6cd1ad751403247bad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0c4aa84e74b27a67bce6b5fdccb91449">replace_readwrite</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy of the file first. <a href="#a0c4aa84e74b27a67bce6b5fdccb91449"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af5ebbb5e33c0afd302add9863f2d8c24">replace_readwrite_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asyncronously overwrites the file in read-write mode, replacing the contents, possibly creating a backup copy of the file first. <a href="#af5ebbb5e33c0afd302add9863f2d8c24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a38b7d1782f03a4d6a4dbf3be16321324">replace_readwrite_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asyncronously overwrites the file in read-write mode, replacing the contents, possibly creating a backup copy of the file first. <a href="#a38b7d1782f03a4d6a4dbf3be16321324"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5733a0911dcd0ccc20f1f54fb3378b18">replace_readwrite_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file replace operation started with g_file_replace_readwrite_async(). <a href="#a5733a0911dcd0ccc20f1f54fb3378b18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd">query_info</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the requested information about the file. <a href="#adb25ffdbe571d33e89c9503fe9a20dcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4e4b9c07ade255b12e2b43c38c3aba90">query_info</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the requested information about the file. <a href="#a4e4b9c07ade255b12e2b43c38c3aba90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad8b0a75e0afdb5f6874ea5e304d55ea8">query_exists</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to check if a particular file exists. <a href="#ad8b0a75e0afdb5f6874ea5e304d55ea8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab4cfdbf4fedacd364e40a72c71ab341a">query_exists</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to check if a particular file exists. <a href="#ab4cfdbf4fedacd364e40a72c71ab341a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga7dcba95023d74c47bba3fd0a07f8824c">FileType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa27c5b271c8f7667ce117cfc6118262e">query_file_type</a> (<a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to inspect the FileType of a file. <a href="#aa27c5b271c8f7667ce117cfc6118262e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga7dcba95023d74c47bba3fd0a07f8824c">FileType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a691a9de5512b870bf358a9b0d292e146">query_file_type</a> (<a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to inspect the #GFileType of a file. <a href="#a691a9de5512b870bf358a9b0d292e146"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7bd60e7864f8954c35e3b0891058e61c">query_info_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about specified file. <a href="#a7bd60e7864f8954c35e3b0891058e61c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afcad69d782a971802a8aa85125ac2c8c">query_info_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about specified file. <a href="#afcad69d782a971802a8aa85125ac2c8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afd4ffc3630b41754c177658f2e745357">query_info_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file info query. <a href="#afd4ffc3630b41754c177658f2e745357"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a40486bc2f0c8758ef8a705b6b8b57e57">query_filesystem_info</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a>, but obtains information about the filesystem the file is on, rather than the file itself. <a href="#a40486bc2f0c8758ef8a705b6b8b57e57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac737012f8df97d90e2447d94d30b817d">query_filesystem_info</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a>, but obtains information about the filesystem the file is on, rather than the file itself. <a href="#ac737012f8df97d90e2447d94d30b817d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Mount.html">Mount</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a45b881926b8d58c49d3baa1f51f2ee5d">find_enclosing_mount</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts.">Mount</a> for the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. <a href="#a45b881926b8d58c49d3baa1f51f2ee5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a39184ff9c9437259df4b9a9e2f283a0b">query_filesystem_info_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about the filesystem that the file is on. <a href="#a39184ff9c9437259df4b9a9e2f283a0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4557ab16a50337f73d8a4649cf60fe70">query_filesystem_info_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about the filesystem that the file is on. <a href="#a4557ab16a50337f73d8a4649cf60fe70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afd1159de8f782d918d8d460cddffee5b">query_filesystem_info_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous filesystem info query. <a href="#afd1159de8f782d918d8d460cddffee5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Mount.html">Mount</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333">find_enclosing_mount</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts.">Mount</a> for the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. <a href="#a6eb675267c7ea1c2a0d40e2e754d8333"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a78c95d4fa47157f7757b686677dec018">find_enclosing_mount_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the mount for the file. <a href="#a78c95d4fa47157f7757b686677dec018"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a67458be57c5687e7469bc26e2594f4be">find_enclosing_mount_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the mount for the file. <a href="#a67458be57c5687e7469bc26e2594f4be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Mount.html">Mount</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa12e6222d81179937cdc366f4d315433">find_enclosing_mount_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous find mount request. <a href="#aa12e6222d81179937cdc366f4d315433"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a68c3afcddc0d4860aa2afb4bf715bb20">enumerate_children</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the requested information about the files in a directory. <a href="#a68c3afcddc0d4860aa2afb4bf715bb20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac0e293d607499b223f4892fb290ab2d6">enumerate_children</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the requested information about the files in a directory. <a href="#ac0e293d607499b223f4892fb290ab2d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1ead7237b7057d9b15cf5f3065988131">enumerate_children_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about the files in a directory. <a href="#a1ead7237b7057d9b15cf5f3065988131"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5b5470cf1c97754a12169201665f1202">enumerate_children_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about the files in a directory. <a href="#a5b5470cf1c97754a12169201665f1202"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a617a2950448788e68df128c58e068a14">enumerate_children_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an async enumerate children operation. <a href="#a617a2950448788e68df128c58e068a14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018">set_display_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames <em>file</em> to the specified display name. <a href="#a3dd75810d7c9ebafac398288f5afc018"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8c2aa80b2d0ecdd22f0222c8ce42d177">set_display_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames the file to the specified display name. <a href="#a8c2aa80b2d0ecdd22f0222c8ce42d177"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0ac539d7758b9c0de809f8c83e0bba79">set_display_name_async</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the display name for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a>. <a href="#a0ac539d7758b9c0de809f8c83e0bba79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a74d219d321dca3d438f876256dee82d2">set_display_name_async</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the display name for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a>. <a href="#a74d219d321dca3d438f876256dee82d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a101b555723233014c0185dd505303f0a">set_display_name_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes setting a display name started with g_file_set_display_name_async(). <a href="#a101b555723233014c0185dd505303f0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aded971b0cf84801f6684ad4bd5dc66c5">remove</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a file. <a href="#aded971b0cf84801f6684ad4bd5dc66c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a14f34508dea523cbf889b7193e513ca4">remove</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a file. <a href="#a14f34508dea523cbf889b7193e513ca4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#acae5ecd962e832cf8d538877f4118da8">trash</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <em>file</em> to the "Trashcan", if possible. <a href="#acae5ecd962e832cf8d538877f4118da8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1925736f9af338eaf9942468b4d6d65e">trash</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the file to the "Trashcan", if possible. <a href="#a1925736f9af338eaf9942468b4d6d65e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9">copy</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file source to the location specified by destination. <a href="#af9e906ed93069e6adb6d87dae158cad9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1d8159b5b377db174b376b3c09deb7c1">copy</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file source to the location specified by destination. <a href="#a1d8159b5b377db174b376b3c09deb7c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7a6b45bed32567031bc7b48273ad4079">copy</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file source to the location specified by destination. <a href="#a7a6b45bed32567031bc7b48273ad4079"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1785b7a4780d5d4ba5ae651350e34398">copy_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp; slot_progress, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_ready, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file to the location specified by <em>destination</em> asynchronously. <a href="#a1785b7a4780d5d4ba5ae651350e34398"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5b8ae7393c73a9a1d383a82d61f4ac30">copy_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_ready, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file to the location specified by <em>destination</em> asynchronously. <a href="#a5b8ae7393c73a9a1d383a82d61f4ac30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac2b1a85f29bbbe15998c090b3794cbf5">copy_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp; slot_progress, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_ready, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file to the location specified by <em>destination</em> asynchronously. <a href="#ac2b1a85f29bbbe15998c090b3794cbf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad538a383b8761d04bd36ed1aa1071e50">copy_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_ready, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file to the location specified by <em>destination</em> asynchronously. <a href="#ad538a383b8761d04bd36ed1aa1071e50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a68294636a2d649c9de53332faee02cf6">copy_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes copying the file started with g_file_copy_async(). <a href="#a68294636a2d649c9de53332faee02cf6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a51c0d55880178c37dee578fdc723b0f2">move</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to move the file or directory source to the location specified by destination. <a href="#a51c0d55880178c37dee578fdc723b0f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#adfb2d8bfed1cb7af50e5e5795ebea732">move</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aba1fab56c3a8bea0b7e4d7f7324c5320">move</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#abfa05e23e95e77cabac289ab4e294a58">make_directory</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory. <a href="#abfa05e23e95e77cabac289ab4e294a58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa1e9aa5f58a76a8562fd00a13434f554">make_directory</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory. <a href="#aa1e9aa5f58a76a8562fd00a13434f554"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afb0b5b094339057b4b15952eb73e08d6">make_directory_with_parents</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory and any parent directories that may not exist similar to 'mkdir -p'. <a href="#afb0b5b094339057b4b15952eb73e08d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a874a487551d49ca62b31a3e5cf32fee6">make_directory_with_parents</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory and any parent directories that may not exist, similar to 'mkdir -p'. <a href="#a874a487551d49ca62b31a3e5cf32fee6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2709318e1f24dfd0cd498d28f5e1b8fe">make_symbolic_link</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; symlink_value, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a symbolic link. <a href="#a2709318e1f24dfd0cd498d28f5e1b8fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8a9a3d060c2675ff9ac1c758f0b2c024">make_symbolic_link</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; symlink_value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a symbolic link. <a href="#a8a9a3d060c2675ff9ac1c758f0b2c024"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4a543339b58cff6a7e5ddd840df0e69e">query_settable_attributes</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of settable attributes for the file. <a href="#a4a543339b58cff6a7e5ddd840df0e69e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1ae03d0652bcfbad2f47409b8f815bc4">query_settable_attributes</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of settable attributes for the file. <a href="#a1ae03d0652bcfbad2f47409b8f815bc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af5c7463b92e2887597486e7b195ca12f">query_writable_namespaces</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of attribute namespaces where new attributes can be created by a user. <a href="#af5c7463b92e2887597486e7b195ca12f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa0278acd7d09ed292359004defb742b0">query_writable_namespaces</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of attribute namespaces where new attributes can be created by a user. <a href="#aa0278acd7d09ed292359004defb742b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a69d9e40a85b96809abc5189b34e8d9b7">set_attributes_from_info</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to set all attributes in the <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> on the target values, not stopping on the first error. <a href="#a69d9e40a85b96809abc5189b34e8d9b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae9f6975ffef28f0d7145601a99de0903">set_attributes_from_info</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to set all attributes in the <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> on the target values, not stopping on the first error. <a href="#ae9f6975ffef28f0d7145601a99de0903"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a14165fba9bf7d91448c3207407ae50c2">set_attributes_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the attributes of file with info. <a href="#a14165fba9bf7d91448c3207407ae50c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a61317a1980318537aa8ada7bb8cc2390">set_attributes_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the attributes of file with info. <a href="#a61317a1980318537aa8ada7bb8cc2390"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aefd45aed7b975b6e204e67927de2817a">set_attributes_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5ce5f43fd5e2836ac1989a54d3233ff6">set_attribute_string</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01628.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_STRING to <em>value</em>. <a href="#a5ce5f43fd5e2836ac1989a54d3233ff6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a75fa7e1a44e97a910d232f2b4ab4bfdd">set_attribute_string</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01628.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_STRING to <em>value</em>. <a href="#a75fa7e1a44e97a910d232f2b4ab4bfdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4f4373b8694c346a6908195f1f2644f3">set_attribute_byte_string</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01628.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_BYTE_STRING to <em>value</em>. <a href="#a4f4373b8694c346a6908195f1f2644f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a09f574259052186e1b516bdcbe696710">set_attribute_byte_string</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01628.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_BYTE_STRING to <em>value</em>. <a href="#a09f574259052186e1b516bdcbe696710"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae53b0f4d2214e050a290c8e35cac0f27">set_attribute_uint32</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, guint32 <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01628.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT32 to <em>value</em>. <a href="#ae53b0f4d2214e050a290c8e35cac0f27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7f769f140143f2e96a7587a10b6792a9">set_attribute_uint32</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, guint32 <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01628.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT32 to <em>value</em>. <a href="#a7f769f140143f2e96a7587a10b6792a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab0290ecba7b06ccf7736e2292708667e">set_attribute_int32</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, gint32 <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01628.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT32 to <em>value</em>. <a href="#ab0290ecba7b06ccf7736e2292708667e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4a707084a3c0a963548a21d17d0ec0b5">set_attribute_int32</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, gint32 <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01628.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT32 to <em>value</em>. <a href="#a4a707084a3c0a963548a21d17d0ec0b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a48638081fd7af772a39af59a558b17f7">set_attribute_uint64</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, guint64 <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01628.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT64 to <em>value</em>. <a href="#a48638081fd7af772a39af59a558b17f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4aa77b3580df88cfd3d7231af78155c7">set_attribute_uint64</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, guint64 <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01628.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT64 to <em>value</em>. <a href="#a4aa77b3580df88cfd3d7231af78155c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a111d73a2d003e5a5a4c5f86c7c3d2fb7">set_attribute_int64</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, gint64 <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01628.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT64 to <em>value</em>. <a href="#a111d73a2d003e5a5a4c5f86c7c3d2fb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4477b0063110951b26c855696ec34802">set_attribute_int64</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, gint64 <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01628.html#ga1c9e781d8d15a3814a601f471797c825">value</a>, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT64 to <em>value</em>. <a href="#a4477b0063110951b26c855696ec34802"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a144aa2de6b696da90a6baffbe959d732">mount_enclosing_volume</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga5484bace25c932fd4c7354259e138814a4fa5bb6630552f216d543dc14bdce93f">MOUNT_MOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a <em>mount_operation</em>, mounting the volume that contains the file. <a href="#a144aa2de6b696da90a6baffbe959d732"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a70fd22116d9c8682433c4bb8cbd764c1">mount_enclosing_volume</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga5484bace25c932fd4c7354259e138814a4fa5bb6630552f216d543dc14bdce93f">MOUNT_MOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a <em>mount_operation</em>, mounting the volume that contains the file. <a href="#a70fd22116d9c8682433c4bb8cbd764c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2172cdcdb683630b719c521bf00b1eb4">mount_enclosing_volume</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga5484bace25c932fd4c7354259e138814a4fa5bb6630552f216d543dc14bdce93f">MOUNT_MOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a <em>mount_operation</em>, mounting the volume that contains the file. <a href="#a2172cdcdb683630b719c521bf00b1eb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a20f8f18876102a5efaa0536bfa71d71c">mount_enclosing_volume</a> (<a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga5484bace25c932fd4c7354259e138814a4fa5bb6630552f216d543dc14bdce93f">MOUNT_MOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a <em>mount_operation</em>, mounting the volume that contains the file. <a href="#a20f8f18876102a5efaa0536bfa71d71c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d">mount_enclosing_volume_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes a mount operation started by g_file_mount_enclosing_volume(). <a href="#aefd44b1b3467bcc474b345ff98b4aa6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a40c88a403f5d01d722b5900545b6a4fe">mount_mountable</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga5484bace25c932fd4c7354259e138814a4fa5bb6630552f216d543dc14bdce93f">MOUNT_MOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a file of type FILE_TYPE_MOUNTABLE. <a href="#a40c88a403f5d01d722b5900545b6a4fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac3c29682ef5a50de73dc2c3c3333301c">mount_mountable</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga5484bace25c932fd4c7354259e138814a4fa5bb6630552f216d543dc14bdce93f">MOUNT_MOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a file of type FILE_TYPE_MOUNTABLE. <a href="#ac3c29682ef5a50de73dc2c3c3333301c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a049e06c3d95b49ad4bff1837ef6d8677">mount_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga5484bace25c932fd4c7354259e138814a4fa5bb6630552f216d543dc14bdce93f">MOUNT_MOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a file of type FILE_TYPE_MOUNTABLE without user interaction. <a href="#a049e06c3d95b49ad4bff1837ef6d8677"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8501fa88f4aaa8d52c001596960a4572">mount_mountable</a> (<a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga5484bace25c932fd4c7354259e138814a4fa5bb6630552f216d543dc14bdce93f">MOUNT_MOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a file of type FILE_TYPE_MOUNTABLE without user interaction. <a href="#a8501fa88f4aaa8d52c001596960a4572"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8">mount_mountable_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes a mount operation. <a href="#ae15d36a7969c55122b9f85a1690a46e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5b687c8f19411e955bb069c469be92b4">unmount_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE. <a href="#a5b687c8f19411e955bb069c469be92b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab6c8e9ef0e5d83a271c8307b18e779d8">unmount_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE. <a href="#ab6c8e9ef0e5d83a271c8307b18e779d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a95f3e87e198493f4332a08aa79f6ebd3">unmount_mountable</a> (<a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE. <a href="#a95f3e87e198493f4332a08aa79f6ebd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a13f7cceb9754a7498789593dd58d818c">unmount_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE. <a href="#a13f7cceb9754a7498789593dd58d818c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad82d5b087fef21cbadcb9407d7f43223">unmount_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE. <a href="#ad82d5b087fef21cbadcb9407d7f43223"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae322b2d5f8f1d95023831c3964c9b015">unmount_mountable</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE. <a href="#ae322b2d5f8f1d95023831c3964c9b015"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d">unmount_mountable_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details. <a href="#a51458cf04ad25e4a784a3ebcb906155d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8a8223e3b661f03c7a60ac0f003b916e">eject_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous eject on a mountable. <a href="#a8a8223e3b661f03c7a60ac0f003b916e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad8422a939a634d2248ef6d8658f0fdad">eject_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous eject on a mountable. <a href="#ad8422a939a634d2248ef6d8658f0fdad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aeb28fd505cab23a82c68ff00445b12e7">eject_mountable</a> (<a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous eject on a mountable. <a href="#aeb28fd505cab23a82c68ff00445b12e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1c103886296fd1ea1107906deebec8a5">eject_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous eject on a mountable. <a href="#a1c103886296fd1ea1107906deebec8a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab6c75952828023d27d109a3a23fafc00">eject_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous eject on a mountable. <a href="#ab6c75952828023d27d109a3a23fafc00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab7aea22f6cb30b3f2be43682ddd543d9">eject_mountable</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous eject on a mountable. <a href="#ab7aea22f6cb30b3f2be43682ddd543d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f">eject_mountable_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation(). <a href="#a6a5124de7c55e9dc5e85ffcb9d3dd14f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a90726dcf94248d2fddf2e4c8584b7bf0">copy_attributes</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file attributes from <em>source</em> to <em>destination</em>. <a href="#a90726dcf94248d2fddf2e4c8584b7bf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a05c1101ede98028c9234486eb0434250">copy_attributes</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file attributes from <em>source</em> to <em>destination</em>. <a href="#a05c1101ede98028c9234486eb0434250"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa0fa22ffba0ff50779e49ff9d12344e6">monitor_directory</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="group__giommEnums.html#gga469f795e9a4dddb2421c0e5568be6649ab14b94920f9dd257f04b8d2089ee7f41">FILE_MONITOR_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a directory monitor for the given file. <a href="#aa0fa22ffba0ff50779e49ff9d12344e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a12d36689c1024ff9fc8819f619910a92">monitor_directory</a> (<a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="group__giommEnums.html#gga469f795e9a4dddb2421c0e5568be6649ab14b94920f9dd257f04b8d2089ee7f41">FILE_MONITOR_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a directory monitor for the given file. <a href="#a12d36689c1024ff9fc8819f619910a92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab8e14809f330ddd58e628c96921cd987">monitor_file</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="group__giommEnums.html#gga469f795e9a4dddb2421c0e5568be6649ab14b94920f9dd257f04b8d2089ee7f41">FILE_MONITOR_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a file monitor for the given file. <a href="#ab8e14809f330ddd58e628c96921cd987"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa410183ed3b4a745093383d038d271b9">monitor_file</a> (<a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="group__giommEnums.html#gga469f795e9a4dddb2421c0e5568be6649ab14b94920f9dd257f04b8d2089ee7f41">FILE_MONITOR_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a file monitor for the given file. <a href="#aa410183ed3b4a745093383d038d271b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a88aacee7bb6f6d968b4383311a9dd002">monitor</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="group__giommEnums.html#gga469f795e9a4dddb2421c0e5568be6649ab14b94920f9dd257f04b8d2089ee7f41">FILE_MONITOR_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a file monitor for the given file. <a href="#a88aacee7bb6f6d968b4383311a9dd002"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a50896969a9de87f810f0bf5e2d3335bd">monitor</a> (<a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="group__giommEnums.html#gga469f795e9a4dddb2421c0e5568be6649ab14b94920f9dd257f04b8d2089ee7f41">FILE_MONITOR_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a file monitor for the given file. <a href="#a50896969a9de87f810f0bf5e2d3335bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa4438daeeb2171e3065bb677b6768721">start_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; start_operation, <a class="el" href="group__giommEnums.html#gab628e70b1d028b3bc9b02b0d3b8acf2d">DriveStartFlags</a> flags=<a class="el" href="group__giommEnums.html#ggab628e70b1d028b3bc9b02b0d3b8acf2da6a46299fc0a721de0bed46063ba484de">DRIVE_START_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a file of type Mountable. <a href="#aa4438daeeb2171e3065bb677b6768721"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad629eaf059b2e05b1f9bfc10c5732974">start_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; start_operation, <a class="el" href="group__giommEnums.html#gab628e70b1d028b3bc9b02b0d3b8acf2d">DriveStartFlags</a> flags=<a class="el" href="group__giommEnums.html#ggab628e70b1d028b3bc9b02b0d3b8acf2da6a46299fc0a721de0bed46063ba484de">DRIVE_START_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a file of type Mountable. <a href="#ad629eaf059b2e05b1f9bfc10c5732974"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af11e51943807876180474b39d2e521ac">start_mountable_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes a start operation. <a href="#af11e51943807876180474b39d2e521ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac101831f87245a881c338014f15d38d8">stop_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; start_operation, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops a file of type Mountable. <a href="#ac101831f87245a881c338014f15d38d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5ccfb3006c2bc69a32e5055939b462d6">stop_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; start_operation, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops a file of type Mountable. <a href="#a5ccfb3006c2bc69a32e5055939b462d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a195990af8825745d0d26147174824565">stop_mountable_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an stop operation, see g_file_stop_mountable() for details. <a href="#a195990af8825745d0d26147174824565"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8e81dd0bab13e56ed98456f6a53591ca">poll_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls a file of type Mountable. <a href="#a8e81dd0bab13e56ed98456f6a53591ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2025339de9d7ed9b62300cad1a8e8fd4">poll_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls a file of type Mountable. <a href="#a2025339de9d7ed9b62300cad1a8e8fd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2da5ec13a4a32f229ca97cce8961e637">poll_mountable_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes a poll operation. <a href="#a2da5ec13a4a32f229ca97cce8961e637"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AppInfo.html">AppInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a753546465735b25633b003333b66d05c">query_default_handler</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch them...">AppInfo</a> that is registered as the default application to handle the file specified by <em>file</em>. <a href="#a753546465735b25633b003333b66d05c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AppInfo.html">AppInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0c0fd0ece2570b6704889df5ee43c283">query_default_handler</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch them...">AppInfo</a> that is registered as the default application to handle the file specified by the file. <a href="#a0c0fd0ece2570b6704889df5ee43c283"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15">load_contents</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, char*&amp; contents, gsize&amp; length, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag_out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the content of the file into memory, returning the size of the data. <a href="#ac53be228d732b34e062a2a57814cdf15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ada7c826a417f88b405244c8dc39ae1ef">load_contents</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, char*&amp; contents, gsize&amp; length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the content of the file into memory, returning the size of the data. <a href="#ada7c826a417f88b405244c8dc39ae1ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a77f7781b0ba65bc4e7e613b80b353fd7">load_contents</a> (char*&amp; contents, gsize&amp; length, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag_out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the content of the file into memory, returning the size of the data. <a href="#a77f7781b0ba65bc4e7e613b80b353fd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a40f3ce7cf905144bac7218f9988d2d35">load_contents</a> (char*&amp; contents, gsize&amp; length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the content of the file into memory, returning the size of the data. <a href="#a40f3ce7cf905144bac7218f9988d2d35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad0e02ebffbaa13036e4636d2118f71a0">load_contents_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous load of the file's contents. <a href="#ad0e02ebffbaa13036e4636d2118f71a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6af7ec98d5543bce07b917b65d7276ce">load_contents_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous load of the file's contents. <a href="#a6af7ec98d5543bce07b917b65d7276ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5fd15277ab90bcc57db088be04cac457">load_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, char*&amp; contents, gsize&amp; length, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag_out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous load of the <em>file's</em> contents. <a href="#a5fd15277ab90bcc57db088be04cac457"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aee93c7e24e8391615f9f263584fb02bd">load_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, char*&amp; contents, gsize&amp; length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous load of the <em>file's</em> contents. <a href="#aee93c7e24e8391615f9f263584fb02bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f">load_partial_contents_async</a> (const <a class="el" href="classGio_1_1File.html#add182d22071784fc345adc757b3d687b">SlotReadMore</a>&amp; slot_read_more, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_async_ready, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the partial contents of a file. <a href="#a0e8d95fcdf7c2aa38f54e90a22d3ab6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a362d71932c0ba8797a8c47b77df1b6d7">load_partial_contents_async</a> (const <a class="el" href="classGio_1_1File.html#add182d22071784fc345adc757b3d687b">SlotReadMore</a>&amp; slot_read_more, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_async_ready)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the partial contents of a file. <a href="#a362d71932c0ba8797a8c47b77df1b6d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb">load_partial_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, char*&amp; contents, gsize&amp; length, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag_out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous partial load operation that was started with <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f" title="Reads the partial contents of a file.">load_partial_contents_async()</a>. <a href="#a4b323508401d2e6fd2b3ad659f9bb5eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae3a59c3831feeadea9bd0709617d2db9">load_partial_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, char*&amp; contents, gsize&amp; length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous partial load operation that was started with <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f" title="Reads the partial contents of a file.">load_partial_contents_async()</a>. <a href="#ae3a59c3831feeadea9bd0709617d2db9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af10deca1d5c5d1f650d3b182624330dc">replace_contents</a> (const char* contents, gsize length, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the file with <em>contents</em> of <em>length</em> bytes. <a href="#af10deca1d5c5d1f650d3b182624330dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae7febf1f0f3b4b9efca9fae469082846">replace_contents</a> (const char* contents, gsize length, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the file with <em>contents</em> of <em>length</em> bytes. <a href="#ae7febf1f0f3b4b9efca9fae469082846"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a23126b43cd262b63c0e458c3a4d0b65c">replace_contents</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; contents, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the file with <em>contents</em>. <a href="#a23126b43cd262b63c0e458c3a4d0b65c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aaf33a17461ff4f70fed06818e364f617">replace_contents</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; contents, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the file with <em>contents</em>. <a href="#aaf33a17461ff4f70fed06818e364f617"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c">replace_contents_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const char* contents, gsize length, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. <a href="#ad33b24a7942429157f47379f4353378c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a9a1c445e84124e16294974a73f2f1bbb">replace_contents_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const char* contents, gsize length, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. <a href="#a9a1c445e84124e16294974a73f2f1bbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a380d6ce6362fc05e0e18ff1b881ceac7">replace_contents_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; contents, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. <a href="#a380d6ce6362fc05e0e18ff1b881ceac7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6fc86aab90620881899a701c2b2775cb">replace_contents_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; contents, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous replacement of the file with the given <em>contents</em>. <a href="#a6fc86aab90620881899a701c2b2775cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af019065c5503c7f47d778c20f8e5de32">replace_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous replace of the given file . <a href="#af019065c5503c7f47d778c20f8e5de32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af0372ffd3f535f39b7e48c0483e4c1f4">replace_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous replace of the given file . <a href="#af0372ffd3f535f39b7e48c0483e4c1f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab666a9ec3922903646504f4080758522">supports_thread_contexts</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <em>file</em> supports thread-default contexts. <a href="#ab666a9ec3922903646504f4080758522"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa9352e68c93431dd16b8ac587703772f">add_interface</a> (GType gtype_implementer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1b1a4553b226689d50b9525488223e25">create_for_path</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> for a given path. <a href="#a1b1a4553b226689d50b9525488223e25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a412b6b55f37f69bd4fb8fbd24d4967be">create_for_uri</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; uri)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> for a given URI. <a href="#a412b6b55f37f69bd4fb8fbd24d4967be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab311a1c606b3907865fc8aecd4691de8">create_for_commandline_arg</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01604.html#ga943544cb1017a51d7cafc7b4d3cd022f">arg</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> for a given argument from the command line. <a href="#ab311a1c606b3907865fc8aecd4691de8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7532baa6ce71fe27cfd1e9bba91a3536">create_for_parse_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; parse_name)</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#abb3b1f0b8e19505b34ae084c518d20fc">File</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">You should derive from this class to use it. <a href="#abb3b1f0b8e19505b34ae084c518d20fc"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">Gio::File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a69670cdc7cf63783d6f9370dcbd7cc3d">wrap</a> (GFile* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#a69670cdc7cf63783d6f9370dcbd7cc3d"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> and directory handling. </p>
<p><a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> is a high level abstraction for manipulating files on a virtual file system. Gio::Files are lightweight, immutable objects that do no I/O upon creation. It is necessary to understand that a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> object does not represent a file, merely a handle to a file. All file I/O is implemented as streaming operations (see <a class="el" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input.">Gio::InputStream</a> and <a class="el" href="classGio_1_1OutputStream.html" title="Base class for implementing streaming output.">Gio::OutputStream</a>).</p>
<p>A GioFile can be constructed from a path, URI, or a command line argument.</p>
<p>You can move through the filesystem with <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> handles with <a class="el" href="classGio_1_1File.html#af39bbd5013b2dd675911df322e12ff94" title="Gets the parent directory for the file.">get_parent()</a> to get a handle to the parent directory, <a class="el" href="classGio_1_1File.html#a53c533d6bbeaaadd1b5592cf1e5ef93c" title="Gets a child of file with basename equal to name.">get_child()</a> to get a handle to a child within a directory, and <a class="el" href="classGio_1_1File.html#ac5e286d421c7236df39881f8ce0a4e03" title="Resolves a relative path for file to an absolute path.">resolve_relative_path()</a> to resolve a relative path between two Gio::Files.</p>
<p>Many <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> operations have both synchronous and asynchronous versions to suit your application. Asynchronous versions of synchronous functions simply have _async() appended to their function names. The asynchronous I/O functions call a SlotAsyncReady callback slot which is then used to finalize the operation, producing a <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> which is then passed to the function's matching _finish() operation.</p>
<p>Some <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> operations do not have synchronous analogs, as they may take a very long time to finish, and blocking may leave an application unusable. Notable cases include: <a class="el" href="classGio_1_1File.html#a40c88a403f5d01d722b5900545b6a4fe" title="Mounts a file of type FILE_TYPE_MOUNTABLE.">mount_mountable()</a> to mount a mountable file, <a class="el" href="classGio_1_1File.html#a5b687c8f19411e955bb069c469be92b4" title="Unmounts a file of type FILE_TYPE_MOUNTABLE.">unmount_mountable()</a> to unmount a mountable file, and <a class="el" href="classGio_1_1File.html#a8a8223e3b661f03c7a60ac0f003b916e" title="Starts an asynchronous eject on a mountable.">eject_mountable()</a> to eject a mountable file.</p>
<p>One notable feature of Gio::Files are entity tags, or "etags" for short. Entity tags are somewhat like a more abstract version of the traditional mtime, and can be used to quickly determine if the file has been modified from the version on the file system. See the HTTP 1.1 specification for HTTP Etag headers, which are a very similar concept.</p>
<dl class="since_2_16"><dt><b><a class="el" href="since_2_16.html#_since_2_16000023">Since glibmm 2.16:</a></b></dt><dd></dd></dl>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ac5ff32ee99845479d138eee49d92e59c"></a><!-- doxytag: member="Gio::File::SlotFileProgress" ref="ac5ff32ee99845479d138eee49d92e59c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;void, goffset, goffset&gt; <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">Gio::File::SlotFileProgress</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A signal handler would be, for instance: void on_file_progress(goffset current_num_bytes, goffset total_num_bytes);. </p>

</div>
</div>
<a class="anchor" id="add182d22071784fc345adc757b3d687b"></a><!-- doxytag: member="Gio::File::SlotReadMore" ref="add182d22071784fc345adc757b3d687b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;bool, const char*, goffset&gt; <a class="el" href="classGio_1_1File.html#add182d22071784fc345adc757b3d687b">Gio::File::SlotReadMore</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A signal handler would be, for instance: bool on_read_more(const char* file_contents, goffset file_size);. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abb3b1f0b8e19505b34ae084c518d20fc"></a><!-- doxytag: member="Gio::File::File" ref="abb3b1f0b8e19505b34ae084c518d20fc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1File.html#abb3b1f0b8e19505b34ae084c518d20fc">Gio::File::File</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>You should derive from this class to use it. </p>

</div>
</div>
<a class="anchor" id="af17e8c7b30baa13aaa5d58ef4d56e383"></a><!-- doxytag: member="Gio::File::~File" ref="af17e8c7b30baa13aaa5d58ef4d56e383" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGio_1_1File.html#af17e8c7b30baa13aaa5d58ef4d56e383">Gio::File::~File</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa9352e68c93431dd16b8ac587703772f"></a><!-- doxytag: member="Gio::File::add_interface" ref="aa9352e68c93431dd16b8ac587703772f" args="(GType gtype_implementer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classGio_1_1File.html#aa9352e68c93431dd16b8ac587703772f">Gio::File::add_interface</a> </td>
          <td>(</td>
          <td class="paramtype">GType&#160;</td>
          <td class="paramname"><em>gtype_implementer</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a91c93ee71eee738690cb551d11df9528"></a><!-- doxytag: member="Gio::File::append_to" ref="a91c93ee71eee738690cb551d11df9528" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; <a class="el" href="classGio_1_1File.html#a91c93ee71eee738690cb551d11df9528">Gio::File::append_to</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets an output stream for appending data to the file. </p>
<p>If the file doesn't already exist it is created.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_FILENAME. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8db337b93f3b9b9a6e163477391e6c89"></a><!-- doxytag: member="Gio::File::append_to" ref="a8db337b93f3b9b9a6e163477391e6c89" args="(FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; <a class="el" href="classGio_1_1File.html#a91c93ee71eee738690cb551d11df9528">Gio::File::append_to</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets an output stream for appending data to the file. </p>
<p>If the file doesn't already exist it is created.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_FILENAME. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e3dfb193e8f2ab69e24c4370de5335a"></a><!-- doxytag: member="Gio::File::append_to_async" ref="a1e3dfb193e8f2ab69e24c4370de5335a" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCreateFlags flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a1e3dfb193e8f2ab69e24c4370de5335a">Gio::File::append_to_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously opens the file for appending. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a91c93ee71eee738690cb551d11df9528" title="Gets an output stream for appending data to the file.">append_to()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#acb1f2d32055b8da274ea241c69487dc6" title="Finishes an asynchronous file append operation started with g_file_append_to_async().">append_to_finish()</a> to get the result of the operation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abff3163e9bf8d8208cd0c0e568b777de"></a><!-- doxytag: member="Gio::File::append_to_async" ref="abff3163e9bf8d8208cd0c0e568b777de" args="(const SlotAsyncReady &amp;slot, FileCreateFlags flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a1e3dfb193e8f2ab69e24c4370de5335a">Gio::File::append_to_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously opens the file for appending. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a91c93ee71eee738690cb551d11df9528" title="Gets an output stream for appending data to the file.">append_to()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#acb1f2d32055b8da274ea241c69487dc6" title="Finishes an asynchronous file append operation started with g_file_append_to_async().">append_to_finish()</a> to get the result of the operation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb1f2d32055b8da274ea241c69487dc6"></a><!-- doxytag: member="Gio::File::append_to_finish" ref="acb1f2d32055b8da274ea241c69487dc6" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; <a class="el" href="classGio_1_1File.html#acb1f2d32055b8da274ea241c69487dc6">Gio::File::append_to_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous file append operation started with g_file_append_to_async(). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td><a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A valid <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="af9e906ed93069e6adb6d87dae158cad9"></a><!-- doxytag: member="Gio::File::copy" ref="af9e906ed93069e6adb6d87dae158cad9" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const SlotFileProgress &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCopyFlags flags=FILE_COPY_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9">Gio::File::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the file source to the location specified by destination. </p>
<p>Can not handle recursive copies of directories. If the flag FILE_COPY_OVERWRITE is specified an already existing destination file is overwritten. If the flag FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks will be copied as symlinks, otherwise the target of the source symlink will be copied.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>The operation can be monitored via the <em>slot</em> callback.</p>
<p>If the source file does not exist then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown, independent on the status of the destination.</p>
<p>If FILE_COPY_OVERWRITE is not specified and the target exists, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with EXISTS will be thrown.</p>
<p>If trying to overwrite a file over a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown. If trying to overwrite a directory with a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WOULD_MERGE will be thrown.</p>
<p>If the source is a directory and the target does not exist, or FILE_COPY_OVERWRITE is specified and the target is a file, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WOULD_RECURSE will be thrown.</p>
<p>If you are interested in copying the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> object itself (not the on-disk file), see <a class="el" href="classGio_1_1File.html#a9ea238062cdc317ae982ffae5c226c9b" title="Duplicates a File handle.">File::dup()</a>. </p>

</div>
</div>
<a class="anchor" id="a1d8159b5b377db174b376b3c09deb7c1"></a><!-- doxytag: member="Gio::File::copy" ref="a1d8159b5b377db174b376b3c09deb7c1" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const SlotFileProgress &amp;slot, FileCopyFlags flags=FILE_COPY_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9">Gio::File::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the file source to the location specified by destination. </p>
<p>Can not handle recursive copies of directories. If the flag FILE_COPY_OVERWRITE is specified an already existing destination file is overwritten. If the flag FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks will be copied as symlinks, otherwise the target of the source symlink will be copied.</p>
<p>The operation can be monitored via the <em>slot</em> callback.</p>
<p>If the source file does not exist then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown, independent on the status of the destination.</p>
<p>If FILE_COPY_OVERWRITE is not specified and the target exists, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with EXISTS will be thrown.</p>
<p>If trying to overwrite a file over a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown. If trying to overwrite a directory with a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WOULD_MERGE will be thrown.</p>
<p>If the source is a directory and the target does not exist, or FILE_COPY_OVERWRITE is specified and the target is a file, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WOULD_RECURSE will be thrown.</p>
<p>If you are interested in copying the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> object itself (not the on-disk file), see <a class="el" href="classGio_1_1File.html#a9ea238062cdc317ae982ffae5c226c9b" title="Duplicates a File handle.">File::dup()</a>. </p>

</div>
</div>
<a class="anchor" id="a7a6b45bed32567031bc7b48273ad4079"></a><!-- doxytag: member="Gio::File::copy" ref="a7a6b45bed32567031bc7b48273ad4079" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, FileCopyFlags flags=FILE_COPY_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9">Gio::File::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the file source to the location specified by destination. </p>
<p>Can not handle recursive copies of directories. If the flag FILE_COPY_OVERWRITE is specified an already existing destination file is overwritten. If the flag FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks will be copied as symlinks, otherwise the target of the source symlink will be copied.</p>
<p>If the source file does not exist then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown, independent on the status of the destination.</p>
<p>If FILE_COPY_OVERWRITE is not specified and the target exists, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with EXISTS will be thrown.</p>
<p>If trying to overwrite a file over a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown. If trying to overwrite a directory with a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WOULD_MERGE will be thrown.</p>
<p>If the source is a directory and the target does not exist, or FILE_COPY_OVERWRITE is specified and the target is a file, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WOULD_RECURSE will be thrown.</p>
<p>If you are interested in copying the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> object itself (not the on-disk file), see <a class="el" href="classGio_1_1File.html#a9ea238062cdc317ae982ffae5c226c9b" title="Duplicates a File handle.">File::dup()</a>. </p>

</div>
</div>
<a class="anchor" id="a1785b7a4780d5d4ba5ae651350e34398"></a><!-- doxytag: member="Gio::File::copy_async" ref="a1785b7a4780d5d4ba5ae651350e34398" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const SlotFileProgress &amp;slot_progress, const SlotAsyncReady &amp;slot_ready, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCopyFlags flags=FILE_COPY_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a1785b7a4780d5d4ba5ae651350e34398">Gio::File::copy_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the file to the location specified by <em>destination</em> asynchronously. </p>
<p>For details of the behaviour, see <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination.">copy()</a>.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a68294636a2d649c9de53332faee02cf6" title="Finishes copying the file started with g_file_copy_async().">copy_finish()</a> to get the result of the operation.</p>
<p>The function specified by <em>slot_progress</em> will be called just like in <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination.">copy()</a>, however the callback will run in the main loop, not in the thread that is doing the I/O operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Destination <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> </td></tr>
    <tr><td class="paramname">slot_progress</td><td>The callback slot to be called with progress information </td></tr>
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td class="paramname">flags</td><td>Set of FileCopyFlags </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b8ae7393c73a9a1d383a82d61f4ac30"></a><!-- doxytag: member="Gio::File::copy_async" ref="a5b8ae7393c73a9a1d383a82d61f4ac30" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const SlotAsyncReady &amp;slot_ready, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCopyFlags flags=FILE_COPY_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a1785b7a4780d5d4ba5ae651350e34398">Gio::File::copy_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the file to the location specified by <em>destination</em> asynchronously. </p>
<p>For details of the behaviour, see <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination.">copy()</a>.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a68294636a2d649c9de53332faee02cf6" title="Finishes copying the file started with g_file_copy_async().">copy_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Destination <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> </td></tr>
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td class="paramname">flags</td><td>Set of FileCopyFlags </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2b1a85f29bbbe15998c090b3794cbf5"></a><!-- doxytag: member="Gio::File::copy_async" ref="ac2b1a85f29bbbe15998c090b3794cbf5" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const SlotFileProgress &amp;slot_progress, const SlotAsyncReady &amp;slot_ready, FileCopyFlags flags=FILE_COPY_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a1785b7a4780d5d4ba5ae651350e34398">Gio::File::copy_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the file to the location specified by <em>destination</em> asynchronously. </p>
<p>For details of the behaviour, see <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination.">copy()</a>.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a68294636a2d649c9de53332faee02cf6" title="Finishes copying the file started with g_file_copy_async().">copy_finish()</a> to get the result of the operation.</p>
<p>The function specified by <em>slot_progress</em> will be called just like in <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination.">copy()</a>, however the callback will run in the main loop, not in the thread that is doing the I/O operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Destination <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> </td></tr>
    <tr><td class="paramname">slot_progress</td><td>The callback slot to be called with progress information </td></tr>
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">flags</td><td>Set of FileCopyFlags </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad538a383b8761d04bd36ed1aa1071e50"></a><!-- doxytag: member="Gio::File::copy_async" ref="ad538a383b8761d04bd36ed1aa1071e50" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const SlotAsyncReady &amp;slot_ready, FileCopyFlags flags=FILE_COPY_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a1785b7a4780d5d4ba5ae651350e34398">Gio::File::copy_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the file to the location specified by <em>destination</em> asynchronously. </p>
<p>For details of the behaviour, see <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination.">copy()</a>.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a68294636a2d649c9de53332faee02cf6" title="Finishes copying the file started with g_file_copy_async().">copy_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Destination <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> </td></tr>
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">flags</td><td>Set of FileCopyFlags </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90726dcf94248d2fddf2e4c8584b7bf0"></a><!-- doxytag: member="Gio::File::copy_attributes" ref="a90726dcf94248d2fddf2e4c8584b7bf0" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCopyFlags flags=FILE_COPY_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a90726dcf94248d2fddf2e4c8584b7bf0">Gio::File::copy_attributes</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the file attributes from <em>source</em> to <em>destination</em>. </p>
<p>Normally only a subset of the file attributes are copied, those that are copies in a normal file copy operation (which for instance does not include e.g. mtime). However if FILE_COPY_ALL_METADATA is specified in <em>flags</em>, then all the metadata that is possible to copy is copied.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>A <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> to copy attributes to. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the attributes were copied successfully, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a05c1101ede98028c9234486eb0434250"></a><!-- doxytag: member="Gio::File::copy_attributes" ref="a05c1101ede98028c9234486eb0434250" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, FileCopyFlags flags=FILE_COPY_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a90726dcf94248d2fddf2e4c8584b7bf0">Gio::File::copy_attributes</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the file attributes from <em>source</em> to <em>destination</em>. </p>
<p>Normally only a subset of the file attributes are copied, those that are copies in a normal file copy operation (which for instance does not include e.g. mtime). However if FILE_COPY_ALL_METADATA is specified in <em>flags</em>, then all the metadata that is possible to copy is copied.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>A <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> to copy attributes to. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the attributes were copied successfully, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a68294636a2d649c9de53332faee02cf6"></a><!-- doxytag: member="Gio::File::copy_finish" ref="a68294636a2d649c9de53332faee02cf6" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a68294636a2d649c9de53332faee02cf6">Gio::File::copy_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes copying the file started with g_file_copy_async(). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a86258e11b2884422819d051c3cfd07a2"></a><!-- doxytag: member="Gio::File::create_file" ref="a86258e11b2884422819d051c3cfd07a2" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; <a class="el" href="classGio_1_1File.html#a86258e11b2884422819d051c3cfd07a2">Gio::File::create_file</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new file and returns an output stream for writing to it. </p>
<p>The file must not already exist.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If a file with this name already exists a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with EXISTS will be thrown. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a> for the newly created file. </dd></dl>

</div>
</div>
<a class="anchor" id="a5cf2b17b953ccfefb1d13c39bd1be72c"></a><!-- doxytag: member="Gio::File::create_file" ref="a5cf2b17b953ccfefb1d13c39bd1be72c" args="(FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; <a class="el" href="classGio_1_1File.html#a86258e11b2884422819d051c3cfd07a2">Gio::File::create_file</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new file and returns an output stream for writing to it. </p>
<p>The file must not already exist.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>If a file with this name already exists a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with EXISTS will be thrown. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a> for the newly created file. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0c42446d37aa466173965b7db1a2053"></a><!-- doxytag: member="Gio::File::create_file_async" ref="ae0c42446d37aa466173965b7db1a2053" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCreateFlags flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#ae0c42446d37aa466173965b7db1a2053">Gio::File::create_file_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously creates a new file and returns an output stream for writing to it. </p>
<p>The file must not already exist. For more details, see <a class="el" href="classGio_1_1File.html#a86258e11b2884422819d051c3cfd07a2" title="Creates a new file and returns an output stream for writing to it.">create_file()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a622b9f7aeaebe2ac53df0574c9c4211a" title="Finishes an asynchronous file create operation started with g_file_create_async().">create_file_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3fe6ed015f3d2bb72aa7aceed8dc7ca1"></a><!-- doxytag: member="Gio::File::create_file_async" ref="a3fe6ed015f3d2bb72aa7aceed8dc7ca1" args="(const SlotAsyncReady &amp;slot, FileCreateFlags flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#ae0c42446d37aa466173965b7db1a2053">Gio::File::create_file_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously creates a new file and returns an output stream for writing to it. </p>
<p>The file must not already exist. For more details, see <a class="el" href="classGio_1_1File.html#a86258e11b2884422819d051c3cfd07a2" title="Creates a new file and returns an output stream for writing to it.">create_file()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a622b9f7aeaebe2ac53df0574c9c4211a" title="Finishes an asynchronous file create operation started with g_file_create_async().">create_file_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a622b9f7aeaebe2ac53df0574c9c4211a"></a><!-- doxytag: member="Gio::File::create_file_finish" ref="a622b9f7aeaebe2ac53df0574c9c4211a" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; <a class="el" href="classGio_1_1File.html#a622b9f7aeaebe2ac53df0574c9c4211a">Gio::File::create_file_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous file create operation started with g_file_create_async(). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="ad5ec69c5360219bccb794bab6a128e88"></a><!-- doxytag: member="Gio::File::create_file_readwrite" ref="ad5ec69c5360219bccb794bab6a128e88" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; <a class="el" href="classGio_1_1File.html#ad5ec69c5360219bccb794bab6a128e88">Gio::File::create_file_readwrite</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new file and returns a stream for reading and writing to it. </p>
<p>The file must not already exist.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If a file with this name already exists a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with EXISTS will be thrown. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a> for the newly created file. </dd></dl>

</div>
</div>
<a class="anchor" id="acf5673ceb9095405e458b5035b0986b4"></a><!-- doxytag: member="Gio::File::create_file_readwrite" ref="acf5673ceb9095405e458b5035b0986b4" args="(FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; <a class="el" href="classGio_1_1File.html#ad5ec69c5360219bccb794bab6a128e88">Gio::File::create_file_readwrite</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new file and returns a stream for reading and writing to it. </p>
<p>The file must not already exist.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>If a file with this name already exists a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with EXISTS will be thrown. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a> for the newly created file. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c27a2460468aab1d3c3665234c24a56"></a><!-- doxytag: member="Gio::File::create_file_readwrite_async" ref="a4c27a2460468aab1d3c3665234c24a56" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCreateFlags flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a4c27a2460468aab1d3c3665234c24a56">Gio::File::create_file_readwrite_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously creates a new file and returns a stream for reading and writing to it. </p>
<p>The file must not already exist.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ad5ec69c5360219bccb794bab6a128e88" title="Creates a new file and returns a stream for reading and writing to it.">create_file_readwrite()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ae75da0ef250a3b27c2811a5e70f58536" title="Finishes an asynchronous file create operation started with g_file_create_readwrite_async().">create_file_readwrite_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a5989cfdee54778de733a529c24607b"></a><!-- doxytag: member="Gio::File::create_file_readwrite_async" ref="a5a5989cfdee54778de733a529c24607b" args="(const SlotAsyncReady &amp;slot, FileCreateFlags flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a4c27a2460468aab1d3c3665234c24a56">Gio::File::create_file_readwrite_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously creates a new file and returns a stream for reading and writing to it. </p>
<p>The file must not already exist.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ad5ec69c5360219bccb794bab6a128e88" title="Creates a new file and returns a stream for reading and writing to it.">create_file_readwrite()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ae75da0ef250a3b27c2811a5e70f58536" title="Finishes an asynchronous file create operation started with g_file_create_readwrite_async().">create_file_readwrite_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae75da0ef250a3b27c2811a5e70f58536"></a><!-- doxytag: member="Gio::File::create_file_readwrite_finish" ref="ae75da0ef250a3b27c2811a5e70f58536" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; <a class="el" href="classGio_1_1File.html#ae75da0ef250a3b27c2811a5e70f58536">Gio::File::create_file_readwrite_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous file create operation started with g_file_create_readwrite_async(). </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000025">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file.">FileIOStream</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="ab311a1c606b3907865fc8aecd4691de8"></a><!-- doxytag: member="Gio::File::create_for_commandline_arg" ref="ab311a1c606b3907865fc8aecd4691de8" args="(const std::string &amp;arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; <a class="el" href="classGio_1_1File.html#ab311a1c606b3907865fc8aecd4691de8">Gio::File::create_for_commandline_arg</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> for a given argument from the command line. </p>
<p>The value of <em>arg</em> can be either a URI, an absolute path or a relative path resolved relative to the current working directory. This operation never fails, but the returned object might not support any I/O operation if arg points to a malformed path.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>A string containing a relative or absolute path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new instantiation of an appropriate <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> class. </dd></dl>

</div>
</div>
<a class="anchor" id="a7532baa6ce71fe27cfd1e9bba91a3536"></a><!-- doxytag: member="Gio::File::create_for_parse_name" ref="a7532baa6ce71fe27cfd1e9bba91a3536" args="(const Glib::ustring &amp;parse_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; <a class="el" href="classGio_1_1File.html#a7532baa6ce71fe27cfd1e9bba91a3536">Gio::File::create_for_parse_name</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>parse_name</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b1a4553b226689d50b9525488223e25"></a><!-- doxytag: member="Gio::File::create_for_path" ref="a1b1a4553b226689d50b9525488223e25" args="(const std::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; <a class="el" href="classGio_1_1File.html#a1b1a4553b226689d50b9525488223e25">Gio::File::create_for_path</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> for a given path. </p>
<p>This operation never fails, but the returned object might not support any I/O operation if path is malformed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A string containing a relative or absolute path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new instantiation of an appropriate <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> class. </dd></dl>

</div>
</div>
<a class="anchor" id="a412b6b55f37f69bd4fb8fbd24d4967be"></a><!-- doxytag: member="Gio::File::create_for_uri" ref="a412b6b55f37f69bd4fb8fbd24d4967be" args="(const std::string &amp;uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; <a class="el" href="classGio_1_1File.html#a412b6b55f37f69bd4fb8fbd24d4967be">Gio::File::create_for_uri</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> for a given URI. </p>
<p>This operation never fails, but the returned object might not support any I/O operation if path is malformed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>A string containing a URI. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new instantiation of an appropriate <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a> class. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ea238062cdc317ae982ffae5c226c9b"></a><!-- doxytag: member="Gio::File::dup" ref="a9ea238062cdc317ae982ffae5c226c9b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; <a class="el" href="classGio_1_1File.html#a9ea238062cdc317ae982ffae5c226c9b">Gio::File::dup</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicates a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> handle. </p>
<p>This operation does not duplicate the actual file or directory represented by the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>; see g_file_copy() if attempting to copy a file.</p>
<p>This call does no blocking i/o. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> that is a duplicate of the given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a8223e3b661f03c7a60ac0f003b916e"></a><!-- doxytag: member="Gio::File::eject_mountable" ref="a8a8223e3b661f03c7a60ac0f003b916e" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a8a8223e3b661f03c7a60ac0f003b916e">Gio::File::eject_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f" title="Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation().">eject_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8422a939a634d2248ef6d8658f0fdad"></a><!-- doxytag: member="Gio::File::eject_mountable" ref="ad8422a939a634d2248ef6d8658f0fdad" args="(const SlotAsyncReady &amp;slot, MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a8a8223e3b661f03c7a60ac0f003b916e">Gio::File::eject_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f" title="Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation().">eject_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb28fd505cab23a82c68ff00445b12e7"></a><!-- doxytag: member="Gio::File::eject_mountable" ref="aeb28fd505cab23a82c68ff00445b12e7" args="(MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a8a8223e3b661f03c7a60ac0f003b916e">Gio::File::eject_mountable</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c103886296fd1ea1107906deebec8a5"></a><!-- doxytag: member="Gio::File::eject_mountable" ref="a1c103886296fd1ea1107906deebec8a5" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const Glib::RefPtr&lt; MountOperation &gt; &amp;mount_operation, MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a8a8223e3b661f03c7a60ac0f003b916e">Gio::File::eject_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f" title="Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation().">eject_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations.">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6c75952828023d27d109a3a23fafc00"></a><!-- doxytag: member="Gio::File::eject_mountable" ref="ab6c75952828023d27d109a3a23fafc00" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; MountOperation &gt; &amp;mount_operation, MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a8a8223e3b661f03c7a60ac0f003b916e">Gio::File::eject_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f" title="Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation().">eject_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations.">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7aea22f6cb30b3f2be43682ddd543d9"></a><!-- doxytag: member="Gio::File::eject_mountable" ref="ab7aea22f6cb30b3f2be43682ddd543d9" args="(const Glib::RefPtr&lt; MountOperation &gt; &amp;mount_operation, MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a8a8223e3b661f03c7a60ac0f003b916e">Gio::File::eject_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations.">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a5124de7c55e9dc5e85ffcb9d3dd14f"></a><!-- doxytag: member="Gio::File::eject_mountable_finish" ref="a6a5124de7c55e9dc5e85ffcb9d3dd14f" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f">Gio::File::eject_mountable_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation(). </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000030">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>file</em> was ejected successfully. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a68c3afcddc0d4860aa2afb4bf715bb20"></a><!-- doxytag: member="Gio::File::enumerate_children" ref="a68c3afcddc0d4860aa2afb4bf715bb20" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;attributes=&quot;*&quot;, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a>&gt; <a class="el" href="classGio_1_1File.html#a68c3afcddc0d4860aa2afb4bf715bb20">Gio::File::enumerate_children</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the requested information about the files in a directory. </p>
<p>The result is a <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines.">FileEnumerator</a> object that will give out <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> objects for all the files in the directory.</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if its not possible to read a particular requested attribute from a file, it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "standard::*" means all attributes in the standard namespace. An example attribute query be "standard::*,owner::user". The standard attributes are availible as defines, like FILE_ATTRIBUTE_STANDARD_NAME.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. If the file is not a directory, a <a class="el" href="classGlib_1_1FileError.html" title="Exception class for file-related errors.">Glib::FileError</a> with NOTDIR will be thrown. Other errors are possible too.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines.">FileEnumerator</a> if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0e293d607499b223f4892fb290ab2d6"></a><!-- doxytag: member="Gio::File::enumerate_children" ref="ac0e293d607499b223f4892fb290ab2d6" args="(const std::string &amp;attributes=&quot;*&quot;, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a>&gt; <a class="el" href="classGio_1_1File.html#a68c3afcddc0d4860aa2afb4bf715bb20">Gio::File::enumerate_children</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the requested information about the files in a directory. </p>
<p>The result is a <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines.">FileEnumerator</a> object that will give out <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> objects for all the files in the directory.</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if its not possible to read a particular requested attribute from a file, it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "standard::*" means all attributes in the standard namespace. An example attribute query be "standard::*,owner::user". The standard attributes are availible as defines, like FILE_ATTRIBUTE_STANDARD_NAME.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. If the file is not a directory, a <a class="el" href="classGlib_1_1FileError.html" title="Exception class for file-related errors.">Glib::FileError</a> with NOTDIR will be thrown. Other errors are possible too.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines.">FileEnumerator</a> if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ead7237b7057d9b15cf5f3065988131"></a><!-- doxytag: member="Gio::File::enumerate_children_async" ref="a1ead7237b7057d9b15cf5f3065988131" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;attributes=&quot;*&quot;, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a1ead7237b7057d9b15cf5f3065988131">Gio::File::enumerate_children_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously gets the requested information about the files in a directory. </p>
<p>The result is a GFileEnumerator object that will give out GFileInfo objects for all the files in the directory.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a68c3afcddc0d4860aa2afb4bf715bb20" title="Gets the requested information about the files in a directory.">enumerate_children()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a617a2950448788e68df128c58e068a14" title="Finishes an async enumerate children operation.">enumerate_children_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b5470cf1c97754a12169201665f1202"></a><!-- doxytag: member="Gio::File::enumerate_children_async" ref="a5b5470cf1c97754a12169201665f1202" args="(const SlotAsyncReady &amp;slot, const std::string &amp;attributes=&quot;*&quot;, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a1ead7237b7057d9b15cf5f3065988131">Gio::File::enumerate_children_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously gets the requested information about the files in a directory. </p>
<p>The result is a GFileEnumerator object that will give out GFileInfo objects for all the files in the directory.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a68c3afcddc0d4860aa2afb4bf715bb20" title="Gets the requested information about the files in a directory.">enumerate_children()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a617a2950448788e68df128c58e068a14" title="Finishes an async enumerate children operation.">enumerate_children_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a617a2950448788e68df128c58e068a14"></a><!-- doxytag: member="Gio::File::enumerate_children_finish" ref="a617a2950448788e68df128c58e068a14" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a>&gt; <a class="el" href="classGio_1_1File.html#a617a2950448788e68df128c58e068a14">Gio::File::enumerate_children_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an async enumerate children operation. </p>
<p>See g_file_enumerate_children_async(). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines.">FileEnumerator</a> or <code>0</code> if an error occurred. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a8877115c870ea8f58b03d1d3c01a83e4"></a><!-- doxytag: member="Gio::File::equal" ref="a8877115c870ea8f58b03d1d3c01a83e4" args="(const Glib::RefPtr&lt; const File &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a8877115c870ea8f58b03d1d3c01a83e4">Gio::File::equal</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks equality of two given Files. </p>
<p>Note that two Files that differ can still refer to the same file on the filesystem due to various forms of filename aliasing.</p>
<p>This call does no blocking i/o. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file2</td><td>The second <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <em>file1</em> and <em>file2</em> are equal. <code>false</code> if either is not a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a45b881926b8d58c49d3baa1f51f2ee5d"></a><!-- doxytag: member="Gio::File::find_enclosing_mount" ref="a45b881926b8d58c49d3baa1f51f2ee5d" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Mount.html">Mount</a>&gt; <a class="el" href="classGio_1_1File.html#a45b881926b8d58c49d3baa1f51f2ee5d">Gio::File::find_enclosing_mount</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts.">Mount</a> for the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </p>
<p>If the FileIface for <em>file</em> does not have a mount (e.g. possibly a remote share), a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with NOT_FOUND and <code>0</code> will be returned.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts.">Mount</a> where the <em>file</em> is located or <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a6eb675267c7ea1c2a0d40e2e754d8333"></a><!-- doxytag: member="Gio::File::find_enclosing_mount" ref="a6eb675267c7ea1c2a0d40e2e754d8333" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Mount.html">Mount</a>&gt; <a class="el" href="classGio_1_1File.html#a45b881926b8d58c49d3baa1f51f2ee5d">Gio::File::find_enclosing_mount</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts.">Mount</a> for the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </p>
<p>If the FileIface for the file does not have a mount (e.g. possibly a remote share), an <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> wtih NOT_FOUND will be thrown and an empty RefPtr will be returned.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts.">Mount</a> where the file is located. </dd></dl>

</div>
</div>
<a class="anchor" id="a78c95d4fa47157f7757b686677dec018"></a><!-- doxytag: member="Gio::File::find_enclosing_mount_async" ref="a78c95d4fa47157f7757b686677dec018" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a78c95d4fa47157f7757b686677dec018">Gio::File::find_enclosing_mount_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously gets the mount for the file. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333" title="Gets a Mount for the File.">find_enclosing_mount()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#aa12e6222d81179937cdc366f4d315433" title="Finishes an asynchronous find mount request.">find_enclosing_mount_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67458be57c5687e7469bc26e2594f4be"></a><!-- doxytag: member="Gio::File::find_enclosing_mount_async" ref="a67458be57c5687e7469bc26e2594f4be" args="(const SlotAsyncReady &amp;slot, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a78c95d4fa47157f7757b686677dec018">Gio::File::find_enclosing_mount_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously gets the mount for the file. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333" title="Gets a Mount for the File.">find_enclosing_mount()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#aa12e6222d81179937cdc366f4d315433" title="Finishes an asynchronous find mount request.">find_enclosing_mount_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa12e6222d81179937cdc366f4d315433"></a><!-- doxytag: member="Gio::File::find_enclosing_mount_finish" ref="aa12e6222d81179937cdc366f4d315433" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Mount.html">Mount</a>&gt; <a class="el" href="classGio_1_1File.html#aa12e6222d81179937cdc366f4d315433">Gio::File::find_enclosing_mount_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous find mount request. </p>
<p>See g_file_find_enclosing_mount_async(). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts.">Mount</a> for given <em>file</em> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="ac731bed45bb7fcfd411eb69c49d3b883"></a><!-- doxytag: member="Gio::File::get_basename" ref="ac731bed45bb7fcfd411eb69c49d3b883" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> <a class="el" href="classGio_1_1File.html#ac731bed45bb7fcfd411eb69c49d3b883">Gio::File::get_basename</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the base name (the last component of the path) for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </p>
<p>If called for the top level of a system (such as the filesystem root or a uri like sftp://host/) it will return a single directory separator (and on Windows, possibly a drive letter).</p>
<p>The base name is a byte string (*not* UTF-8). It has no defined encoding or rules other than it may not contain zero bytes. If you want to use filenames in a user interface you should use the display name that you can get by requesting the FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with g_file_query_info().</p>
<p>This call does no blocking i/o. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>String containing the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>'s base name, or <code>0</code> if given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> is invalid. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a53c533d6bbeaaadd1b5592cf1e5ef93c"></a><!-- doxytag: member="Gio::File::get_child" ref="a53c533d6bbeaaadd1b5592cf1e5ef93c" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; <a class="el" href="classGio_1_1File.html#a53c533d6bbeaaadd1b5592cf1e5ef93c">Gio::File::get_child</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a child of <em>file</em> with basename equal to <em>name</em>. </p>
<p>Note that the file with that specific name might not exist, but you can still have a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> that points to it. You can use this for instance to create that file.</p>
<p>This call does no blocking i/o. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>String containing the child's basename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> to a child specified by <em>name</em>. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a479cfd632af30b29e125f904f809ed71"></a><!-- doxytag: member="Gio::File::get_child_for_display_name" ref="a479cfd632af30b29e125f904f809ed71" args="(const Glib::ustring &amp;display_name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; <a class="el" href="classGio_1_1File.html#a479cfd632af30b29e125f904f809ed71">Gio::File::get_child_for_display_name</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>display_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the child of <em>file</em> for a given <em>display_name</em> (i.e. a UTF8 version of the name). </p>
<p>If this function fails, it returns <code>0</code> and <em>error</em> will be set. This is very useful when constructing a GFile for a new file and the user entered the filename in the user interface, for instance when you select a directory and type a filename in the file selector.</p>
<p>This call does no blocking i/o. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">display_name</td><td>String to a possible child. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> to the specified child, or <code>0</code> if the display name couldn't be converted. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="af39bbd5013b2dd675911df322e12ff94"></a><!-- doxytag: member="Gio::File::get_parent" ref="af39bbd5013b2dd675911df322e12ff94" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; <a class="el" href="classGio_1_1File.html#af39bbd5013b2dd675911df322e12ff94">Gio::File::get_parent</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the parent directory for the <em>file</em>. </p>
<p>If the <em>file</em> represents the root directory of the file system, then <code>0</code> will be returned.</p>
<p>This call does no blocking i/o. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> structure to the parent of the given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> or <code>0</code> if there is no parent. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="aea4a78163e3085a35cbaacde9a3a7628"></a><!-- doxytag: member="Gio::File::get_parse_name" ref="aea4a78163e3085a35cbaacde9a3a7628" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> <a class="el" href="classGio_1_1File.html#aea4a78163e3085a35cbaacde9a3a7628">Gio::File::get_parse_name</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the parse name of the <em>file</em>. </p>
<p>A parse name is a UTF-8 string that describes the file such that one can get the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> back using g_file_parse_name().</p>
<p>This is generally used to show the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> as a nice full-pathname kind of string in a user interface, like in a location entry.</p>
<p>For local files with names that can safely be converted to UTF8 the pathname is used, otherwise the IRI is used (a form of URI that allows UTF8 characters unescaped).</p>
<p>This call does no blocking i/o. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string containing the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>'s parse name. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b3edc7946b681b6db2cdcdad08d2b00"></a><!-- doxytag: member="Gio::File::get_path" ref="a7b3edc7946b681b6db2cdcdad08d2b00" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> <a class="el" href="classGio_1_1File.html#a7b3edc7946b681b6db2cdcdad08d2b00">Gio::File::get_path</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the local pathname for <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>, if one exists. </p>
<p>This call does no blocking i/o. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>String containing the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>'s path, or <code>0</code> if no such path exists. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a464248111fa2bc5df89c620354eb99bb"></a><!-- doxytag: member="Gio::File::get_relative_path" ref="a464248111fa2bc5df89c620354eb99bb" args="(const Glib::RefPtr&lt; const File &gt; &amp;descendant) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> <a class="el" href="classGio_1_1File.html#a464248111fa2bc5df89c620354eb99bb">Gio::File::get_relative_path</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>descendant</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the path for <em>descendant</em> relative to <em>parent</em>. </p>
<p>This call does no blocking i/o. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">descendant</td><td>Input <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>String with the relative path from <em>descendant</em> to <em>parent</em>, or <code>0</code> if <em>descendant</em> doesn't have <em>parent</em> as prefix. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d1313e4a4eb5de034b693ec1cc9fba0"></a><!-- doxytag: member="Gio::File::get_uri" ref="a2d1313e4a4eb5de034b693ec1cc9fba0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> <a class="el" href="classGio_1_1File.html#a2d1313e4a4eb5de034b693ec1cc9fba0">Gio::File::get_uri</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the URI for the <em>file</em>. </p>
<p>This call does no blocking i/o. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string containing the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>'s URI. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="aeecec6962f955bd72ac5595be37db7a4"></a><!-- doxytag: member="Gio::File::get_uri_scheme" ref="aeecec6962f955bd72ac5595be37db7a4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> <a class="el" href="classGio_1_1File.html#aeecec6962f955bd72ac5595be37db7a4">Gio::File::get_uri_scheme</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the URI scheme for a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </p>
<p>RFC 3986 decodes the scheme as:</p>
<p>URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]</p>
<p>Common schemes include "file", "http", "ftp", etc.</p>
<p>This call does no blocking i/o. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string containing the URI scheme for the given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a96552cfbaf2e5fa3659a1568db8cca91"></a><!-- doxytag: member="Gio::File::gobj" ref="a96552cfbaf2e5fa3659a1568db8cca91" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GFile* <a class="el" href="classGio_1_1File.html#a96552cfbaf2e5fa3659a1568db8cca91">Gio::File::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1Interface.html#a969e9396f75132a9577428f4fa932d42">Glib::Interface</a>.</p>

</div>
</div>
<a class="anchor" id="a5437bc648d8b73451e8bee0bc902cfc0"></a><!-- doxytag: member="Gio::File::gobj" ref="a5437bc648d8b73451e8bee0bc902cfc0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GFile* <a class="el" href="classGio_1_1File.html#a96552cfbaf2e5fa3659a1568db8cca91">Gio::File::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1Interface.html#a70a443071a69d3372c2cdd7128a91ed1">Glib::Interface</a>.</p>

</div>
</div>
<a class="anchor" id="ae0b0d16b849b2f92699ad57ee7c935d9"></a><!-- doxytag: member="Gio::File::has_parent" ref="ae0b0d16b849b2f92699ad57ee7c935d9" args="(const Glib::RefPtr&lt; File &gt; &amp;parent) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#ae0b0d16b849b2f92699ad57ee7c935d9">Gio::File::has_parent</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if <em>file</em> has a parent, and optionally, if it is <em>parent</em>. </p>
<p>If <em>parent</em> is <code>0</code> then this function returns <code>true</code> if <em>file</em> has any parent at all. If <em>parent</em> is non-<code>0</code> then <code>true</code> is only returned if <em>file</em> is a child of <em>parent</em>.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000022">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent to check for, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <em>file</em> is a child of <em>parent</em> (or any parent in the case that <em>parent</em> is <code>0</code>). </dd></dl>

</div>
</div>
<a class="anchor" id="aa1daee0498c403e83ac509e6157edd1c"></a><!-- doxytag: member="Gio::File::has_parent" ref="aa1daee0498c403e83ac509e6157edd1c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#ae0b0d16b849b2f92699ad57ee7c935d9">Gio::File::has_parent</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if the file has any parent at all. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the file is a child of any parent.</dd></dl>

</div>
</div>
<a class="anchor" id="a4c40ec88dfc4333f19e939d26a1e0332"></a><!-- doxytag: member="Gio::File::has_prefix" ref="a4c40ec88dfc4333f19e939d26a1e0332" args="(const Glib::RefPtr&lt; const File &gt; &amp;prefix) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a4c40ec88dfc4333f19e939d26a1e0332">Gio::File::has_prefix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether <em>file</em> has the prefix specified by <em>prefix</em>. </p>
<p>In other word, if the names of initial elements of <em>files</em> pathname match <em>prefix</em>. Only full pathname elements are matched, so a path like /foo is not considered a prefix of /foobar, only of /foo/bar.</p>
<p>This call does no i/o, as it works purely on names. As such it can sometimes return <code>false</code> even if <em>file</em> is inside a <em>prefix</em> (from a filesystem point of view), because the prefix of <em>file</em> is an alias of <em>prefix</em>.</p>
<p>Virtual: prefix_matches </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Input <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>files's</em> parent, grandparent, etc is <em>prefix</em>. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a90d71529e5b51b9ff73914eaf90be0f1"></a><!-- doxytag: member="Gio::File::has_uri_scheme" ref="a90d71529e5b51b9ff73914eaf90be0f1" args="(const std::string &amp;uri_scheme) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a90d71529e5b51b9ff73914eaf90be0f1">Gio::File::has_uri_scheme</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>uri_scheme</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks to see if a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> has a given URI scheme. </p>
<p>This call does no blocking i/o. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri_scheme</td><td>A string containing a URI scheme. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>'s backend supports the given URI scheme, <code>false</code> if URI scheme is <code>0</code>, not supported, or <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a0320bac72ecc9ced1f894f1af696856f"></a><!-- doxytag: member="Gio::File::hash" ref="a0320bac72ecc9ced1f894f1af696856f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint <a class="el" href="classGio_1_1File.html#a0320bac72ecc9ced1f894f1af696856f">Gio::File::hash</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a hash value for a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </p>
<p>This call does no blocking i/o.</p>
<p>Virtual: hash </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>#gconstpointer to a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if <em>file</em> is not a valid <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>, otherwise an integer that can be used as hash value for the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. This function is intended for easily hashing a <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> to add to a HashTable or similar data structure. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa3b910bc9f240d4ebd0efc70979f163"></a><!-- doxytag: member="Gio::File::is_native" ref="aaa3b910bc9f240d4ebd0efc70979f163" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#aaa3b910bc9f240d4ebd0efc70979f163">Gio::File::is_native</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks to see if a file is native to the platform. </p>
<p>A native file s one expressed in the platform-native filename format, e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local, as it might be on a locally mounted remote filesystem.</p>
<p>On some systems non-native files may be available using the native filesystem via a userspace filesystem (FUSE), in these cases this call will return <code>false</code>, but g_file_get_path() will still return a native path.</p>
<p>This call does no blocking i/o. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if file is native. </dd></dl>

</div>
</div>
<a class="anchor" id="ac53be228d732b34e062a2a57814cdf15"></a><!-- doxytag: member="Gio::File::load_contents" ref="ac53be228d732b34e062a2a57814cdf15" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, char *&amp;contents, gsize &amp;length, std::string &amp;etag_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15">Gio::File::load_contents</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads the content of the file into memory, returning the size of the data. </p>
<p>The data is always zero terminated, but this is not included in the resultant <em>length</em>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> exception with CANCELLED will be returned.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A cancellable object. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
    <tr><td class="paramname">etag_out</td><td>A location to place the current entity tag for the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada7c826a417f88b405244c8dc39ae1ef"></a><!-- doxytag: member="Gio::File::load_contents" ref="ada7c826a417f88b405244c8dc39ae1ef" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, char *&amp;contents, gsize &amp;length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15">Gio::File::load_contents</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads the content of the file into memory, returning the size of the data. </p>
<p>The data is always zero terminated, but this is not included in the resultant <em>length</em>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> exception with CANCELLED will be returned.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A cancellable object. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000034">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a77f7781b0ba65bc4e7e613b80b353fd7"></a><!-- doxytag: member="Gio::File::load_contents" ref="a77f7781b0ba65bc4e7e613b80b353fd7" args="(char *&amp;contents, gsize &amp;length, std::string &amp;etag_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15">Gio::File::load_contents</a> </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads the content of the file into memory, returning the size of the data. </p>
<p>The data is always zero terminated, but this is not included in the resultant <em>length</em>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
    <tr><td class="paramname">etag_out</td><td>A location to place the current entity tag for the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40f3ce7cf905144bac7218f9988d2d35"></a><!-- doxytag: member="Gio::File::load_contents" ref="a40f3ce7cf905144bac7218f9988d2d35" args="(char *&amp;contents, gsize &amp;length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15">Gio::File::load_contents</a> </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads the content of the file into memory, returning the size of the data. </p>
<p>The data is always zero terminated, but this is not included in the resultant <em>length</em>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000035">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ad0e02ebffbaa13036e4636d2118f71a0"></a><!-- doxytag: member="Gio::File::load_contents_async" ref="ad0e02ebffbaa13036e4636d2118f71a0" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#ad0e02ebffbaa13036e4636d2118f71a0">Gio::File::load_contents_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous load of the file's contents. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15" title="Loads the content of the file into memory, returning the size of the data.">load_contents()</a> which is the synchronous version of this call.</p>
<p>When the load operation has completed, the <em>slot</em> will be called. To finish the operation, call <a class="el" href="classGio_1_1File.html#a5fd15277ab90bcc57db088be04cac457" title="Finishes an asynchronous load of the file&#39;s contents.">load_contents_finish()</a> with the <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> provided to the <em>slot</em>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6af7ec98d5543bce07b917b65d7276ce"></a><!-- doxytag: member="Gio::File::load_contents_async" ref="a6af7ec98d5543bce07b917b65d7276ce" args="(const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#ad0e02ebffbaa13036e4636d2118f71a0">Gio::File::load_contents_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous load of the file's contents. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15" title="Loads the content of the file into memory, returning the size of the data.">load_contents()</a> which is the synchronous version of this call.</p>
<p>When the load operation has completed, the <em>slot</em> will be called. To finish the operation, call <a class="el" href="classGio_1_1File.html#a5fd15277ab90bcc57db088be04cac457" title="Finishes an asynchronous load of the file&#39;s contents.">load_contents_finish()</a> with the <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> provided to the <em>slot</em>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5fd15277ab90bcc57db088be04cac457"></a><!-- doxytag: member="Gio::File::load_contents_finish" ref="a5fd15277ab90bcc57db088be04cac457" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, char *&amp;contents, gsize &amp;length, std::string &amp;etag_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a5fd15277ab90bcc57db088be04cac457">Gio::File::load_contents_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous load of the <em>file's</em> contents. </p>
<p>The contents are placed in <em>contents</em>, and <em>length</em> is set to the size of the <em>contents</em> string. If <em>etag_out</em> is present, it will be set to the new entity tag for the <em>file</em>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
    <tr><td class="paramname">etag_out</td><td>A location to place the current entity tag for the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the load was successful. If <code>false</code> and <em>error</em> is present, it will be set appropriately. </dd></dl>

</div>
</div>
<a class="anchor" id="aee93c7e24e8391615f9f263584fb02bd"></a><!-- doxytag: member="Gio::File::load_contents_finish" ref="aee93c7e24e8391615f9f263584fb02bd" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, char *&amp;contents, gsize &amp;length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a5fd15277ab90bcc57db088be04cac457">Gio::File::load_contents_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous load of the <em>file's</em> contents. </p>
<p>The contents are placed in <em>contents</em>, and <em>length</em> is set to the size of the <em>contents</em> string. If <em>etag_out</em> is present, it will be set to the new entity tag for the <em>file</em>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the load was successful. If <code>false</code> and <em>error</em> is present, it will be set appropriately. </dd></dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000036">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a0e8d95fcdf7c2aa38f54e90a22d3ab6f"></a><!-- doxytag: member="Gio::File::load_partial_contents_async" ref="a0e8d95fcdf7c2aa38f54e90a22d3ab6f" args="(const SlotReadMore &amp;slot_read_more, const SlotAsyncReady &amp;slot_async_ready, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f">Gio::File::load_partial_contents_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#add182d22071784fc345adc757b3d687b">SlotReadMore</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_read_more</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_async_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the partial contents of a file. </p>
<p>The <em>slot_read_more</em> callback slot should be used to stop reading from the file when appropriate. This operation can be finished by <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb" title="Finishes an asynchronous partial load operation that was started with load_partial_contents_async().">load_partial_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb" title="Finishes an asynchronous partial load operation that was started with load_partial_contents_async().">load_partial_contents_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot_read_more</td><td>A callback to receive partial data and to specify whether further data should be read. </td></tr>
    <tr><td class="paramname">slot_async_ready</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a362d71932c0ba8797a8c47b77df1b6d7"></a><!-- doxytag: member="Gio::File::load_partial_contents_async" ref="a362d71932c0ba8797a8c47b77df1b6d7" args="(const SlotReadMore &amp;slot_read_more, const SlotAsyncReady &amp;slot_async_ready)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f">Gio::File::load_partial_contents_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#add182d22071784fc345adc757b3d687b">SlotReadMore</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_read_more</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_async_ready</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the partial contents of a file. </p>
<p>The <em>slot_read_more</em> callback slot should be used to stop reading from the file when appropriate. This operation can be finished by <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb" title="Finishes an asynchronous partial load operation that was started with load_partial_contents_async().">load_partial_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb" title="Finishes an asynchronous partial load operation that was started with load_partial_contents_async().">load_partial_contents_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot_read_more</td><td>A callback to receive partial data and to specify whether further data should be read. </td></tr>
    <tr><td class="paramname">slot_async_ready</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b323508401d2e6fd2b3ad659f9bb5eb"></a><!-- doxytag: member="Gio::File::load_partial_contents_finish" ref="a4b323508401d2e6fd2b3ad659f9bb5eb" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, char *&amp;contents, gsize &amp;length, std::string &amp;etag_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb">Gio::File::load_partial_contents_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous partial load operation that was started with <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f" title="Reads the partial contents of a file.">load_partial_contents_async()</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
    <tr><td class="paramname">etag_out</td><td>A location to place the current entity tag for the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the load was successful. If <code>false</code> and <em>error</em> is present, it will be set appropriately. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3a59c3831feeadea9bd0709617d2db9"></a><!-- doxytag: member="Gio::File::load_partial_contents_finish" ref="ae3a59c3831feeadea9bd0709617d2db9" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, char *&amp;contents, gsize &amp;length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb">Gio::File::load_partial_contents_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous partial load operation that was started with <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f" title="Reads the partial contents of a file.">load_partial_contents_async()</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the load was successful. If <code>false</code> and <em>error</em> is present, it will be set appropriately. </dd></dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000037">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="abfa05e23e95e77cabac289ab4e294a58"></a><!-- doxytag: member="Gio::File::make_directory" ref="abfa05e23e95e77cabac289ab4e294a58" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#abfa05e23e95e77cabac289ab4e294a58">Gio::File::make_directory</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a directory. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on successful creation, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1e9aa5f58a76a8562fd00a13434f554"></a><!-- doxytag: member="Gio::File::make_directory" ref="aa1e9aa5f58a76a8562fd00a13434f554" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#abfa05e23e95e77cabac289ab4e294a58">Gio::File::make_directory</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a directory. </p>
<p>Note that this will only create a child directory of the immediate parent directory of the path or URI given by the <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a>. To recursively create directories, see <a class="el" href="classGio_1_1File.html#a874a487551d49ca62b31a3e5cf32fee6" title="Creates a directory and any parent directories that may not exist, similar to &#39;mkdir -p&#39;...">make_directory_with_parents()</a>. This function will fail if the parent directory does not exist, throwing an exception with IO_ERROR_NOT_FOUND. If the file system doesn't support creating directories, this function will fail, throwing an exception with IO_ERROR_NOT_SUPPORTED.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on successful creation, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afb0b5b094339057b4b15952eb73e08d6"></a><!-- doxytag: member="Gio::File::make_directory_with_parents" ref="afb0b5b094339057b4b15952eb73e08d6" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#afb0b5b094339057b4b15952eb73e08d6">Gio::File::make_directory_with_parents</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a directory and any parent directories that may not exist similar to 'mkdir -p'. </p>
<p>If the file system does not support creating directories, this function will fail, setting <em>error</em> to IO_ERROR_NOT_SUPPORTED. If the directory itself already exists, this function will fail setting <em>error</em> to IO_ERROR_EXISTS, unlike the similar Glib::mkdir_with_parents().</p>
<p>For a local <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> the newly created directories will have the default (current) ownership and permissions of the current process.</p>
<p>If <em>cancellable</em> is not <code>0</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error IO_ERROR_CANCELLED will be returned.</p>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000017">Since glibmm 2.18:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if all directories have been successfully created, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a874a487551d49ca62b31a3e5cf32fee6"></a><!-- doxytag: member="Gio::File::make_directory_with_parents" ref="a874a487551d49ca62b31a3e5cf32fee6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#afb0b5b094339057b4b15952eb73e08d6">Gio::File::make_directory_with_parents</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a directory and any parent directories that may not exist, similar to 'mkdir -p'. </p>
<p>If the file system does not support creating directories, this function will fail, throwing an exception with IO_ERROR_NOT_SUPPORTED.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on successful creation, <code>false</code> otherwise.</dd></dl>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000018">Since glibmm 2.18:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a2709318e1f24dfd0cd498d28f5e1b8fe"></a><!-- doxytag: member="Gio::File::make_symbolic_link" ref="a2709318e1f24dfd0cd498d28f5e1b8fe" args="(const std::string &amp;symlink_value, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a2709318e1f24dfd0cd498d28f5e1b8fe">Gio::File::make_symbolic_link</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>symlink_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a symbolic link. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">symlink_value</td><td>A string with the value of the new symlink. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on the creation of a new symlink, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a9a3d060c2675ff9ac1c758f0b2c024"></a><!-- doxytag: member="Gio::File::make_symbolic_link" ref="a8a9a3d060c2675ff9ac1c758f0b2c024" args="(const std::string &amp;symlink_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a2709318e1f24dfd0cd498d28f5e1b8fe">Gio::File::make_symbolic_link</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>symlink_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a symbolic link. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">symlink_value</td><td>A string with the value of the new symlink. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on the creation of a new symlink, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a88aacee7bb6f6d968b4383311a9dd002"></a><!-- doxytag: member="Gio::File::monitor" ref="a88aacee7bb6f6d968b4383311a9dd002" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileMonitorFlags flags=FILE_MONITOR_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; <a class="el" href="classGio_1_1File.html#a88aacee7bb6f6d968b4383311a9dd002">Gio::File::monitor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga469f795e9a4dddb2421c0e5568be6649ab14b94920f9dd257f04b8d2089ee7f41">FILE_MONITOR_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains a file monitor for the given file. </p>
<p>If no file notification mechanism exists, then regular polling of the file is used.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes.">FileMonitor</a> for the file.</dd></dl>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000019">Since glibmm 2.18:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a50896969a9de87f810f0bf5e2d3335bd"></a><!-- doxytag: member="Gio::File::monitor" ref="a50896969a9de87f810f0bf5e2d3335bd" args="(FileMonitorFlags flags=FILE_MONITOR_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; <a class="el" href="classGio_1_1File.html#a88aacee7bb6f6d968b4383311a9dd002">Gio::File::monitor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga469f795e9a4dddb2421c0e5568be6649ab14b94920f9dd257f04b8d2089ee7f41">FILE_MONITOR_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains a file monitor for the given file. </p>
<p>If no file notification mechanism exists, then regular polling of the file is used.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes.">FileMonitor</a> for the file.</dd></dl>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000020">Since glibmm 2.18:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aa0fa22ffba0ff50779e49ff9d12344e6"></a><!-- doxytag: member="Gio::File::monitor_directory" ref="aa0fa22ffba0ff50779e49ff9d12344e6" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileMonitorFlags flags=FILE_MONITOR_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; <a class="el" href="classGio_1_1File.html#aa0fa22ffba0ff50779e49ff9d12344e6">Gio::File::monitor_directory</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga469f795e9a4dddb2421c0e5568be6649ab14b94920f9dd257f04b8d2089ee7f41">FILE_MONITOR_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains a directory monitor for the given file. </p>
<p>This may fail if directory monitoring is not supported.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes.">FileMonitor</a> for the file. </dd></dl>

</div>
</div>
<a class="anchor" id="a12d36689c1024ff9fc8819f619910a92"></a><!-- doxytag: member="Gio::File::monitor_directory" ref="a12d36689c1024ff9fc8819f619910a92" args="(FileMonitorFlags flags=FILE_MONITOR_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; <a class="el" href="classGio_1_1File.html#aa0fa22ffba0ff50779e49ff9d12344e6">Gio::File::monitor_directory</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga469f795e9a4dddb2421c0e5568be6649ab14b94920f9dd257f04b8d2089ee7f41">FILE_MONITOR_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains a directory monitor for the given file. </p>
<p>This may fail if directory monitoring is not supported.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes.">FileMonitor</a> for the file. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8e14809f330ddd58e628c96921cd987"></a><!-- doxytag: member="Gio::File::monitor_file" ref="ab8e14809f330ddd58e628c96921cd987" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileMonitorFlags flags=FILE_MONITOR_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; <a class="el" href="classGio_1_1File.html#ab8e14809f330ddd58e628c96921cd987">Gio::File::monitor_file</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga469f795e9a4dddb2421c0e5568be6649ab14b94920f9dd257f04b8d2089ee7f41">FILE_MONITOR_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains a file monitor for the given file. </p>
<p>If no file notification mechanism exists, then regular polling of the file is used.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes.">FileMonitor</a> for the file. </dd></dl>

</div>
</div>
<a class="anchor" id="aa410183ed3b4a745093383d038d271b9"></a><!-- doxytag: member="Gio::File::monitor_file" ref="aa410183ed3b4a745093383d038d271b9" args="(FileMonitorFlags flags=FILE_MONITOR_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; <a class="el" href="classGio_1_1File.html#ab8e14809f330ddd58e628c96921cd987">Gio::File::monitor_file</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga469f795e9a4dddb2421c0e5568be6649ab14b94920f9dd257f04b8d2089ee7f41">FILE_MONITOR_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains a file monitor for the given file. </p>
<p>If no file notification mechanism exists, then regular polling of the file is used.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes.">FileMonitor</a> for the file. </dd></dl>

</div>
</div>
<a class="anchor" id="a144aa2de6b696da90a6baffbe959d732"></a><!-- doxytag: member="Gio::File::mount_enclosing_volume" ref="a144aa2de6b696da90a6baffbe959d732" args="(const Glib::RefPtr&lt; MountOperation &gt; &amp;mount_operation, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, MountMountFlags flags=MOUNT_MOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a144aa2de6b696da90a6baffbe959d732">Gio::File::mount_enclosing_volume</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga5484bace25c932fd4c7354259e138814a4fa5bb6630552f216d543dc14bdce93f">MOUNT_MOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a <em>mount_operation</em>, mounting the volume that contains the file. </p>
<p>When this operation has completed, <em>slot</em> will be called with, and the operation can be finalized with <a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d" title="Finishes a mount operation started by g_file_mount_enclosing_volume().">mount_enclosing_volume_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations.">MountOperation</a>. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70fd22116d9c8682433c4bb8cbd764c1"></a><!-- doxytag: member="Gio::File::mount_enclosing_volume" ref="a70fd22116d9c8682433c4bb8cbd764c1" args="(const Glib::RefPtr&lt; MountOperation &gt; &amp;mount_operation, const SlotAsyncReady &amp;slot, MountMountFlags flags=MOUNT_MOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a144aa2de6b696da90a6baffbe959d732">Gio::File::mount_enclosing_volume</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga5484bace25c932fd4c7354259e138814a4fa5bb6630552f216d543dc14bdce93f">MOUNT_MOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a <em>mount_operation</em>, mounting the volume that contains the file. </p>
<p>When this operation has completed, <em>slot</em> will be called with, and the operation can be finalized with <a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d" title="Finishes a mount operation started by g_file_mount_enclosing_volume().">mount_enclosing_volume_finish()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations.">MountOperation</a>. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2172cdcdb683630b719c521bf00b1eb4"></a><!-- doxytag: member="Gio::File::mount_enclosing_volume" ref="a2172cdcdb683630b719c521bf00b1eb4" args="(const SlotAsyncReady &amp;slot, MountMountFlags flags=MOUNT_MOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a144aa2de6b696da90a6baffbe959d732">Gio::File::mount_enclosing_volume</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga5484bace25c932fd4c7354259e138814a4fa5bb6630552f216d543dc14bdce93f">MOUNT_MOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a <em>mount_operation</em>, mounting the volume that contains the file. </p>
<p>When this operation has completed, <em>slot</em> will be called with, and the operation can be finalized with <a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d" title="Finishes a mount operation started by g_file_mount_enclosing_volume().">mount_enclosing_volume_finish()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20f8f18876102a5efaa0536bfa71d71c"></a><!-- doxytag: member="Gio::File::mount_enclosing_volume" ref="a20f8f18876102a5efaa0536bfa71d71c" args="(MountMountFlags flags=MOUNT_MOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a144aa2de6b696da90a6baffbe959d732">Gio::File::mount_enclosing_volume</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga5484bace25c932fd4c7354259e138814a4fa5bb6630552f216d543dc14bdce93f">MOUNT_MOUNT_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a <em>mount_operation</em>, mounting the volume that contains the file. </p>

</div>
</div>
<a class="anchor" id="aefd44b1b3467bcc474b345ff98b4aa6d"></a><!-- doxytag: member="Gio::File::mount_enclosing_volume_finish" ref="aefd44b1b3467bcc474b345ff98b4aa6d" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d">Gio::File::mount_enclosing_volume_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes a mount operation started by g_file_mount_enclosing_volume(). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if successful. If an error has occurred, this function will return <code>false</code> and set <em>error</em> appropriately if present. </dd></dl>

</div>
</div>
<a class="anchor" id="a40c88a403f5d01d722b5900545b6a4fe"></a><!-- doxytag: member="Gio::File::mount_mountable" ref="a40c88a403f5d01d722b5900545b6a4fe" args="(const Glib::RefPtr&lt; MountOperation &gt; &amp;mount_operation, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, MountMountFlags flags=MOUNT_MOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a40c88a403f5d01d722b5900545b6a4fe">Gio::File::mount_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga5484bace25c932fd4c7354259e138814a4fa5bb6630552f216d543dc14bdce93f">MOUNT_MOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>Using <em>mount_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8" title="Finishes a mount operation.">mount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations.">MountOperation</a>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3c29682ef5a50de73dc2c3c3333301c"></a><!-- doxytag: member="Gio::File::mount_mountable" ref="ac3c29682ef5a50de73dc2c3c3333301c" args="(const Glib::RefPtr&lt; MountOperation &gt; &amp;mount_operation, const SlotAsyncReady &amp;slot, MountMountFlags flags=MOUNT_MOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a40c88a403f5d01d722b5900545b6a4fe">Gio::File::mount_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga5484bace25c932fd4c7354259e138814a4fa5bb6630552f216d543dc14bdce93f">MOUNT_MOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>Using <em>mount_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8" title="Finishes a mount operation.">mount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations.">MountOperation</a>. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a049e06c3d95b49ad4bff1837ef6d8677"></a><!-- doxytag: member="Gio::File::mount_mountable" ref="a049e06c3d95b49ad4bff1837ef6d8677" args="(const SlotAsyncReady &amp;slot, MountMountFlags flags=MOUNT_MOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a40c88a403f5d01d722b5900545b6a4fe">Gio::File::mount_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga5484bace25c932fd4c7354259e138814a4fa5bb6630552f216d543dc14bdce93f">MOUNT_MOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mounts a file of type FILE_TYPE_MOUNTABLE without user interaction. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8" title="Finishes a mount operation.">mount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8501fa88f4aaa8d52c001596960a4572"></a><!-- doxytag: member="Gio::File::mount_mountable" ref="a8501fa88f4aaa8d52c001596960a4572" args="(MountMountFlags flags=MOUNT_MOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a40c88a403f5d01d722b5900545b6a4fe">Gio::File::mount_mountable</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga5484bace25c932fd4c7354259e138814a4fa5bb6630552f216d543dc14bdce93f">MOUNT_MOUNT_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mounts a file of type FILE_TYPE_MOUNTABLE without user interaction. </p>

</div>
</div>
<a class="anchor" id="ae15d36a7969c55122b9f85a1690a46e8"></a><!-- doxytag: member="Gio::File::mount_mountable_finish" ref="ae15d36a7969c55122b9f85a1690a46e8" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; <a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8">Gio::File::mount_mountable_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes a mount operation. </p>
<p>See g_file_mount_mountable() for details.</p>
<p>Finish an asynchronous mount operation that was started with g_file_mount_mountable(). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a51c0d55880178c37dee578fdc723b0f2"></a><!-- doxytag: member="Gio::File::move" ref="a51c0d55880178c37dee578fdc723b0f2" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const SlotFileProgress &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileCopyFlags flags=FILE_COPY_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a51c0d55880178c37dee578fdc723b0f2">Gio::File::move</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to move the file or directory source to the location specified by destination. </p>
<p>If native move operations are supported then this is used, otherwise a copy and delete fallback is used. The native implementation may support moving directories (for instance on moves inside the same filesystem), but the fallback code does not.</p>
<p>If the flag FILE_COPY_OVERWRITE is specified an already existing destination file is overwritten.</p>
<p>If the flag FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks will be copied as symlinks, otherwise the target of the source symlink will be copied.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>The operation can be monitored via the <em>slot</em> callback. If the source file does not exist then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown, independent on the status of the destination.</p>
<p>If G_FILE_COPY_OVERWRITE is not specified and the target exists, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with EXISTS will be thrown.</p>
<p>If trying to overwrite a file over a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown. If trying to overwrite a directory with a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WOULD_MERGE will be thrown.</p>
<p>If the source is a directory and the target does not exist, or FILE_COPY_OVERWRITE is specified and the target is a file, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WOULD_RECURSE may be thrown (if the native move operation isn't available). </p>

</div>
</div>
<a class="anchor" id="adfb2d8bfed1cb7af50e5e5795ebea732"></a><!-- doxytag: member="Gio::File::move" ref="adfb2d8bfed1cb7af50e5e5795ebea732" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, const SlotFileProgress &amp;slot, FileCopyFlags flags=FILE_COPY_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a51c0d55880178c37dee578fdc723b0f2">Gio::File::move</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aba1fab56c3a8bea0b7e4d7f7324c5320"></a><!-- doxytag: member="Gio::File::move" ref="aba1fab56c3a8bea0b7e4d7f7324c5320" args="(const Glib::RefPtr&lt; File &gt; &amp;destination, FileCopyFlags flags=FILE_COPY_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a51c0d55880178c37dee578fdc723b0f2">Gio::File::move</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga08edc09a45449b136b27493647d4ecbea2de95276b80f5261e9de761e98987273">FILE_COPY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a128757d6cf7b152c82bb378a095003ef"></a><!-- doxytag: member="Gio::File::open_readwrite" ref="a128757d6cf7b152c82bb378a095003ef" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; <a class="el" href="classGio_1_1File.html#a128757d6cf7b152c82bb378a095003ef">Gio::File::open_readwrite</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens an existing file for reading and writing. </p>
<p>The result is a <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file.">FileIOStream</a> that can be used to read and write the contents of the file.</p>
<p>If <em>cancellable</em> is not <code>0</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error IO_ERROR_CANCELLED will be returned.</p>
<p>If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned. If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are possible too, and depend on what kind of filesystem the file is on. Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000026">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file.">FileIOStream</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a73d95a731716c7ffaa86c3af90afe8d3"></a><!-- doxytag: member="Gio::File::open_readwrite_async" ref="a73d95a731716c7ffaa86c3af90afe8d3" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a73d95a731716c7ffaa86c3af90afe8d3">Gio::File::open_readwrite_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens an existing file for reading and writing. </p>
<p>The result is a <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file.">FileIOStream</a> that can be used to read and write the contents of the file.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a128757d6cf7b152c82bb378a095003ef" title="Opens an existing file for reading and writing.">open_readwrite()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a9c501374d1257d5eeed903be20b66f63" title="Finishes an asynchronous file read operation started with g_file_open_readwrite_async().">open_readwrite_finish()</a> to get the result of the operation. If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. If the file is a directory, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a405af7082f531a7a39f3e7a453ab6267"></a><!-- doxytag: member="Gio::File::open_readwrite_async" ref="a405af7082f531a7a39f3e7a453ab6267" args="(const SlotAsyncReady &amp;slot, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a73d95a731716c7ffaa86c3af90afe8d3">Gio::File::open_readwrite_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens an existing file for reading and writing. </p>
<p>The result is a <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file.">FileIOStream</a> that can be used to read and write the contents of the file.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a128757d6cf7b152c82bb378a095003ef" title="Opens an existing file for reading and writing.">open_readwrite()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a9c501374d1257d5eeed903be20b66f63" title="Finishes an asynchronous file read operation started with g_file_open_readwrite_async().">open_readwrite_finish()</a> to get the result of the operation. If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. If the file is a directory, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c501374d1257d5eeed903be20b66f63"></a><!-- doxytag: member="Gio::File::open_readwrite_finish" ref="a9c501374d1257d5eeed903be20b66f63" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; <a class="el" href="classGio_1_1File.html#a9c501374d1257d5eeed903be20b66f63">Gio::File::open_readwrite_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous file read operation started with g_file_open_readwrite_async(). </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000027">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file.">FileIOStream</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a8e81dd0bab13e56ed98456f6a53591ca"></a><!-- doxytag: member="Gio::File::poll_mountable" ref="a8e81dd0bab13e56ed98456f6a53591ca" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a8e81dd0bab13e56ed98456f6a53591ca">Gio::File::poll_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Polls a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#a195990af8825745d0d26147174824565" title="Finishes an stop operation, see g_file_stop_mountable() for details.">stop_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot,:</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2025339de9d7ed9b62300cad1a8e8fd4"></a><!-- doxytag: member="Gio::File::poll_mountable" ref="a2025339de9d7ed9b62300cad1a8e8fd4" args="(const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a8e81dd0bab13e56ed98456f6a53591ca">Gio::File::poll_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Polls a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#a195990af8825745d0d26147174824565" title="Finishes an stop operation, see g_file_stop_mountable() for details.">stop_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot,:</td><td>A callback to call when the request is satisfied.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2da5ec13a4a32f229ca97cce8961e637"></a><!-- doxytag: member="Gio::File::poll_mountable_finish" ref="a2da5ec13a4a32f229ca97cce8961e637" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a2da5ec13a4a32f229ca97cce8961e637">Gio::File::poll_mountable_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes a poll operation. </p>
<p>See g_file_poll_mountable() for details.</p>
<p>Finish an asynchronous poll operation that was polled with g_file_poll_mountable().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000033">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the operation finished successfully. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a753546465735b25633b003333b66d05c"></a><!-- doxytag: member="Gio::File::query_default_handler" ref="a753546465735b25633b003333b66d05c" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AppInfo.html">AppInfo</a>&gt; <a class="el" href="classGio_1_1File.html#a753546465735b25633b003333b66d05c">Gio::File::query_default_handler</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch them...">AppInfo</a> that is registered as the default application to handle the file specified by <em>file</em>. </p>
<p>If <em>cancellable</em> is not <code>0</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error IO_ERROR_CANCELLED will be returned. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch them...">AppInfo</a> if the handle was found, <code>0</code> if there were errors. When you are done with it, release it with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a0c0fd0ece2570b6704889df5ee43c283"></a><!-- doxytag: member="Gio::File::query_default_handler" ref="a0c0fd0ece2570b6704889df5ee43c283" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AppInfo.html">AppInfo</a>&gt; <a class="el" href="classGio_1_1File.html#a753546465735b25633b003333b66d05c">Gio::File::query_default_handler</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch them...">AppInfo</a> that is registered as the default application to handle the file specified by the file. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch them...">AppInfo</a> if the handle was found, or an empty RefPtr if there were errors. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8b0a75e0afdb5f6874ea5e304d55ea8"></a><!-- doxytag: member="Gio::File::query_exists" ref="ad8b0a75e0afdb5f6874ea5e304d55ea8" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#ad8b0a75e0afdb5f6874ea5e304d55ea8">Gio::File::query_exists</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Utility function to check if a particular file exists. </p>
<p>This is implemented using <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a> and as such does blocking I/O.</p>
<p>Note that in many cases it is racy to first check for file existence and then execute something based on the outcome of that, because the file might have been created or removed in between the operations. The general approach to handling that is to not check, but just do the operation and handle the errors as they come.</p>
<p>As an example of race-free checking, take the case of reading a file, and if it doesn't exist, creating it. There are two racy versions: read it, and on error create it; and: check if it exists, if not create it. These can both result in two processes creating the file (with perhaps a partially written file as the result). The correct approach is to always try to create the file with File::create() which will either atomically create the file or fail with a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> exception with EXISTS.</p>
<p>However, in many cases an existence check is useful in a user interface, for instance to make a menu item sensitive/insensitive, so that you don't have to fool users that something is possible and then just show and error dialog. If you do this, you should make sure to also handle the errors that can happen due to races when you execute the operation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the file exists (and can be detected without error), <code>false</code> otherwise (or if cancelled). </dd></dl>

</div>
</div>
<a class="anchor" id="ab4cfdbf4fedacd364e40a72c71ab341a"></a><!-- doxytag: member="Gio::File::query_exists" ref="ab4cfdbf4fedacd364e40a72c71ab341a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#ad8b0a75e0afdb5f6874ea5e304d55ea8">Gio::File::query_exists</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Utility function to check if a particular file exists. </p>
<p>This is implemented using <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a> and as such does blocking I/O.</p>
<p>Note that in many cases it is racy to first check for file existance and then execute something based on the outcome of that, because the file might have been created or removed inbetween the operations. The general approach to handling that is to not check, but just do the operation and handle the errors as they come.</p>
<p>As an example of race-free checking, take the case of reading a file, and if it doesn't exist, creating it. There are two racy versions: read it, and on error create it; and: check if it exists, if not create it. These can both result in two processes creating the file (with perhaps a partially written file as the result). The correct approach is to always try to create the file with g_file_create() which will either atomically create the file or throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with EXISTS.</p>
<p>However, in many cases an existance check is useful in a user interface, for instance to make a menu item sensitive/insensitive, so that you don't have to fool users that something is possible and then just show and error dialog. If you do this, you should make sure to also handle the errors that can happen due to races when you execute the operation.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the file exists (and can be detected without error), false otherwise (or if cancelled). </dd></dl>

</div>
</div>
<a class="anchor" id="aa27c5b271c8f7667ce117cfc6118262e"></a><!-- doxytag: member="Gio::File::query_file_type" ref="aa27c5b271c8f7667ce117cfc6118262e" args="(FileQueryInfoFlags flags, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga7dcba95023d74c47bba3fd0a07f8824c">FileType</a> <a class="el" href="classGio_1_1File.html#aa27c5b271c8f7667ce117cfc6118262e">Gio::File::query_file_type</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Utility function to inspect the FileType of a file. </p>
<p>This is implemented using g_file_query_info() and as such does blocking I/O.</p>
<p>The primary use case of this method is to check if a file is a regular file, directory, or symlink.</p>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000015">Since glibmm 2.18:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags passed to g_file_query_info(). </td></tr>
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The FileType of the file and FILE_TYPE_UNKNOWN if the file does not exist. </dd></dl>

</div>
</div>
<a class="anchor" id="a691a9de5512b870bf358a9b0d292e146"></a><!-- doxytag: member="Gio::File::query_file_type" ref="a691a9de5512b870bf358a9b0d292e146" args="(FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga7dcba95023d74c47bba3fd0a07f8824c">FileType</a> <a class="el" href="classGio_1_1File.html#aa27c5b271c8f7667ce117cfc6118262e">Gio::File::query_file_type</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Utility function to inspect the #GFileType of a file. </p>
<p>This is implemented using <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a> and as such does blocking I/O.</p>
<p>The primary use case of this method is to check if a file is a regular file, directory, or symlink.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flags,:</td><td>a set of FileQueryInfoFlags passed to <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a>. The FileType of the file, or FILE_TYPE_UNKNOWN if the file does not exist.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000016">Since glibmm 2.18:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a40486bc2f0c8758ef8a705b6b8b57e57"></a><!-- doxytag: member="Gio::File::query_filesystem_info" ref="a40486bc2f0c8758ef8a705b6b8b57e57" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;attributes=&quot;*&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; <a class="el" href="classGio_1_1File.html#a40486bc2f0c8758ef8a705b6b8b57e57">Gio::File::query_filesystem_info</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a>, but obtains information about the filesystem the file is on, rather than the file itself. </p>
<p>For instance the amount of space availible and the type of the filesystem.</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if its not possible to read a particular requested attribute from a file, it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "fs:*" means all attributes in the fs namespace. The standard namespace for filesystem attributes is "fs". Common attributes of interest are FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem in bytes), FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes availible), and FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> or an empty RefPtr if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="ac737012f8df97d90e2447d94d30b817d"></a><!-- doxytag: member="Gio::File::query_filesystem_info" ref="ac737012f8df97d90e2447d94d30b817d" args="(const std::string &amp;attributes=&quot;*&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; <a class="el" href="classGio_1_1File.html#a40486bc2f0c8758ef8a705b6b8b57e57">Gio::File::query_filesystem_info</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a>, but obtains information about the filesystem the file is on, rather than the file itself. </p>
<p>For instance the amount of space availible and the type of the filesystem.</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if its not possible to read a particular requested attribute from a file, it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "fs:*" means all attributes in the fs namespace. The standard namespace for filesystem attributes is "fs". Common attributes of interest are FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem in bytes), FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes availible), and FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> or an empty RefPtr if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a39184ff9c9437259df4b9a9e2f283a0b"></a><!-- doxytag: member="Gio::File::query_filesystem_info_async" ref="a39184ff9c9437259df4b9a9e2f283a0b" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;attributes=&quot;*&quot;, int io_priority=Glib::PRIORITY_DEFAULT) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a39184ff9c9437259df4b9a9e2f283a0b">Gio::File::query_filesystem_info_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously gets the requested information about the filesystem that the file is on. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> object that contains key-value attributes (such as type or size for the file).</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a40486bc2f0c8758ef8a705b6b8b57e57" title="Similar to query_info(), but obtains information about the filesystem the file is on...">query_filesystem_info()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#afd1159de8f782d918d8d460cddffee5b" title="Finishes an asynchronous filesystem info query.">query_filesystem_info_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4557ab16a50337f73d8a4649cf60fe70"></a><!-- doxytag: member="Gio::File::query_filesystem_info_async" ref="a4557ab16a50337f73d8a4649cf60fe70" args="(const SlotAsyncReady &amp;slot, const std::string &amp;attributes=&quot;*&quot;, int io_priority=Glib::PRIORITY_DEFAULT) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a39184ff9c9437259df4b9a9e2f283a0b">Gio::File::query_filesystem_info_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously gets the requested information about the filesystem that the file is on. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> object that contains key-value attributes (such as type or size for the file).</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a40486bc2f0c8758ef8a705b6b8b57e57" title="Similar to query_info(), but obtains information about the filesystem the file is on...">query_filesystem_info()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#afd1159de8f782d918d8d460cddffee5b" title="Finishes an asynchronous filesystem info query.">query_filesystem_info_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd1159de8f782d918d8d460cddffee5b"></a><!-- doxytag: member="Gio::File::query_filesystem_info_finish" ref="afd1159de8f782d918d8d460cddffee5b" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; <a class="el" href="classGio_1_1File.html#afd1159de8f782d918d8d460cddffee5b">Gio::File::query_filesystem_info_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous filesystem info query. </p>
<p>See g_file_query_filesystem_info_async(). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> for given <em>file</em> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="adb25ffdbe571d33e89c9503fe9a20dcd"></a><!-- doxytag: member="Gio::File::query_info" ref="adb25ffdbe571d33e89c9503fe9a20dcd" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;attributes=&quot;*&quot;, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd">Gio::File::query_info</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the requested information about the file. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> object that contains key-value attributes (such as the type or size of the file).</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if it's not possible to read a particular requested attribute from a file - it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "standard::*" means all attributes in the standard namespace. An example attribute query be "standard::*,owner::user". The standard attributes are available as defines, like #G_FILE_ATTRIBUTE_STANDARD_NAME.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>For symlinks, normally the information about the target of the symlink is returned, rather than information about the symlink itself. However if you pass FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in <em>flags</em> the information about the symlink itself will be returned. Also, for symlinks that point to non-existing files the information about the symlink itself will be returned.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">attributes,:</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags,:</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> for the file, or an empty RefPtr on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e4b9c07ade255b12e2b43c38c3aba90"></a><!-- doxytag: member="Gio::File::query_info" ref="a4e4b9c07ade255b12e2b43c38c3aba90" args="(const std::string &amp;attributes=&quot;*&quot;, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd">Gio::File::query_info</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the requested information about the file. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> object that contains key-value attributes (such as the type or size of the file).</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if it's not possible to read a particular requested attribute from a file - it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "standard::*" means all attributes in the standard namespace. An example attribute query be "standard::*,owner::user". The standard attributes are available as defines, like #G_FILE_ATTRIBUTE_STANDARD_NAME.</p>
<p>For symlinks, normally the information about the target of the symlink is returned, rather than information about the symlink itself. However if you pass FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in <em>flags</em> the information about the symlink itself will be returned. Also, for symlinks that point to non-existing files the information about the symlink itself will be returned.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attributes,:</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags,:</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> for the file, or an empty RefPtr on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a7bd60e7864f8954c35e3b0891058e61c"></a><!-- doxytag: member="Gio::File::query_info_async" ref="a7bd60e7864f8954c35e3b0891058e61c" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;attributes=&quot;*&quot;, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a7bd60e7864f8954c35e3b0891058e61c">Gio::File::query_info_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously gets the requested information about specified file. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> object that contains key-value attributes (such as type or size for the file).</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#afd4ffc3630b41754c177658f2e745357" title="Finishes an asynchronous file info query.">query_info_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcad69d782a971802a8aa85125ac2c8c"></a><!-- doxytag: member="Gio::File::query_info_async" ref="afcad69d782a971802a8aa85125ac2c8c" args="(const SlotAsyncReady &amp;slot, const std::string &amp;attributes=&quot;*&quot;, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a7bd60e7864f8954c35e3b0891058e61c">Gio::File::query_info_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously gets the requested information about specified file. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> object that contains key-value attributes (such as type or size for the file).</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file.">query_info()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#afd4ffc3630b41754c177658f2e745357" title="Finishes an asynchronous file info query.">query_info_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd4ffc3630b41754c177658f2e745357"></a><!-- doxytag: member="Gio::File::query_info_finish" ref="afd4ffc3630b41754c177658f2e745357" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; <a class="el" href="classGio_1_1File.html#afd4ffc3630b41754c177658f2e745357">Gio::File::query_info_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous file info query. </p>
<p>See g_file_query_info_async(). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> for given <em>file</em> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a4a543339b58cff6a7e5ddd840df0e69e"></a><!-- doxytag: member="Gio::File::query_settable_attributes" ref="a4a543339b58cff6a7e5ddd840df0e69e" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a>&gt; <a class="el" href="classGio_1_1File.html#a4a543339b58cff6a7e5ddd840df0e69e">Gio::File::query_settable_attributes</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the list of settable attributes for the file. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileAttributeInfoList.html" title="Key-Value paired file attributes.">FileAttributeInfoList</a> describing the settable attributes. When you are done with it, release it with g_file_attribute_info_list_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a1ae03d0652bcfbad2f47409b8f815bc4"></a><!-- doxytag: member="Gio::File::query_settable_attributes" ref="a1ae03d0652bcfbad2f47409b8f815bc4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a>&gt; <a class="el" href="classGio_1_1File.html#a4a543339b58cff6a7e5ddd840df0e69e">Gio::File::query_settable_attributes</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the list of settable attributes for the file. </p>
<p>Returns: a <a class="el" href="classGio_1_1FileAttributeInfoList.html" title="Key-Value paired file attributes.">FileAttributeInfoList</a> describing the settable attributes. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileAttributeInfoList.html" title="Key-Value paired file attributes.">FileAttributeInfoList</a> describing the settable attributes. </dd></dl>

</div>
</div>
<a class="anchor" id="af5c7463b92e2887597486e7b195ca12f"></a><!-- doxytag: member="Gio::File::query_writable_namespaces" ref="af5c7463b92e2887597486e7b195ca12f" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a>&gt; <a class="el" href="classGio_1_1File.html#af5c7463b92e2887597486e7b195ca12f">Gio::File::query_writable_namespaces</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the list of attribute namespaces where new attributes can be created by a user. </p>
<p>An example of this is extended attributes (in the "xattr" namespace).</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileAttributeInfoList.html" title="Key-Value paired file attributes.">FileAttributeInfoList</a> describing the writable namespaces. When you are done with it, release it with g_file_attribute_info_list_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="aa0278acd7d09ed292359004defb742b0"></a><!-- doxytag: member="Gio::File::query_writable_namespaces" ref="aa0278acd7d09ed292359004defb742b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a>&gt; <a class="el" href="classGio_1_1File.html#af5c7463b92e2887597486e7b195ca12f">Gio::File::query_writable_namespaces</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the list of attribute namespaces where new attributes can be created by a user. </p>
<p>An example of this is extended attributes (in the "xattr" namespace).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileAttributeInfoList.html" title="Key-Value paired file attributes.">FileAttributeInfoList</a> describing the writable namespaces. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ef959c7ad7096846f26eb8b282e3c68"></a><!-- doxytag: member="Gio::File::read" ref="a3ef959c7ad7096846f26eb8b282e3c68" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a>&gt; <a class="el" href="classGio_1_1File.html#a3ef959c7ad7096846f26eb8b282e3c68">Gio::File::read</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens a file for reading. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file.">FileInputStream</a> that can be used to read the contents of the file.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. If the file is a directory, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file.">FileInputStream</a> or <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a0395b3b0b8cec5dc1fd9953e52e5fbc1"></a><!-- doxytag: member="Gio::File::read" ref="a0395b3b0b8cec5dc1fd9953e52e5fbc1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a>&gt; <a class="el" href="classGio_1_1File.html#a3ef959c7ad7096846f26eb8b282e3c68">Gio::File::read</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens a file for reading. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file.">FileInputStream</a> that can be used to read the contents of the file.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_FOUND will be thrown. If the file is a directory, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file.">FileInputStream</a> or an empty RefPtr on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a2826eed0b1e76c3771f6ad5f5b993991"></a><!-- doxytag: member="Gio::File::read_async" ref="a2826eed0b1e76c3771f6ad5f5b993991" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a2826eed0b1e76c3771f6ad5f5b993991">Gio::File::read_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously opens the file for reading. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1" title="Opens a file for reading.">read()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a64b10854ad1add1f888ecb19403eb921" title="Finishes an asynchronous file read operation started with g_file_read_async().">read_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab451a182a647408e697c9115e66f6194"></a><!-- doxytag: member="Gio::File::read_async" ref="ab451a182a647408e697c9115e66f6194" args="(const SlotAsyncReady &amp;slot, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a2826eed0b1e76c3771f6ad5f5b993991">Gio::File::read_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously opens the file for reading. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1" title="Opens a file for reading.">read()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a64b10854ad1add1f888ecb19403eb921" title="Finishes an asynchronous file read operation started with g_file_read_async().">read_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64b10854ad1add1f888ecb19403eb921"></a><!-- doxytag: member="Gio::File::read_finish" ref="a64b10854ad1add1f888ecb19403eb921" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a>&gt; <a class="el" href="classGio_1_1File.html#a64b10854ad1add1f888ecb19403eb921">Gio::File::read_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous file read operation started with g_file_read_async(). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file.">FileInputStream</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="aded971b0cf84801f6684ad4bd5dc66c5"></a><!-- doxytag: member="Gio::File::remove" ref="aded971b0cf84801f6684ad4bd5dc66c5" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#aded971b0cf84801f6684ad4bd5dc66c5">Gio::File::remove</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes a file. </p>
<p>If the file is a directory, it will only be deleted if it is empty. The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGlib_1_1FileError.html" title="Exception class for file-related errors.">Glib::FileError</a> with ERROR_CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the file was deleted. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a14f34508dea523cbf889b7193e513ca4"></a><!-- doxytag: member="Gio::File::remove" ref="a14f34508dea523cbf889b7193e513ca4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#aded971b0cf84801f6684ad4bd5dc66c5">Gio::File::remove</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes a file. </p>
<p>If the file is a directory, it will only be deleted if it is empty.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the file was deleted. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7cf0360096504e40f799fde5cc8e9de"></a><!-- doxytag: member="Gio::File::replace" ref="ad7cf0360096504e40f799fde5cc8e9de" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;etag=std::string(), bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; <a class="el" href="classGio_1_1File.html#ad7cf0360096504e40f799fde5cc8e9de">Gio::File::replace</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an output stream for overwriting the file, possibly creating a backup copy of the file first. </p>
<p>This will try to replace the file in the safest way possible so that any errors during the writing will not affect an already existing copy of the file. For instance, for local files it may write to a temporary file and then atomically rename over the destination when the stream is closed.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If you pass in an etag value, then this value is compared to the current entity tag of the file, and if they differ a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WRONG_ETAG will be thrown. This generally means that the file has been changed since you last read it. You can get the new etag from <a class="el" href="classGio_1_1FileOutputStream.html#a8e29de4e67428a79b41180ca27af0a3d" title="Gets the entity tag for the file when it has been written.">FileOutputStream::get_etag()</a> after you've finished writing and closed the <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a>. When you load a new file you can use <a class="el" href="classGio_1_1FileInputStream.html#ae9cf87761484839f4ea53bc33064f189" title="Queries a file input stream the given attributes.">FileInputStream::query_info()</a> to get the etag of the file.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the current file before overwriting it. If this fails aa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANT_CREATE_BACKUP will be thrown. If you want to replace anyway, try again with <em>make_backup</em> set to false.</p>
<p>If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown, and if the file is some other form of non-regular file then aa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_REGULAR_FILE will be thrown. Some file systems don't allow all file names, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">etag</td><td>An optional entity tag for the current Glib::File. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="acf55f9291659566f6fd36271801b013b"></a><!-- doxytag: member="Gio::File::replace" ref="acf55f9291659566f6fd36271801b013b" args="(const std::string &amp;etag=std::string(), bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; <a class="el" href="classGio_1_1File.html#ad7cf0360096504e40f799fde5cc8e9de">Gio::File::replace</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an output stream for overwriting the file, possibly creating a backup copy of the file first. </p>
<p>This will try to replace the file in the safest way possible so that any errors during the writing will not affect an already existing copy of the file. For instance, for local files it may write to a temporary file and then atomically rename over the destination when the stream is closed.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>If you pass in an etag value, then this value is compared to the current entity tag of the file, and if they differ a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WRONG_ETAG will be thrown. This generally means that the file has been changed since you last read it. You can get the new etag from <a class="el" href="classGio_1_1FileOutputStream.html#a8e29de4e67428a79b41180ca27af0a3d" title="Gets the entity tag for the file when it has been written.">FileOutputStream::get_etag()</a> after you've finished writing and closed the <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a>. When you load a new file you can use <a class="el" href="classGio_1_1FileInputStream.html#ae9cf87761484839f4ea53bc33064f189" title="Queries a file input stream the given attributes.">FileInputStream::query_info()</a> to get the etag of the file.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the current file before overwriting it. If this fails aa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANT_CREATE_BACKUP will be thrown. If you want to replace anyway, try again with <em>make_backup</em> set to false.</p>
<p>If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with IS_DIRECTORY will be thrown, and if the file is some other form of non-regular file then aa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_REGULAR_FILE will be thrown. Some file systems don't allow all file names, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">etag</td><td>An optional entity tag for the current Glib::File. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad777cdaa404a6a668ee8d520299687ce"></a><!-- doxytag: member="Gio::File::replace_async" ref="ad777cdaa404a6a668ee8d520299687ce" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;etag=std::string(), bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#ad777cdaa404a6a668ee8d520299687ce">Gio::File::replace_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asyncronously overwrites the file, replacing the contents, possibly creating a backup copy of the file first. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ad7cf0360096504e40f799fde5cc8e9de" title="Returns an output stream for overwriting the file, possibly creating a backup copy of the file first...">replace()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ab28557d592f2c53df618728cf865e65e" title="Finishes an asynchronous file replace operation started with g_file_replace_async().">replace_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">etag</td><td>An entity tag for the current <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a>. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup of the existing file should be made. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae51e51a2e3a45da4324230b4d5401a58"></a><!-- doxytag: member="Gio::File::replace_async" ref="ae51e51a2e3a45da4324230b4d5401a58" args="(const SlotAsyncReady &amp;slot, const std::string &amp;etag=std::string(), bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#ad777cdaa404a6a668ee8d520299687ce">Gio::File::replace_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asyncronously overwrites the file, replacing the contents, possibly creating a backup copy of the file first. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ad7cf0360096504e40f799fde5cc8e9de" title="Returns an output stream for overwriting the file, possibly creating a backup copy of the file first...">replace()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ab28557d592f2c53df618728cf865e65e" title="Finishes an asynchronous file replace operation started with g_file_replace_async().">replace_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">etag</td><td>An entity tag for the current <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a>. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup of the existing file should be made. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af10deca1d5c5d1f650d3b182624330dc"></a><!-- doxytag: member="Gio::File::replace_contents" ref="af10deca1d5c5d1f650d3b182624330dc" args="(const char *contents, gsize length, const std::string &amp;etag, std::string &amp;new_etag, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#af10deca1d5c5d1f650d3b182624330dc">Gio::File::replace_contents</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>new_etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces the contents of the file with <em>contents</em> of <em>length</em> bytes. </p>
<p>If <em>etag</em> is specified (not an empty string) any existing file must have that etag, or a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WRONG_ETAG will be thrown.</p>
<p>If <em>make_backup</em> is <code>true</code>, this function will attempt to make a backup of the file.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>The returned <em>new_etag</em> can be used to verify that the file hasn't changed the next time it is saved over. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">contents</td><td>A string containing the new contents for the file. </td></tr>
    <tr><td class="paramname">length</td><td>The length of <em>contents</em> in bytes. </td></tr>
    <tr><td class="paramname">etag</td><td>The old entity tag for the document. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">new_etag</td><td>A location to a new entity tag for the document. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7febf1f0f3b4b9efca9fae469082846"></a><!-- doxytag: member="Gio::File::replace_contents" ref="ae7febf1f0f3b4b9efca9fae469082846" args="(const char *contents, gsize length, const std::string &amp;etag, std::string &amp;new_etag, bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#af10deca1d5c5d1f650d3b182624330dc">Gio::File::replace_contents</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>new_etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces the contents of the file with <em>contents</em> of <em>length</em> bytes. </p>
<p>If <em>etag</em> is specified (not an empty string) any existing file must have that etag, or a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WRONG_ETAG will be thrown.</p>
<p>If <em>make_backup</em> is <code>true</code>, this function will attempt to make a backup of the file.</p>
<p>The returned <em>new_etag</em> can be used to verify that the file hasn't changed the next time it is saved over. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">contents</td><td>A string containing the new contents for the file. </td></tr>
    <tr><td class="paramname">length</td><td>The length of <em>contents</em> in bytes. </td></tr>
    <tr><td class="paramname">etag</td><td>The old entity tag for the document. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">new_etag</td><td>A location to a new entity tag for the document. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23126b43cd262b63c0e458c3a4d0b65c"></a><!-- doxytag: member="Gio::File::replace_contents" ref="a23126b43cd262b63c0e458c3a4d0b65c" args="(const std::string &amp;contents, const std::string &amp;etag, std::string &amp;new_etag, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#af10deca1d5c5d1f650d3b182624330dc">Gio::File::replace_contents</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>new_etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces the contents of the file with <em>contents</em>. </p>
<p>If <em>etag</em> is specified (not an empty string) any existing file must have that etag, or a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WRONG_ETAG will be thrown.</p>
<p>If <em>make_backup</em> is <code>true</code>, this function will attempt to make a backup of the file.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>The returned <em>new_etag</em> can be used to verify that the file hasn't changed the next time it is saved over. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">contents</td><td>A string containing the new contents for the file. </td></tr>
    <tr><td class="paramname">etag</td><td>The old entity tag for the document. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">new_etag</td><td>A location to a new entity tag for the document. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf33a17461ff4f70fed06818e364f617"></a><!-- doxytag: member="Gio::File::replace_contents" ref="aaf33a17461ff4f70fed06818e364f617" args="(const std::string &amp;contents, const std::string &amp;etag, std::string &amp;new_etag, bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#af10deca1d5c5d1f650d3b182624330dc">Gio::File::replace_contents</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>new_etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces the contents of the file with <em>contents</em>. </p>
<p>If <em>etag</em> is specified (not an empty string) any existing file must have that etag, or a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with WRONG_ETAG will be thrown.</p>
<p>If <em>make_backup</em> is <code>true</code>, this function will attempt to make a backup of the file.</p>
<p>The returned <em>new_etag</em> can be used to verify that the file hasn't changed the next time it is saved over. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">contents</td><td>A string containing the new contents for the file. </td></tr>
    <tr><td class="paramname">etag</td><td>The old entity tag for the document. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">new_etag</td><td>A location to a new entity tag for the document. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad33b24a7942429157f47379f4353378c"></a><!-- doxytag: member="Gio::File::replace_contents_async" ref="ad33b24a7942429157f47379f4353378c" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const char *contents, gsize length, const std::string &amp;etag, bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c">Gio::File::replace_contents_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. </p>
<p><em>etag</em> will replace the document's current entity tag.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#af019065c5503c7f47d778c20f8e5de32" title="Finishes an asynchronous replace of the given file .">replace_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot,:</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">contents</td><td>String of contents to replace the file with. </td></tr>
    <tr><td class="paramname">length</td><td>The length of <em>contents</em> in bytes. </td></tr>
    <tr><td class="paramname">etag</td><td>a new entity tag for the file. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a1c445e84124e16294974a73f2f1bbb"></a><!-- doxytag: member="Gio::File::replace_contents_async" ref="a9a1c445e84124e16294974a73f2f1bbb" args="(const SlotAsyncReady &amp;slot, const char *contents, gsize length, const std::string &amp;etag, bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c">Gio::File::replace_contents_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. </p>
<p><em>etag</em> will replace the document's current entity tag.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#af019065c5503c7f47d778c20f8e5de32" title="Finishes an asynchronous replace of the given file .">replace_contents_finish()</a>.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot,:</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">contents</td><td>String of contents to replace the file with. </td></tr>
    <tr><td class="paramname">length</td><td>The length of <em>contents</em> in bytes. </td></tr>
    <tr><td class="paramname">etag</td><td>a new entity tag for the file. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a380d6ce6362fc05e0e18ff1b881ceac7"></a><!-- doxytag: member="Gio::File::replace_contents_async" ref="a380d6ce6362fc05e0e18ff1b881ceac7" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;contents, const std::string &amp;etag, bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c">Gio::File::replace_contents_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. </p>
<p><em>etag</em> will replace the document's current entity tag.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#af019065c5503c7f47d778c20f8e5de32" title="Finishes an asynchronous replace of the given file .">replace_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot,:</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">contents</td><td>String of contents to replace the file with. </td></tr>
    <tr><td class="paramname">etag</td><td>a new entity tag for the file. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6fc86aab90620881899a701c2b2775cb"></a><!-- doxytag: member="Gio::File::replace_contents_async" ref="a6fc86aab90620881899a701c2b2775cb" args="(const SlotAsyncReady &amp;slot, const std::string &amp;contents, const std::string &amp;etag, bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c">Gio::File::replace_contents_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an asynchronous replacement of the file with the given <em>contents</em>. </p>
<p><em>etag</em> will replace the document's current entity tag.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#af019065c5503c7f47d778c20f8e5de32" title="Finishes an asynchronous replace of the given file .">replace_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot,:</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">contents</td><td>String of contents to replace the file with. </td></tr>
    <tr><td class="paramname">etag</td><td>a new entity tag for the file. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af019065c5503c7f47d778c20f8e5de32"></a><!-- doxytag: member="Gio::File::replace_contents_finish" ref="af019065c5503c7f47d778c20f8e5de32" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, std::string &amp;etag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#af019065c5503c7f47d778c20f8e5de32">Gio::File::replace_contents_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous replace of the given file . </p>
<p>See <a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c" title="Starts an asynchronous replacement of the file with the given contents of length bytes.">replace_contents_async()</a>. Sets <em>new_etag</em> to the new entity tag for the document. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">new_etag</td><td>A location of a new entity tag for the document. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0372ffd3f535f39b7e48c0483e4c1f4"></a><!-- doxytag: member="Gio::File::replace_contents_finish" ref="af0372ffd3f535f39b7e48c0483e4c1f4" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#af019065c5503c7f47d778c20f8e5de32">Gio::File::replace_contents_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous replace of the given file . </p>
<p>See <a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c" title="Starts an asynchronous replacement of the file with the given contents of length bytes.">replace_contents_async()</a>. Sets <em>new_etag</em> to the new entity tag for the document. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. for the document. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab28557d592f2c53df618728cf865e65e"></a><!-- doxytag: member="Gio::File::replace_finish" ref="ab28557d592f2c53df618728cf865e65e" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; <a class="el" href="classGio_1_1File.html#ab28557d592f2c53df618728cf865e65e">Gio::File::replace_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous file replace operation started with g_file_replace_async(). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a>, or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="af483e2ddc29cbb6cd1ad751403247bad"></a><!-- doxytag: member="Gio::File::replace_readwrite" ref="af483e2ddc29cbb6cd1ad751403247bad" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;etag=std::string(), bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; <a class="el" href="classGio_1_1File.html#af483e2ddc29cbb6cd1ad751403247bad">Gio::File::replace_readwrite</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy of the file first. </p>
<p>If the file doesn't exist, it will be created.</p>
<p>For details about the behaviour, see <a class="el" href="classGio_1_1File.html#ad7cf0360096504e40f799fde5cc8e9de" title="Returns an output stream for overwriting the file, possibly creating a backup copy of the file first...">replace()</a> which does the same thing but returns an output stream only.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">etag</td><td>An optional entity tag for the current Glib::File. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a>.</dd></dl>

</div>
</div>
<a class="anchor" id="a0c4aa84e74b27a67bce6b5fdccb91449"></a><!-- doxytag: member="Gio::File::replace_readwrite" ref="a0c4aa84e74b27a67bce6b5fdccb91449" args="(const std::string &amp;etag=std::string(), bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; <a class="el" href="classGio_1_1File.html#af483e2ddc29cbb6cd1ad751403247bad">Gio::File::replace_readwrite</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy of the file first. </p>
<p>If the file doesn't exist, it will be created.</p>
<p>For details about the behaviour, see <a class="el" href="classGio_1_1File.html#ad7cf0360096504e40f799fde5cc8e9de" title="Returns an output stream for overwriting the file, possibly creating a backup copy of the file first...">replace()</a> which does the same thing but returns an output stream only.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">etag</td><td>An optional entity tag for the current Glib::File. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file.">FileOutputStream</a>.</dd></dl>

</div>
</div>
<a class="anchor" id="af5ebbb5e33c0afd302add9863f2d8c24"></a><!-- doxytag: member="Gio::File::replace_readwrite_async" ref="af5ebbb5e33c0afd302add9863f2d8c24" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const std::string &amp;etag=std::string(), bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#af5ebbb5e33c0afd302add9863f2d8c24">Gio::File::replace_readwrite_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asyncronously overwrites the file in read-write mode, replacing the contents, possibly creating a backup copy of the file first. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#af483e2ddc29cbb6cd1ad751403247bad" title="Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy ...">replace_readwrite()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a5733a0911dcd0ccc20f1f54fb3378b18" title="Finishes an asynchronous file replace operation started with g_file_replace_readwrite_async().">replace_readwrite_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">etag</td><td>An entity tag for the current <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a>. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup of the existing file should be made. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38b7d1782f03a4d6a4dbf3be16321324"></a><!-- doxytag: member="Gio::File::replace_readwrite_async" ref="a38b7d1782f03a4d6a4dbf3be16321324" args="(const SlotAsyncReady &amp;slot, const std::string &amp;etag=std::string(), bool make_backup=false, FileCreateFlags flags=FILE_CREATE_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#af5ebbb5e33c0afd302add9863f2d8c24">Gio::File::replace_readwrite_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga500a44e123fd4c578f8af9ddef2f7601aa91626c845b45a4432c5c5be9f62db63">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asyncronously overwrites the file in read-write mode, replacing the contents, possibly creating a backup copy of the file first. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#af483e2ddc29cbb6cd1ad751403247bad" title="Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy ...">replace_readwrite()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a5733a0911dcd0ccc20f1f54fb3378b18" title="Finishes an asynchronous file replace operation started with g_file_replace_readwrite_async().">replace_readwrite_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">etag</td><td>An entity tag for the current <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a>. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup of the existing file should be made. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5733a0911dcd0ccc20f1f54fb3378b18"></a><!-- doxytag: member="Gio::File::replace_readwrite_finish" ref="a5733a0911dcd0ccc20f1f54fb3378b18" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; <a class="el" href="classGio_1_1File.html#a5733a0911dcd0ccc20f1f54fb3378b18">Gio::File::replace_readwrite_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous file replace operation started with g_file_replace_readwrite_async(). </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000028">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file.">FileIOStream</a>, or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="ac5e286d421c7236df39881f8ce0a4e03"></a><!-- doxytag: member="Gio::File::resolve_relative_path" ref="ac5e286d421c7236df39881f8ce0a4e03" args="(const std::string &amp;relative_path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; <a class="el" href="classGio_1_1File.html#ac5e286d421c7236df39881f8ce0a4e03">Gio::File::resolve_relative_path</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>relative_path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resolves a relative path for <em>file</em> to an absolute path. </p>
<p>This call does no blocking i/o. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relative_path</td><td>A given relative path string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> to the resolved path. <code>0</code> if <em>relative_path</em> is <code>0</code> or if <em>file</em> is invalid. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a4f4373b8694c346a6908195f1f2644f3"></a><!-- doxytag: member="Gio::File::set_attribute_byte_string" ref="a4f4373b8694c346a6908195f1f2644f3" args="(const std::string &amp;attribute, const std::string &amp;value, FileQueryInfoFlags flags, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a4f4373b8694c346a6908195f1f2644f3">Gio::File::set_attribute_byte_string</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_BYTE_STRING to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail, returning <code>false</code>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A string containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a09f574259052186e1b516bdcbe696710"></a><!-- doxytag: member="Gio::File::set_attribute_byte_string" ref="a09f574259052186e1b516bdcbe696710" args="(const std::string &amp;attribute, const std::string &amp;value, FileQueryInfoFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a4f4373b8694c346a6908195f1f2644f3">Gio::File::set_attribute_byte_string</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_BYTE_STRING to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail, returning <code>false</code>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A string containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0290ecba7b06ccf7736e2292708667e"></a><!-- doxytag: member="Gio::File::set_attribute_int32" ref="ab0290ecba7b06ccf7736e2292708667e" args="(const std::string &amp;attribute, gint32 value, FileQueryInfoFlags flags, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#ab0290ecba7b06ccf7736e2292708667e">Gio::File::set_attribute_int32</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT32 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A #gint32 containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a707084a3c0a963548a21d17d0ec0b5"></a><!-- doxytag: member="Gio::File::set_attribute_int32" ref="a4a707084a3c0a963548a21d17d0ec0b5" args="(const std::string &amp;attribute, gint32 value, FileQueryInfoFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#ab0290ecba7b06ccf7736e2292708667e">Gio::File::set_attribute_int32</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT32 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A #gint32 containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a111d73a2d003e5a5a4c5f86c7c3d2fb7"></a><!-- doxytag: member="Gio::File::set_attribute_int64" ref="a111d73a2d003e5a5a4c5f86c7c3d2fb7" args="(const std::string &amp;attribute, gint64 value, FileQueryInfoFlags flags, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a111d73a2d003e5a5a4c5f86c7c3d2fb7">Gio::File::set_attribute_int64</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT64 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A #guint64 containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4477b0063110951b26c855696ec34802"></a><!-- doxytag: member="Gio::File::set_attribute_int64" ref="a4477b0063110951b26c855696ec34802" args="(const std::string &amp;attribute, gint64 value, FileQueryInfoFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a111d73a2d003e5a5a4c5f86c7c3d2fb7">Gio::File::set_attribute_int64</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT64 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A #guint64 containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ce5f43fd5e2836ac1989a54d3233ff6"></a><!-- doxytag: member="Gio::File::set_attribute_string" ref="a5ce5f43fd5e2836ac1989a54d3233ff6" args="(const std::string &amp;attribute, const std::string &amp;value, FileQueryInfoFlags flags, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a5ce5f43fd5e2836ac1989a54d3233ff6">Gio::File::set_attribute_string</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_STRING to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A string containing the attribute's value. </td></tr>
    <tr><td class="paramname">flags</td><td>FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a75fa7e1a44e97a910d232f2b4ab4bfdd"></a><!-- doxytag: member="Gio::File::set_attribute_string" ref="a75fa7e1a44e97a910d232f2b4ab4bfdd" args="(const std::string &amp;attribute, const std::string &amp;value, FileQueryInfoFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a5ce5f43fd5e2836ac1989a54d3233ff6">Gio::File::set_attribute_string</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_STRING to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A string containing the attribute's value. </td></tr>
    <tr><td class="paramname">flags</td><td>FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae53b0f4d2214e050a290c8e35cac0f27"></a><!-- doxytag: member="Gio::File::set_attribute_uint32" ref="ae53b0f4d2214e050a290c8e35cac0f27" args="(const std::string &amp;attribute, guint32 value, FileQueryInfoFlags flags, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#ae53b0f4d2214e050a290c8e35cac0f27">Gio::File::set_attribute_uint32</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT32 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A #guint32 containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f769f140143f2e96a7587a10b6792a9"></a><!-- doxytag: member="Gio::File::set_attribute_uint32" ref="a7f769f140143f2e96a7587a10b6792a9" args="(const std::string &amp;attribute, guint32 value, FileQueryInfoFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#ae53b0f4d2214e050a290c8e35cac0f27">Gio::File::set_attribute_uint32</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT32 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A #guint32 containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a48638081fd7af772a39af59a558b17f7"></a><!-- doxytag: member="Gio::File::set_attribute_uint64" ref="a48638081fd7af772a39af59a558b17f7" args="(const std::string &amp;attribute, guint64 value, FileQueryInfoFlags flags, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a48638081fd7af772a39af59a558b17f7">Gio::File::set_attribute_uint64</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT64 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A #guint64 containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4aa77b3580df88cfd3d7231af78155c7"></a><!-- doxytag: member="Gio::File::set_attribute_uint64" ref="a4aa77b3580df88cfd3d7231af78155c7" args="(const std::string &amp;attribute, guint64 value, FileQueryInfoFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a48638081fd7af772a39af59a558b17f7">Gio::File::set_attribute_uint64</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT64 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A #guint64 containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a14165fba9bf7d91448c3207407ae50c2"></a><!-- doxytag: member="Gio::File::set_attributes_async" ref="a14165fba9bf7d91448c3207407ae50c2" args="(const Glib::RefPtr&lt; FileInfo &gt; &amp;info, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a14165fba9bf7d91448c3207407ae50c2">Gio::File::set_attributes_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously sets the attributes of file with info. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a69d9e40a85b96809abc5189b34e8d9b7" title="Tries to set all attributes in the FileInfo on the target values, not stopping on the first error...">set_attributes_from_info()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#aefd45aed7b975b6e204e67927de2817a">set_attributes_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a>. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61317a1980318537aa8ada7bb8cc2390"></a><!-- doxytag: member="Gio::File::set_attributes_async" ref="a61317a1980318537aa8ada7bb8cc2390" args="(const Glib::RefPtr&lt; FileInfo &gt; &amp;info, const SlotAsyncReady &amp;slot, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a14165fba9bf7d91448c3207407ae50c2">Gio::File::set_attributes_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously sets the attributes of file with info. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a69d9e40a85b96809abc5189b34e8d9b7" title="Tries to set all attributes in the FileInfo on the target values, not stopping on the first error...">set_attributes_from_info()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#aefd45aed7b975b6e204e67927de2817a">set_attributes_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a>. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefd45aed7b975b6e204e67927de2817a"></a><!-- doxytag: member="Gio::File::set_attributes_finish" ref="aefd45aed7b975b6e204e67927de2817a" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, const Glib::RefPtr&lt; FileInfo &gt; &amp;info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#aefd45aed7b975b6e204e67927de2817a">Gio::File::set_attributes_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a69d9e40a85b96809abc5189b34e8d9b7"></a><!-- doxytag: member="Gio::File::set_attributes_from_info" ref="a69d9e40a85b96809abc5189b34e8d9b7" args="(const Glib::RefPtr&lt; FileInfo &gt; &amp;info, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a69d9e40a85b96809abc5189b34e8d9b7">Gio::File::set_attributes_from_info</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to set all attributes in the <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> on the target values, not stopping on the first error. </p>
<p>If there is any error during this operation then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown. <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Error</a> on particular fields are flagged by setting the "status" field in the attribute value to FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can also detect further errors.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if there was any error, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9f6975ffef28f0d7145601a99de0903"></a><!-- doxytag: member="Gio::File::set_attributes_from_info" ref="ae9f6975ffef28f0d7145601a99de0903" args="(const Glib::RefPtr&lt; FileInfo &gt; &amp;info, FileQueryInfoFlags flags=FILE_QUERY_INFO_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a69d9e40a85b96809abc5189b34e8d9b7">Gio::File::set_attributes_from_info</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga2cb7bdea61353f0999607785abd032c0a25937649b891bc6e25fd3b102e961fa0">FILE_QUERY_INFO_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to set all attributes in the <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a> on the target values, not stopping on the first error. </p>
<p>If there is any error during this operation then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown. <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Error</a> on particular fields are flagged by setting the "status" field in the attribute value to FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can also detect further errors.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes.">FileInfo</a>. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if there was any error, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3dd75810d7c9ebafac398288f5afc018"></a><!-- doxytag: member="Gio::File::set_display_name" ref="a3dd75810d7c9ebafac398288f5afc018" args="(const Glib::ustring &amp;display_name, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; <a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018">Gio::File::set_display_name</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>display_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renames <em>file</em> to the specified display name. </p>
<p>The display name is converted from UTF8 to the correct encoding for the target filesystem if possible and the <em>file</em> is renamed to this.</p>
<p>If you want to implement a rename operation in the user interface the edit name (FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the initial value in the rename widget, and then the result after editing should be passed to g_file_set_display_name().</p>
<p>On success the resulting converted filename is returned.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">display_name</td><td>A string. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> specifying what <em>file</em> was renamed to, or <code>0</code> if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c2aa80b2d0ecdd22f0222c8ce42d177"></a><!-- doxytag: member="Gio::File::set_display_name" ref="a8c2aa80b2d0ecdd22f0222c8ce42d177" args="(const Glib::ustring &amp;display_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; <a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018">Gio::File::set_display_name</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>display_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renames the file to the specified display name. </p>
<p>The display name is converted from UTF8 to the correct encoding for the target filesystem if possible and the file is renamed to this.</p>
<p>If you want to implement a rename operation in the user interface the edit name (G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the initial value in the rename widget, and then the result after editing should be passed to <a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018" title="Renames file to the specified display name.">set_display_name()</a>.</p>
<p>On success the resulting converted filename is returned.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">display_name</td><td>A string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A Glib::File specifying what the file was renamed to, or an empty RefPtr if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ac539d7758b9c0de809f8c83e0bba79"></a><!-- doxytag: member="Gio::File::set_display_name_async" ref="a0ac539d7758b9c0de809f8c83e0bba79" args="(const Glib::ustring &amp;display_name, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a0ac539d7758b9c0de809f8c83e0bba79">Gio::File::set_display_name_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>display_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously sets the display name for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a>. </p>
<p>For the synchronous version of this function, see <a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018" title="Renames file to the specified display name.">set_display_name()</a>. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a101b555723233014c0185dd505303f0a" title="Finishes setting a display name started with g_file_set_display_name_async().">set_display_name_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">display_name</td><td>A string. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74d219d321dca3d438f876256dee82d2"></a><!-- doxytag: member="Gio::File::set_display_name_async" ref="a74d219d321dca3d438f876256dee82d2" args="(const Glib::ustring &amp;display_name, const SlotAsyncReady &amp;slot, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a0ac539d7758b9c0de809f8c83e0bba79">Gio::File::set_display_name_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>display_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously sets the display name for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling.">Gio::File</a>. </p>
<p>For the synchronous version of this function, see <a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018" title="Renames file to the specified display name.">set_display_name()</a>. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a101b555723233014c0185dd505303f0a" title="Finishes setting a display name started with g_file_set_display_name_async().">set_display_name_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">display_name</td><td>A string. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a101b555723233014c0185dd505303f0a"></a><!-- doxytag: member="Gio::File::set_display_name_finish" ref="a101b555723233014c0185dd505303f0a" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; <a class="el" href="classGio_1_1File.html#a101b555723233014c0185dd505303f0a">Gio::File::set_display_name_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes setting a display name started with g_file_set_display_name_async(). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="aa4438daeeb2171e3065bb677b6768721"></a><!-- doxytag: member="Gio::File::start_mountable" ref="aa4438daeeb2171e3065bb677b6768721" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const Glib::RefPtr&lt; MountOperation &gt; &amp;start_operation, DriveStartFlags flags=DRIVE_START_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#aa4438daeeb2171e3065bb677b6768721">Gio::File::start_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>start_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gab628e70b1d028b3bc9b02b0d3b8acf2d">DriveStartFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggab628e70b1d028b3bc9b02b0d3b8acf2da6a46299fc0a721de0bed46063ba484de">DRIVE_START_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#af11e51943807876180474b39d2e521ac" title="Finishes a start operation.">start_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot,:</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad629eaf059b2e05b1f9bfc10c5732974"></a><!-- doxytag: member="Gio::File::start_mountable" ref="ad629eaf059b2e05b1f9bfc10c5732974" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; MountOperation &gt; &amp;start_operation, DriveStartFlags flags=DRIVE_START_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#aa4438daeeb2171e3065bb677b6768721">Gio::File::start_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>start_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gab628e70b1d028b3bc9b02b0d3b8acf2d">DriveStartFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggab628e70b1d028b3bc9b02b0d3b8acf2da6a46299fc0a721de0bed46063ba484de">DRIVE_START_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#af11e51943807876180474b39d2e521ac" title="Finishes a start operation.">start_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot,:</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af11e51943807876180474b39d2e521ac"></a><!-- doxytag: member="Gio::File::start_mountable_finish" ref="af11e51943807876180474b39d2e521ac" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#af11e51943807876180474b39d2e521ac">Gio::File::start_mountable_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes a start operation. </p>
<p>See g_file_start_mountable() for details.</p>
<p>Finish an asynchronous start operation that was started with g_file_start_mountable().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000031">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the operation finished successfully. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac101831f87245a881c338014f15d38d8"></a><!-- doxytag: member="Gio::File::stop_mountable" ref="ac101831f87245a881c338014f15d38d8" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const Glib::RefPtr&lt; MountOperation &gt; &amp;start_operation, MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#ac101831f87245a881c338014f15d38d8">Gio::File::stop_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>start_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#a195990af8825745d0d26147174824565" title="Finishes an stop operation, see g_file_stop_mountable() for details.">stop_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot,:</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ccfb3006c2bc69a32e5055939b462d6"></a><!-- doxytag: member="Gio::File::stop_mountable" ref="a5ccfb3006c2bc69a32e5055939b462d6" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; MountOperation &gt; &amp;start_operation, MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#ac101831f87245a881c338014f15d38d8">Gio::File::stop_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>start_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#a195990af8825745d0d26147174824565" title="Finishes an stop operation, see g_file_stop_mountable() for details.">stop_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot,:</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">start_operation</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a195990af8825745d0d26147174824565"></a><!-- doxytag: member="Gio::File::stop_mountable_finish" ref="a195990af8825745d0d26147174824565" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a195990af8825745d0d26147174824565">Gio::File::stop_mountable_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an stop operation, see g_file_stop_mountable() for details. </p>
<p>Finish an asynchronous stop operation that was started with g_file_stop_mountable().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000032">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the operation finished successfully. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab666a9ec3922903646504f4080758522"></a><!-- doxytag: member="Gio::File::supports_thread_contexts" ref="ab666a9ec3922903646504f4080758522" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#ab666a9ec3922903646504f4080758522">Gio::File::supports_thread_contexts</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if <em>file</em> supports thread-default contexts. </p>
<p>If this returns <code>false</code>, you cannot perform asynchronous operations on <em>file</em> in a thread that has a thread-default context.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000038">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether or not <em>file</em> supports thread-default contexts. </dd></dl>

</div>
</div>
<a class="anchor" id="acae5ecd962e832cf8d538877f4118da8"></a><!-- doxytag: member="Gio::File::trash" ref="acae5ecd962e832cf8d538877f4118da8" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#acae5ecd962e832cf8d538877f4118da8">Gio::File::trash</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends <em>file</em> to the "Trashcan", if possible. </p>
<p>This is similar to deleting it, but the user can recover it before emptying the trashcan. Not all file systems support trashing, so this call can throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_SUPPORTED.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on successful trash, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1925736f9af338eaf9942468b4d6d65e"></a><!-- doxytag: member="Gio::File::trash" ref="a1925736f9af338eaf9942468b4d6d65e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#acae5ecd962e832cf8d538877f4118da8">Gio::File::trash</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends the file to the "Trashcan", if possible. </p>
<p>This is similar to deleting it, but the user can recover it before emptying the trashcan. Not all filesystems support trashing, so this call can throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with NOT_SUPPORTED.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on successful trash, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b687c8f19411e955bb069c469be92b4"></a><!-- doxytag: member="Gio::File::unmount_mountable" ref="a5b687c8f19411e955bb069c469be92b4" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a5b687c8f19411e955bb069c469be92b4">Gio::File::unmount_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d" title="Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details.">unmount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6c8e9ef0e5d83a271c8307b18e779d8"></a><!-- doxytag: member="Gio::File::unmount_mountable" ref="ab6c8e9ef0e5d83a271c8307b18e779d8" args="(const SlotAsyncReady &amp;slot, MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a5b687c8f19411e955bb069c469be92b4">Gio::File::unmount_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d" title="Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details.">unmount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95f3e87e198493f4332a08aa79f6ebd3"></a><!-- doxytag: member="Gio::File::unmount_mountable" ref="a95f3e87e198493f4332a08aa79f6ebd3" args="(MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a5b687c8f19411e955bb069c469be92b4">Gio::File::unmount_mountable</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13f7cceb9754a7498789593dd58d818c"></a><!-- doxytag: member="Gio::File::unmount_mountable" ref="a13f7cceb9754a7498789593dd58d818c" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const Glib::RefPtr&lt; MountOperation &gt; &amp;mount_operation, MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a5b687c8f19411e955bb069c469be92b4">Gio::File::unmount_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d" title="Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details.">unmount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations.">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad82d5b087fef21cbadcb9407d7f43223"></a><!-- doxytag: member="Gio::File::unmount_mountable" ref="ad82d5b087fef21cbadcb9407d7f43223" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; MountOperation &gt; &amp;mount_operation, MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a5b687c8f19411e955bb069c469be92b4">Gio::File::unmount_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d" title="Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details.">unmount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations.">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae322b2d5f8f1d95023831c3964c9b015"></a><!-- doxytag: member="Gio::File::unmount_mountable" ref="ae322b2d5f8f1d95023831c3964c9b015" args="(const Glib::RefPtr&lt; MountOperation &gt; &amp;mount_operation, MountUnmountFlags flags=MOUNT_UNMOUNT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1File.html#a5b687c8f19411e955bb069c469be92b4">Gio::File::unmount_mountable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga9fa1b6a8eabf8f88e4cf6d611a4cff44a30cece3099822da07d5d74cc97fa4ad4">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations.">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51458cf04ad25e4a784a3ebcb906155d"></a><!-- doxytag: member="Gio::File::unmount_mountable_finish" ref="a51458cf04ad25e4a784a3ebcb906155d" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d">Gio::File::unmount_mountable_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details. </p>
<p>Finish an asynchronous unmount operation that was started with g_file_unmount_mountable_with_operation().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000029">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the operation finished successfully. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a69670cdc7cf63783d6f9370dcbd7cc3d"></a><!-- doxytag: member="Gio::File::wrap" ref="a69670cdc7cf63783d6f9370dcbd7cc3d" args="(GFile *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">Gio::File</a> &gt; <a class="el" href="classGio_1_1File.html#a69670cdc7cf63783d6f9370dcbd7cc3d">wrap</a> </td>
          <td>(</td>
          <td class="paramtype">GFile *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 10 2012 14:20:37 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
