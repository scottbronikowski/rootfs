<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>glibmm: Glib::IOChannel Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="/home/murrayc/checkouts/gnome30/glibmm/docs/doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.32.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceGlib.html">Glib</a> </li>
      <li class="navelem"><a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a> </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> </div>
  <div class="headertitle">
<div class="title">Glib::IOChannel Class Reference</div> </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Glib::IOChannel" --><!-- doxytag: inherits="sigc::trackable" -->
<p><a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> aims to provide portable I/O support for files, pipes and sockets, and to integrate them with the GLib main event loop.  <a href="classGlib_1_1IOChannel.html#details">More...</a></p>

<p><code>#include &lt;glibmm/iochannel.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Glib::IOChannel:</div>
<div class="dyncontent">
<div class="center"><img src="classGlib_1_1IOChannel__inherit__graph.png" border="0" usemap="#Glib_1_1IOChannel_inherit__map" alt="Inheritance graph"/></div>
<map name="Glib_1_1IOChannel_inherit__map" id="Glib_1_1IOChannel_inherit__map">
<area shape="rect" id="node5" href="classGlib_1_1StreamIOChannel.html" title="Glib::StreamIOChannel" alt="" coords="5,160,171,189"/><area shape="rect" id="node2" href="../../../libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="31,5,145,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGlib_1_1IOChannel-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a0a6c1cddcf00c77c6ab99b096c86544f">~IOChannel</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ae5878a4510f52f194f18c0743f6a9b5c">read</a> (gunichar&amp; thechar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single UCS-4 character. <a href="#ae5878a4510f52f194f18c0743f6a9b5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a1afb78d2e29a2f01a7034279a0c12636">read</a> (char* buf, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, gsize&amp; bytes_read)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a character sequence into memory. <a href="#a1afb78d2e29a2f01a7034279a0c12636"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a4553088deea02ebea2ab7a9e2cff0a1c">read</a> (<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; str, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a maximum of <em>count</em> bytes into <em>str</em>. <a href="#a4553088deea02ebea2ab7a9e2cff0a1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a2950510fff168d5753ee1eb14714d67a">read_line</a> (<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; line)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a whole line. <a href="#a2950510fff168d5753ee1eb14714d67a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a0d64e84ab360b3c83399c94076487df1">read_to_end</a> (<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; str)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all the remaining data from the file. <a href="#a0d64e84ab360b3c83399c94076487df1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#acacb5599be21f549911c6aca5f820fcf">write</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; str)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a string to the I/O channel. <a href="#acacb5599be21f549911c6aca5f820fcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a29114ed2bcb64b8af551271394968528">write</a> (const char* buf, gssize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, gsize&amp; bytes_written)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a memory area of <em>count</em> bytes to the I/O channel. <a href="#a29114ed2bcb64b8af551271394968528"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a5e0a187ff012b3b90c6d3d8593c18e92">write</a> (gunichar unichar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single UCS-4 character to the I/O channel. <a href="#a5e0a187ff012b3b90c6d3d8593c18e92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a65a5048c32ecde11827b5ae1973ee0b1">seek</a> (gint64 offset, <a class="el" href="group__glibmmEnums.html#gaa3767731311bdba4ef42dc99215e5cda">SeekType</a> <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01612.html#ga2c2933c16c723af4d77eb939438617ca">type</a>=<a class="el" href="group__glibmmEnums.html#ggaa3767731311bdba4ef42dc99215e5cdaa1e0d3b4a03e5dd32f135acc89982889f">SEEK_TYPE_SET</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek the I/O channel to a specific position. <a href="#a65a5048c32ecde11827b5ae1973ee0b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#aba6702093bd1c58ea22231446ed2f6e4">flush</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the buffers of the I/O channel. <a href="#aba6702093bd1c58ea22231446ed2f6e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a6affd4b4cbeeefe4965544f762922c35">close</a> (bool <a class="el" href="classGlib_1_1IOChannel.html#aba6702093bd1c58ea22231446ed2f6e4">flush</a>=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the I/O channel. <a href="#a6affd4b4cbeeefe4965544f762922c35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a2f5c5979ad729df9524fcb1940e5d2fe">get_buffer_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> internal buffer size. <a href="#a2f5c5979ad729df9524fcb1940e5d2fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a535767c92f2678e5e72051f6f4bc5326">set_buffer_size</a> (gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01616.html#ga445a43f417432dd1b9aed90ef239c700">size</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> buffer size. <a href="#a535767c92f2678e5e72051f6f4bc5326"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#gaee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ac15e424b863d398ed458315b7f799243">get_flags</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current flags for a <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a>, including read-only flags such as <a class="el" href="group__glibmmEnums.html#ggaee093e5db5bc1ea5738771ba0d1af3b7a162bfe5ccb18465d0f11e954cc4a89d9">Glib::IO_FLAG_IS_READABLE</a>. <a href="#ac15e424b863d398ed458315b7f799243"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ab6c16c87c174d836247f47c2b87539fd">set_flags</a> (<a class="el" href="group__glibmmEnums.html#gaee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flags on the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a>. <a href="#ab6c16c87c174d836247f47c2b87539fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#abaf37b0d76cd41628fd0c41a674495de">set_buffered</a> (bool buffered)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buffering status of the I/O channel. <a href="#abaf37b0d76cd41628fd0c41a674495de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a3013c245f30ca81e11c01f8a031b1745">get_buffered</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffering status of the I/O channel. <a href="#a3013c245f30ca81e11c01f8a031b1745"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">IOCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a9ba943e998468e3b86d841c5aec8a551">get_buffer_condition</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an IOCondition depending on whether there is data to be read/space to write data in the internal buffers in the I/O channel. <a href="#a9ba943e998468e3b86d841c5aec8a551"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ac93b128c8ee396702b2a20c5a060949d">get_close_on_unref</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the file/socket/whatever associated with the I/O channel will be closed when the channel receives its final unref and is destroyed. <a href="#ac93b128c8ee396702b2a20c5a060949d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a3f4fbc2a4c3670863fbf504d7fc96253">set_close_on_unref</a> (bool do_close)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting this flag to <code>true</code> for a channel you have already closed can cause problems. <a href="#a3f4fbc2a4c3670863fbf504d7fc96253"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ab1d3ae667bd425ef830929a67cf526e0">set_encoding</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; encoding=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the encoding for the input/output of the channel. <a href="#ab1d3ae667bd425ef830929a67cf526e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ae52a79ec5f3acc2b0990870668c4ea2a">get_encoding</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the encoding of the I/O channel. <a href="#ae52a79ec5f3acc2b0990870668c4ea2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ad42d03bdd0288cf5517737a73f7268b3">set_line_term</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; term=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#afd08e7a2a6cbfbdad2ef599c9eadcc01">get_line_term</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a755c88fe8c78dc0727b5686fc62b736c">create_watch</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">IOCondition</a> condition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> object. <a href="#a755c88fe8c78dc0727b5686fc62b736c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#aa63e3a39347848387cd9422d0073a7be">reference</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a4c57bf6b00844fc3ddb9d0e60cac7dcf">unreference</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GIOChannel*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ab05ed8535a51b04749e11386c845a581">gobj</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GIOChannel*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#aad550f12d9d2ec2fef0a2c7ba78f2595">gobj</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ac175ea1fd6ef84ac3758ca57b42b7f33">create_from_file</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; filename, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; mode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file <em>filename</em> as an I/O channel using mode <em>mode</em>. <a href="#ac175ea1fd6ef84ac3758ca57b42b7f33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a078698e18f61bb75fe3fd33d82970f5d">create_from_fd</a> (int fd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an I/O channel from a file descriptor. <a href="#a078698e18f61bb75fe3fd33d82970f5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a1a22bd01752d233c23babdef800c0d87">create_from_win32_fd</a> (int fd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an I/O channel for C runtime (emulated Unix-like) file descriptors. <a href="#a1a22bd01752d233c23babdef800c0d87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a087946554b86d42f1cd72277fd1b0530">create_from_win32_socket</a> (int socket)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an I/O channel for a winsock socket. <a href="#a087946554b86d42f1cd72277fd1b0530"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#aded3d9a998914bcac0b3f1aef1eeb974">IOChannel</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that should be used by derived classes. <a href="#aded3d9a998914bcac0b3f1aef1eeb974"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#abfb4faa07e80b86f21b0f18f0b8606cd">read_vfunc</a> (char* buf, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, gsize&amp; bytes_read)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a4ed5372da9d4ad3465012fc2317507b5">write_vfunc</a> (const char* buf, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, gsize&amp; bytes_written)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a781de88aec2c032d05f74402779665f3">seek_vfunc</a> (gint64 offset, <a class="el" href="group__glibmmEnums.html#gaa3767731311bdba4ef42dc99215e5cda">SeekType</a> <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01612.html#ga2c2933c16c723af4d77eb939438617ca">type</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a735b70808acbb542b04bf55b0133927e">close_vfunc</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#af8f690f1e0a8945b75ad7be4949e44cf">set_flags_vfunc</a> (<a class="el" href="group__glibmmEnums.html#gaee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#gaee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ae3326db3877358b563de11fb3dd8367f">get_flags_vfunc</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGlib_1_1Source.html">Glib::Source</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a128f2bfd977617a6a1a7e4a7fbe6aa5b">create_watch_vfunc</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">IOCondition</a> cond)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GIOChannel*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a6683e47c0d78492b83d7021288d9b6d0">gobject_</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> aims to provide portable I/O support for files, pipes and sockets, and to integrate them with the GLib main event loop. </p>
<p>Note that IOChannels implement an automatic implicit character set conversion to the data stream, and usually will not pass by default binary data unchanged. To set the encoding of the channel, use e.g. set_encoding("ISO-8859-15"). To set the channel to no encoding, use <a class="el" href="classGlib_1_1IOChannel.html#ab1d3ae667bd425ef830929a67cf526e0" title="Sets the encoding for the input/output of the channel.">set_encoding()</a> without any arguments.</p>
<p>You can create an <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> with one of the static create methods, or implement one yourself, in which case you have to 1)&#160;override all _vfunc() members. 2)&#160;set the GIOChannel flags in your constructor.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This feature of being able to implement a custom <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">Glib::IOChannel</a> is deprecated in glibmm&#160;2.2. The vfunc interface has not yet stabilized enough to allow that -- the C++ wrapper went in by pure accident. Besides, it isn't terribly useful either. Thus please refrain from overriding any <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> vfuncs. </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0a6c1cddcf00c77c6ab99b096c86544f"></a><!-- doxytag: member="Glib::IOChannel::~IOChannel" ref="a0a6c1cddcf00c77c6ab99b096c86544f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGlib_1_1IOChannel.html#a0a6c1cddcf00c77c6ab99b096c86544f">Glib::IOChannel::~IOChannel</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aded3d9a998914bcac0b3f1aef1eeb974"></a><!-- doxytag: member="Glib::IOChannel::IOChannel" ref="aded3d9a998914bcac0b3f1aef1eeb974" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1IOChannel.html#aded3d9a998914bcac0b3f1aef1eeb974">Glib::IOChannel::IOChannel</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor that should be used by derived classes. </p>
<p>Use this constructor if you want to inherit from <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a>. It will set up a GIOChannel that will call the vfuncs of your class even if it is being used from C code, and it will keep a reference to the C++ code while the GIOChannel exists. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a6affd4b4cbeeefe4965544f762922c35"></a><!-- doxytag: member="Glib::IOChannel::close" ref="a6affd4b4cbeeefe4965544f762922c35" args="(bool flush=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#a6affd4b4cbeeefe4965544f762922c35">Glib::IOChannel::close</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close the I/O channel. </p>
<p>Any pending data to be written will be flushed if <em>flush</em> is <code>true</code>. The channel will not be freed until the last reference is dropped. Accessing the channel after closing it is considered an error. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flush</td><td>Whether to <a class="el" href="classGlib_1_1IOChannel.html#aba6702093bd1c58ea22231446ed2f6e4" title="Flush the buffers of the I/O channel.">flush()</a> pending data before closing the channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a735b70808acbb542b04bf55b0133927e"></a><!-- doxytag: member="Glib::IOChannel::close_vfunc" ref="a735b70808acbb542b04bf55b0133927e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#a735b70808acbb542b04bf55b0133927e">Glib::IOChannel::close_vfunc</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#a20deabe6a3bc6b1488975375e61af626">Glib::StreamIOChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a078698e18f61bb75fe3fd33d82970f5d"></a><!-- doxytag: member="Glib::IOChannel::create_from_fd" ref="a078698e18f61bb75fe3fd33d82970f5d" args="(int fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>&gt; <a class="el" href="classGlib_1_1IOChannel.html#a078698e18f61bb75fe3fd33d82970f5d">Glib::IOChannel::create_from_fd</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an I/O channel from a file descriptor. </p>
<p>On Unix, IOChannels created with this function work for any file descriptor or socket.</p>
<p>On Win32, this can be used either for files opened with the MSVCRT (the Microsoft run-time C library) <code>_open()</code> or <code>_pipe()</code>, including file descriptors 0, 1 and 2 (corresponding to <code>stdin</code>, <code>stdout</code> and <code>stderr</code>), or for Winsock <code>SOCKET</code>s. If the parameter is a legal file descriptor, it is assumed to be such, otherwise it should be a <code>SOCKET</code>. This relies on <code>SOCKET</code>s and file descriptors not overlapping. If you want to be certain, call either <a class="el" href="classGlib_1_1IOChannel.html#a1a22bd01752d233c23babdef800c0d87" title="Create an I/O channel for C runtime (emulated Unix-like) file descriptors.">create_from_win32_fd()</a> or <a class="el" href="classGlib_1_1IOChannel.html#a087946554b86d42f1cd72277fd1b0530" title="Create an I/O channel for a winsock socket.">create_from_win32_socket()</a> instead as appropriate.</p>
<p>The term file descriptor as used in the context of Win32 refers to the emulated Unix-like file descriptors MSVCRT provides. The native corresponding concept is file <code>HANDLE</code>. There isn't as of yet a way to get IOChannels for Win32 file <code>HANDLE</code>s. </p>

</div>
</div>
<a class="anchor" id="ac175ea1fd6ef84ac3758ca57b42b7f33"></a><!-- doxytag: member="Glib::IOChannel::create_from_file" ref="ac175ea1fd6ef84ac3758ca57b42b7f33" args="(const std::string &amp;filename, const std::string &amp;mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>&gt; <a class="el" href="classGlib_1_1IOChannel.html#ac175ea1fd6ef84ac3758ca57b42b7f33">Glib::IOChannel::create_from_file</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a file <em>filename</em> as an I/O channel using mode <em>mode</em>. </p>
<p>This channel will be closed when the last reference to it is dropped, so there is no need to call <a class="el" href="classGlib_1_1IOChannel.html#a6affd4b4cbeeefe4965544f762922c35" title="Close the I/O channel.">close()</a> (though doing so will not cause problems, as long as no attempt is made to access the channel after it is closed). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to open. </td></tr>
    <tr><td class="paramname">mode</td><td>One of <code>"r"</code>, <code>"w"</code>, <code>"a"</code>, <code>"r+"</code>, <code>"w+"</code>, <code>"a+"</code>. These have the same meaning as in <code>fopen()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> for the opened file. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1FileError.html" title="Exception class for file-related errors.">Glib::FileError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a22bd01752d233c23babdef800c0d87"></a><!-- doxytag: member="Glib::IOChannel::create_from_win32_fd" ref="a1a22bd01752d233c23babdef800c0d87" args="(int fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>&gt; <a class="el" href="classGlib_1_1IOChannel.html#a1a22bd01752d233c23babdef800c0d87">Glib::IOChannel::create_from_win32_fd</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an I/O channel for C runtime (emulated Unix-like) file descriptors. </p>
<p>After calling add_watch() on a I/O channel returned by this function, you shouldn't call <a class="el" href="classGlib_1_1IOChannel.html#ae5878a4510f52f194f18c0743f6a9b5c" title="Read a single UCS-4 character.">read()</a> on the file descriptor. This is because adding polling for a file descriptor is implemented on Win32 by starting a thread that sits blocked in a <code>read()</code> from the file descriptor most of the time. All reads from the file descriptor should be done by this internal GLib thread. Your code should call only <a class="el" href="classGlib_1_1IOChannel.html#ae5878a4510f52f194f18c0743f6a9b5c" title="Read a single UCS-4 character.">IOChannel::read()</a>. </p>

</div>
</div>
<a class="anchor" id="a087946554b86d42f1cd72277fd1b0530"></a><!-- doxytag: member="Glib::IOChannel::create_from_win32_socket" ref="a087946554b86d42f1cd72277fd1b0530" args="(int socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>&gt; <a class="el" href="classGlib_1_1IOChannel.html#a087946554b86d42f1cd72277fd1b0530">Glib::IOChannel::create_from_win32_socket</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an I/O channel for a winsock socket. </p>
<p>The parameter should be a <code>SOCKET</code>. Contrary to I/O channels for file descriptors (on Win32), you can use normal <code>recv()</code> or <code>recvfrom()</code> on sockets even if GLib is polling them. </p>

</div>
</div>
<a class="anchor" id="a755c88fe8c78dc0727b5686fc62b736c"></a><!-- doxytag: member="Glib::IOChannel::create_watch" ref="a755c88fe8c78dc0727b5686fc62b736c" args="(IOCondition condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOSource.html">IOSource</a>&gt; <a class="el" href="classGlib_1_1IOChannel.html#a755c88fe8c78dc0727b5686fc62b736c">Glib::IOChannel::create_watch</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">IOCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> object. </p>
<p>Create a slot from a function to be called when condition is met for the channel with <a class="elRef" href="../../../libsigc++-2.0/reference/html/group__ptr__fun.html#ga9c80de72f656fb05e81fda622dddc863">sigc::ptr_fun()</a> or <a class="elRef" href="../../../libsigc++-2.0/reference/html/group__mem__fun.html#ga52244864d2f65f072678b682bfc9913f">sigc::mem_fun()</a> and pass it into the connect() function of the returned <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> object. Polling of the channel will start when you attach a <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a> object to the returned <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> object using its attach() function.</p>
<p><a class="el" href="group__MainLoop.html#gaf391654b755a32169d18be4835677376" title="Convenience I/O signal.">Glib::signal_io()</a>.connect() is a simpler interface to the same functionality, for the case where you want to add the source to the default main context. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>The condition to watch for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> object that can be polled from a <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a>'s event loop. </dd></dl>

</div>
</div>
<a class="anchor" id="a128f2bfd977617a6a1a7e4a7fbe6aa5b"></a><!-- doxytag: member="Glib::IOChannel::create_watch_vfunc" ref="a128f2bfd977617a6a1a7e4a7fbe6aa5b" args="(IOCondition cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1Source.html">Glib::Source</a>&gt; <a class="el" href="classGlib_1_1IOChannel.html#a128f2bfd977617a6a1a7e4a7fbe6aa5b">Glib::IOChannel::create_watch_vfunc</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">IOCondition</a>&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#a77595f06e524cd2cb3dc7958fd274f4f">Glib::StreamIOChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aba6702093bd1c58ea22231446ed2f6e4"></a><!-- doxytag: member="Glib::IOChannel::flush" ref="aba6702093bd1c58ea22231446ed2f6e4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#aba6702093bd1c58ea22231446ed2f6e4">Glib::IOChannel::flush</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush the buffers of the I/O channel. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ba943e998468e3b86d841c5aec8a551"></a><!-- doxytag: member="Glib::IOChannel::get_buffer_condition" ref="a9ba943e998468e3b86d841c5aec8a551" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">IOCondition</a> <a class="el" href="classGlib_1_1IOChannel.html#a9ba943e998468e3b86d841c5aec8a551">Glib::IOChannel::get_buffer_condition</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an IOCondition depending on whether there is data to be read/space to write data in the internal buffers in the I/O channel. </p>
<p>Only the flags <a class="el" href="group__glibmmEnums.html#ggabd96381793b70d4ae32c725926990918af244f3e8c1c9525762f3630befd76336">Glib::IO_IN</a> and <a class="el" href="group__glibmmEnums.html#ggabd96381793b70d4ae32c725926990918a60f61c8f26f2bb61afd3ad8afd673099">Glib::IO_OUT</a> may be set. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Bitwise combination of <a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918" title="A bitwise combination representing an I/O condition to watch for on an event source.">Glib::IOCondition</a> flags. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f5c5979ad729df9524fcb1940e5d2fe"></a><!-- doxytag: member="Glib::IOChannel::get_buffer_size" ref="a2f5c5979ad729df9524fcb1940e5d2fe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsize <a class="el" href="classGlib_1_1IOChannel.html#a2f5c5979ad729df9524fcb1940e5d2fe">Glib::IOChannel::get_buffer_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> internal buffer size. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The buffer size. </dd></dl>

</div>
</div>
<a class="anchor" id="a3013c245f30ca81e11c01f8a031b1745"></a><!-- doxytag: member="Glib::IOChannel::get_buffered" ref="a3013c245f30ca81e11c01f8a031b1745" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGlib_1_1IOChannel.html#a3013c245f30ca81e11c01f8a031b1745">Glib::IOChannel::get_buffered</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the buffering status of the I/O channel. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The buffering status of the channel. </dd></dl>

</div>
</div>
<a class="anchor" id="ac93b128c8ee396702b2a20c5a060949d"></a><!-- doxytag: member="Glib::IOChannel::get_close_on_unref" ref="ac93b128c8ee396702b2a20c5a060949d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGlib_1_1IOChannel.html#ac93b128c8ee396702b2a20c5a060949d">Glib::IOChannel::get_close_on_unref</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the file/socket/whatever associated with the I/O channel will be closed when the channel receives its final unref and is destroyed. </p>
<p>The default value of this is <code>true</code> for channels created by <a class="el" href="classGlib_1_1IOChannel.html#ac175ea1fd6ef84ac3758ca57b42b7f33" title="Open a file filename as an I/O channel using mode mode.">create_from_file()</a>, and <code>false</code> for all other channels. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the channel will be closed on the final unref of the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="ae52a79ec5f3acc2b0990870668c4ea2a"></a><!-- doxytag: member="Glib::IOChannel::get_encoding" ref="ae52a79ec5f3acc2b0990870668c4ea2a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> <a class="el" href="classGlib_1_1IOChannel.html#ae52a79ec5f3acc2b0990870668c4ea2a">Glib::IOChannel::get_encoding</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the encoding of the I/O channel. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current encoding of the channel. </dd></dl>

</div>
</div>
<a class="anchor" id="ac15e424b863d398ed458315b7f799243"></a><!-- doxytag: member="Glib::IOChannel::get_flags" ref="ac15e424b863d398ed458315b7f799243" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#gaee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a> <a class="el" href="classGlib_1_1IOChannel.html#ac15e424b863d398ed458315b7f799243">Glib::IOChannel::get_flags</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current flags for a <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a>, including read-only flags such as <a class="el" href="group__glibmmEnums.html#ggaee093e5db5bc1ea5738771ba0d1af3b7a162bfe5ccb18465d0f11e954cc4a89d9">Glib::IO_FLAG_IS_READABLE</a>. </p>
<p>The values of the flags <a class="el" href="group__glibmmEnums.html#ggaee093e5db5bc1ea5738771ba0d1af3b7a162bfe5ccb18465d0f11e954cc4a89d9">Glib::IO_FLAG_IS_READABLE</a> and <a class="el" href="group__glibmmEnums.html#ggaee093e5db5bc1ea5738771ba0d1af3b7af9738e0234ae1d1f15c4512d6edb16db">Glib::IO_FLAG_IS_WRITEABLE</a> are cached for internal use by the channel when it is created. If they should change at some later point (e.g. partial shutdown of a socket with the UNIX <code>shutdown()</code> function), the user should immediately call <a class="el" href="classGlib_1_1IOChannel.html#ac15e424b863d398ed458315b7f799243" title="Get the current flags for a IOChannel, including read-only flags such as Glib::IO_FLAG_IS_READABLE.">get_flags()</a> to update the internal values of these flags. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Bitwise combination of the flags set on the channel. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3326db3877358b563de11fb3dd8367f"></a><!-- doxytag: member="Glib::IOChannel::get_flags_vfunc" ref="ae3326db3877358b563de11fb3dd8367f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#gaee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a> <a class="el" href="classGlib_1_1IOChannel.html#ae3326db3877358b563de11fb3dd8367f">Glib::IOChannel::get_flags_vfunc</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#a29a782e3ab6d7fc1b77f612c97c195f6">Glib::StreamIOChannel</a>.</p>

</div>
</div>
<a class="anchor" id="afd08e7a2a6cbfbdad2ef599c9eadcc01"></a><!-- doxytag: member="Glib::IOChannel::get_line_term" ref="afd08e7a2a6cbfbdad2ef599c9eadcc01" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> <a class="el" href="classGlib_1_1IOChannel.html#afd08e7a2a6cbfbdad2ef599c9eadcc01">Glib::IOChannel::get_line_term</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab05ed8535a51b04749e11386c845a581"></a><!-- doxytag: member="Glib::IOChannel::gobj" ref="ab05ed8535a51b04749e11386c845a581" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GIOChannel* <a class="el" href="classGlib_1_1IOChannel.html#ab05ed8535a51b04749e11386c845a581">Glib::IOChannel::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aad550f12d9d2ec2fef0a2c7ba78f2595"></a><!-- doxytag: member="Glib::IOChannel::gobj" ref="aad550f12d9d2ec2fef0a2c7ba78f2595" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GIOChannel* <a class="el" href="classGlib_1_1IOChannel.html#ab05ed8535a51b04749e11386c845a581">Glib::IOChannel::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae5878a4510f52f194f18c0743f6a9b5c"></a><!-- doxytag: member="Glib::IOChannel::read" ref="ae5878a4510f52f194f18c0743f6a9b5c" args="(gunichar &amp;thechar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#ae5878a4510f52f194f18c0743f6a9b5c">Glib::IOChannel::read</a> </td>
          <td>(</td>
          <td class="paramtype">gunichar &amp;&#160;</td>
          <td class="paramname"><em>thechar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a single UCS-4 character. </p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">thechar</td><td>The <a class="el" href="namespaceGlib_1_1Unicode.html">Unicode</a> character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1afb78d2e29a2f01a7034279a0c12636"></a><!-- doxytag: member="Glib::IOChannel::read" ref="a1afb78d2e29a2f01a7034279a0c12636" args="(char *buf, gsize count, gsize &amp;bytes_read)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#ae5878a4510f52f194f18c0743f6a9b5c">Glib::IOChannel::read</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>bytes_read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a character sequence into memory. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A buffer to read data into. </td></tr>
    <tr><td class="paramname">count</td><td>The size of the buffer in bytes. Note that the buffer may not be complelely filled even if there is data in the buffer if the remaining data is not a complete character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">bytes_read</td><td>The number of bytes read. This may be zero even on success if <em>count</em> &lt; 6 and the channel's encoding is not <code>""</code>. This indicates that the next UTF-8 character is too wide for the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4553088deea02ebea2ab7a9e2cff0a1c"></a><!-- doxytag: member="Glib::IOChannel::read" ref="a4553088deea02ebea2ab7a9e2cff0a1c" args="(Glib::ustring &amp;str, gsize count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#ae5878a4510f52f194f18c0743f6a9b5c">Glib::IOChannel::read</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a maximum of <em>count</em> bytes into <em>str</em>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The maximum number of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">str</td><td>The characters that have been read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2950510fff168d5753ee1eb14714d67a"></a><!-- doxytag: member="Glib::IOChannel::read_line" ref="a2950510fff168d5753ee1eb14714d67a" args="(Glib::ustring &amp;line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#a2950510fff168d5753ee1eb14714d67a">Glib::IOChannel::read_line</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a whole line. </p>
<p>Reads until the line separator is found, which is included in the result string. </p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">line</td><td>The line that was read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d64e84ab360b3c83399c94076487df1"></a><!-- doxytag: member="Glib::IOChannel::read_to_end" ref="a0d64e84ab360b3c83399c94076487df1" args="(Glib::ustring &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#a0d64e84ab360b3c83399c94076487df1">Glib::IOChannel::read_to_end</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads all the remaining data from the file. </p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">str</td><td>The resulting string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__glibmmEnums.html#gga23fb251e48485b62a9c2677bb1f87d5eaf249c5b8e984c37db0847258aeeae86a">Glib::IO_STATUS_NORMAL</a> on success. This function never returns <a class="el" href="group__glibmmEnums.html#gga23fb251e48485b62a9c2677bb1f87d5ead42ae91b402716ab4faaec9b0f3823fe">Glib::IO_STATUS_EOF</a>. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfb4faa07e80b86f21b0f18f0b8606cd"></a><!-- doxytag: member="Glib::IOChannel::read_vfunc" ref="abfb4faa07e80b86f21b0f18f0b8606cd" args="(char *buf, gsize count, gsize &amp;bytes_read)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#abfb4faa07e80b86f21b0f18f0b8606cd">Glib::IOChannel::read_vfunc</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>bytes_read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#aad85c2e9149428db83575ff98bdac482">Glib::StreamIOChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aa63e3a39347848387cd9422d0073a7be"></a><!-- doxytag: member="Glib::IOChannel::reference" ref="aa63e3a39347848387cd9422d0073a7be" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classGlib_1_1IOChannel.html#aa63e3a39347848387cd9422d0073a7be">Glib::IOChannel::reference</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a65a5048c32ecde11827b5ae1973ee0b1"></a><!-- doxytag: member="Glib::IOChannel::seek" ref="a65a5048c32ecde11827b5ae1973ee0b1" args="(gint64 offset, SeekType type=SEEK_TYPE_SET)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#a65a5048c32ecde11827b5ae1973ee0b1">Glib::IOChannel::seek</a> </td>
          <td>(</td>
          <td class="paramtype">gint64&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gaa3767731311bdba4ef42dc99215e5cda">SeekType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="group__glibmmEnums.html#ggaa3767731311bdba4ef42dc99215e5cdaa1e0d3b4a03e5dd32f135acc89982889f">SEEK_TYPE_SET</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seek the I/O channel to a specific position. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset in bytes from the position specified by <em>type</em>. </td></tr>
    <tr><td class="paramname">type</td><td>A SeekType. The type <a class="el" href="group__glibmmEnums.html#ggaa3767731311bdba4ef42dc99215e5cdaa48f0a394042c3a8e117b2ae64af33960">Glib::SEEK_TYPE_CUR</a> is only allowed in those cases where a call to <a class="el" href="classGlib_1_1IOChannel.html#ab1d3ae667bd425ef830929a67cf526e0" title="Sets the encoding for the input/output of the channel.">set_encoding()</a> is allowed. See the documentation for <a class="el" href="classGlib_1_1IOChannel.html#ab1d3ae667bd425ef830929a67cf526e0" title="Sets the encoding for the input/output of the channel.">set_encoding()</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a781de88aec2c032d05f74402779665f3"></a><!-- doxytag: member="Glib::IOChannel::seek_vfunc" ref="a781de88aec2c032d05f74402779665f3" args="(gint64 offset, SeekType type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#a781de88aec2c032d05f74402779665f3">Glib::IOChannel::seek_vfunc</a> </td>
          <td>(</td>
          <td class="paramtype">gint64&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gaa3767731311bdba4ef42dc99215e5cda">SeekType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#a82c4a6b077c542d1b79c23ecc6b1772f">Glib::StreamIOChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a535767c92f2678e5e72051f6f4bc5326"></a><!-- doxytag: member="Glib::IOChannel::set_buffer_size" ref="a535767c92f2678e5e72051f6f4bc5326" args="(gsize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGlib_1_1IOChannel.html#a535767c92f2678e5e72051f6f4bc5326">Glib::IOChannel::set_buffer_size</a> </td>
          <td>(</td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the internal <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> buffer size. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The buffer size the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> should use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abaf37b0d76cd41628fd0c41a674495de"></a><!-- doxytag: member="Glib::IOChannel::set_buffered" ref="abaf37b0d76cd41628fd0c41a674495de" args="(bool buffered)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGlib_1_1IOChannel.html#abaf37b0d76cd41628fd0c41a674495de">Glib::IOChannel::set_buffered</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>buffered</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the buffering status of the I/O channel. </p>
<p>The buffering state can only be set if the channel's encoding is <code>""</code>. For any other encoding, the channel must be buffered.</p>
<p>A buffered channel can only be set unbuffered if the channel's internal buffers have been flushed. Newly created channels or channels which have returned <a class="el" href="group__glibmmEnums.html#gga23fb251e48485b62a9c2677bb1f87d5ead42ae91b402716ab4faaec9b0f3823fe">Glib::IO_STATUS_EOF</a> not require such a flush. For write-only channels, a call to <a class="el" href="classGlib_1_1IOChannel.html#aba6702093bd1c58ea22231446ed2f6e4" title="Flush the buffers of the I/O channel.">flush()</a> is sufficient. For all other channels, the buffers may be flushed by a call to <a class="el" href="classGlib_1_1IOChannel.html#a65a5048c32ecde11827b5ae1973ee0b1" title="Seek the I/O channel to a specific position.">seek()</a>. This includes the possibility of seeking with seek type <a class="el" href="group__glibmmEnums.html#ggaa3767731311bdba4ef42dc99215e5cdaa48f0a394042c3a8e117b2ae64af33960">Glib::SEEK_TYPE_CUR</a> and an offset of zero. Note that this means that socket-based channels cannot be set unbuffered once they have had data read from them.</p>
<p>The default state of the channel is buffered.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffered</td><td>Whether to set the channel buffered or unbuffered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f4fbc2a4c3670863fbf504d7fc96253"></a><!-- doxytag: member="Glib::IOChannel::set_close_on_unref" ref="a3f4fbc2a4c3670863fbf504d7fc96253" args="(bool do_close)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGlib_1_1IOChannel.html#a3f4fbc2a4c3670863fbf504d7fc96253">Glib::IOChannel::set_close_on_unref</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_close</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setting this flag to <code>true</code> for a channel you have already closed can cause problems. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">do_close</td><td>Whether to close the channel on the final unref of the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> object. The default value of this is <code>true</code> for channels created by <a class="el" href="classGlib_1_1IOChannel.html#ac175ea1fd6ef84ac3758ca57b42b7f33" title="Open a file filename as an I/O channel using mode mode.">create_from_file()</a>, and <code>false</code> for all other channels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1d3ae667bd425ef830929a67cf526e0"></a><!-- doxytag: member="Glib::IOChannel::set_encoding" ref="ab1d3ae667bd425ef830929a67cf526e0" args="(const std::string &amp;encoding=std::string())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#ab1d3ae667bd425ef830929a67cf526e0">Glib::IOChannel::set_encoding</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>encoding</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the encoding for the input/output of the channel. </p>
<p>The internal encoding is always UTF-8. The default encoding for the external file is UTF-8. The encoding <code>""</code> is safe to use with binary data.</p>
<p>The encoding can only be set if one of the following conditions is true:</p>
<ol type="1">
<li>The channel was just created, and has not been written to or read from yet.</li>
<li>The channel is write-only.</li>
<li>The channel is a file, and the file pointer was just repositioned by a call to seek_position(). (This flushes all the internal buffers.)</li>
<li>The current encoding is <code>""</code> or UTF-8.</li>
<li>One of the read methods has just returned <a class="el" href="group__glibmmEnums.html#gga23fb251e48485b62a9c2677bb1f87d5ead42ae91b402716ab4faaec9b0f3823fe">Glib::IO_STATUS_EOF</a> (or, in the case of <a class="el" href="classGlib_1_1IOChannel.html#a0d64e84ab360b3c83399c94076487df1" title="Reads all the remaining data from the file.">read_to_end()</a>, <a class="el" href="group__glibmmEnums.html#gga23fb251e48485b62a9c2677bb1f87d5eaf249c5b8e984c37db0847258aeeae86a">Glib::IO_STATUS_NORMAL</a>).</li>
<li>The <a class="el" href="classGlib_1_1IOChannel.html#ae5878a4510f52f194f18c0743f6a9b5c" title="Read a single UCS-4 character.">read()</a> method has returned <a class="el" href="group__glibmmEnums.html#gga23fb251e48485b62a9c2677bb1f87d5ea5a33609d7ff07e1d711185c0765cf5de">Glib::IO_STATUS_AGAIN</a> or thrown a <a class="el" href="classGlib_1_1Error.html">Glib::Error</a> exception. This may be useful in the case of <a class="el" href="classGlib_1_1ConvertError.html#aea4b79ac3149c1fcfcab32155e3561a9a335a4cb227118026dd0c25661f294d10">ConvertError::ILLEGAL_SEQUENCE</a>. Returning one of these statuses from <a class="el" href="classGlib_1_1IOChannel.html#a2950510fff168d5753ee1eb14714d67a" title="Read a whole line.">read_line()</a> or <a class="el" href="classGlib_1_1IOChannel.html#a0d64e84ab360b3c83399c94076487df1" title="Reads all the remaining data from the file.">read_to_end()</a> does <em>not</em> guarantee that the encoding can be changed.</li>
</ol>
<p>Channels which do not meet one of the above conditions cannot call seek_position() with a seek type of <a class="el" href="group__glibmmEnums.html#ggaa3767731311bdba4ef42dc99215e5cdaa48f0a394042c3a8e117b2ae64af33960">Glib::SEEK_TYPE_CUR</a> and, if they are "seekable", cannot call <a class="el" href="classGlib_1_1IOChannel.html#acacb5599be21f549911c6aca5f820fcf" title="Write a string to the I/O channel.">write()</a> after calling one of the API "read" methods.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">encoding</td><td>The encoding name, or <code>""</code> for binary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__glibmmEnums.html#gga23fb251e48485b62a9c2677bb1f87d5eaf249c5b8e984c37db0847258aeeae86a">Glib::IO_STATUS_NORMAL</a> if the encoding was successfully set. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6c16c87c174d836247f47c2b87539fd"></a><!-- doxytag: member="Glib::IOChannel::set_flags" ref="ab6c16c87c174d836247f47c2b87539fd" args="(IOFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#ab6c16c87c174d836247f47c2b87539fd">Glib::IOChannel::set_flags</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gaee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set flags on the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Bitwise combination of the flags to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The operation result code. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8f690f1e0a8945b75ad7be4949e44cf"></a><!-- doxytag: member="Glib::IOChannel::set_flags_vfunc" ref="af8f690f1e0a8945b75ad7be4949e44cf" args="(IOFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#af8f690f1e0a8945b75ad7be4949e44cf">Glib::IOChannel::set_flags_vfunc</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gaee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#add1a29876a6d3b553f41ef21dd654f67">Glib::StreamIOChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ad42d03bdd0288cf5517737a73f7268b3"></a><!-- doxytag: member="Glib::IOChannel::set_line_term" ref="ad42d03bdd0288cf5517737a73f7268b3" args="(const std::string &amp;term=std::string())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGlib_1_1IOChannel.html#ad42d03bdd0288cf5517737a73f7268b3">Glib::IOChannel::set_line_term</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>term</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4c57bf6b00844fc3ddb9d0e60cac7dcf"></a><!-- doxytag: member="Glib::IOChannel::unreference" ref="a4c57bf6b00844fc3ddb9d0e60cac7dcf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classGlib_1_1IOChannel.html#a4c57bf6b00844fc3ddb9d0e60cac7dcf">Glib::IOChannel::unreference</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acacb5599be21f549911c6aca5f820fcf"></a><!-- doxytag: member="Glib::IOChannel::write" ref="acacb5599be21f549911c6aca5f820fcf" args="(const Glib::ustring &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#acacb5599be21f549911c6aca5f820fcf">Glib::IOChannel::write</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a string to the I/O channel. </p>
<p>Note that this method does not return the number of characters written. If the channel is blocking and the returned value is <a class="el" href="group__glibmmEnums.html#gga23fb251e48485b62a9c2677bb1f87d5eaf249c5b8e984c37db0847258aeeae86a">Glib::IO_STATUS_NORMAL</a>, the whole string was written. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29114ed2bcb64b8af551271394968528"></a><!-- doxytag: member="Glib::IOChannel::write" ref="a29114ed2bcb64b8af551271394968528" args="(const char *buf, gssize count, gsize &amp;bytes_written)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#acacb5599be21f549911c6aca5f820fcf">Glib::IOChannel::write</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>bytes_written</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a memory area of <em>count</em> bytes to the I/O channel. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The start of the memory area. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">bytes_written</td><td>The number of bytes written to the channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e0a187ff012b3b90c6d3d8593c18e92"></a><!-- doxytag: member="Glib::IOChannel::write" ref="a5e0a187ff012b3b90c6d3d8593c18e92" args="(gunichar unichar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#acacb5599be21f549911c6aca5f820fcf">Glib::IOChannel::write</a> </td>
          <td>(</td>
          <td class="paramtype">gunichar&#160;</td>
          <td class="paramname"><em>unichar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a single UCS-4 character to the I/O channel. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">unichar</td><td>The character to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ed5372da9d4ad3465012fc2317507b5"></a><!-- doxytag: member="Glib::IOChannel::write_vfunc" ref="a4ed5372da9d4ad3465012fc2317507b5" args="(const char *buf, gsize count, gsize &amp;bytes_written)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> <a class="el" href="classGlib_1_1IOChannel.html#a4ed5372da9d4ad3465012fc2317507b5">Glib::IOChannel::write_vfunc</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>bytes_written</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#a9b6ce8cea1b948c1d408c946c4ad27eb">Glib::StreamIOChannel</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a6683e47c0d78492b83d7021288d9b6d0"></a><!-- doxytag: member="Glib::IOChannel::gobject_" ref="a6683e47c0d78492b83d7021288d9b6d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GIOChannel* <a class="el" href="classGlib_1_1IOChannel.html#a6683e47c0d78492b83d7021288d9b6d0">Glib::IOChannel::gobject_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 10 2012 14:20:39 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
