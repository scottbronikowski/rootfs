<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>glibmm: Gio::Cancellable Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="/home/murrayc/checkouts/gnome30/glibmm/docs/doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.32.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceGio.html">Gio</a> </li>
      <li class="navelem"><a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> </div>
  <div class="headertitle">
<div class="title">Gio::Cancellable Class Reference</div> </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Gio::Cancellable" --><!-- doxytag: inherits="Glib::Object" -->
<p>Allows actions to be cancelled.  <a href="classGio_1_1Cancellable.html#details">More...</a></p>

<p><code>#include &lt;giomm/cancellable.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gio::Cancellable:</div>
<div class="dyncontent">
<div class="center"><img src="classGio_1_1Cancellable__inherit__graph.png" border="0" usemap="#Gio_1_1Cancellable_inherit__map" alt="Inheritance graph"/></div>
<map name="Gio_1_1Cancellable_inherit__map" id="Gio_1_1Cancellable_inherit__map">
<area shape="rect" id="node2" href="classGlib_1_1Object.html" title="Glib::Object" alt="" coords="21,160,115,189"/><area shape="rect" id="node4" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="5,83,131,112"/><area shape="rect" id="node6" href="../../../libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="11,5,125,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGio_1_1Cancellable-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a18d005aeefd0da4daab594f4c44ce9cd">SlotCancelledCallback</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a97c7c4d728865129bc6f0cd3f4ecfce7">~Cancellable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GCancellable*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#ae19ec1e85fd9cd7893914d4d7c20120d">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#ae19ec1e85fd9cd7893914d4d7c20120d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GCancellable*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a668176a01f7ad3cc13c7448378f37b41">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a668176a01f7ad3cc13c7448378f37b41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GCancellable*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a379e6394bad0fff1eb11e1a160f30235">gobj_copy</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. <a href="#a379e6394bad0fff1eb11e1a160f30235"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a47ce5f2f16541b7ae18bc5114b366d8c">is_cancelled</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a cancellable job has been cancelled. <a href="#a47ce5f2f16541b7ae18bc5114b366d8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a80df23049daf594fda884f2932ce3b95">get_fd</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the file descriptor for a cancellable job. <a href="#a80df23049daf594fda884f2932ce3b95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a6627893047c8a375324b58e955661395">make_pollfd</a> (GPollFD* pollfd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a PollFD corresponding to <em>cancellable</em>; this can be passed to Glib::poll() and used to poll for cancellation. <a href="#a6627893047c8a375324b58e955661395"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#ad8f406bb61e80d382153ebf600822ce2">release_fd</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a resources previously allocated by g_cancellable_get_fd() or g_cancellable_make_pollfd(). <a href="#ad8f406bb61e80d382153ebf600822ce2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a86adae0645cec20d09d1a2903fe46cc0">cancel</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Will set <em>cancellable</em> to cancelled, and will emit the <a class="el" href="classGio_1_1Cancellable.html#a5a34d4782ccec014684c4eb6c20cf0a6">Cancellable::signal_cancelled()</a> signal. <a href="#a86adae0645cec20d09d1a2903fe46cc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#ad893da5aebfb4baf34ecdbdad7a3608b">push_current</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes <em>cancellable</em> onto the cancellable stack. <a href="#ad893da5aebfb4baf34ecdbdad7a3608b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a93b5a39447d2b4eb9fb56748cb687fc8">pop_current</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops <em>cancellable</em> off the cancellable stack (verifying that <em>cancellable</em> is on the top of the stack). <a href="#a93b5a39447d2b4eb9fb56748cb687fc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a2285370aea5d98141e742e73743b9c3e">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets <em>cancellable</em> to its uncancelled state. <a href="#a2285370aea5d98141e742e73743b9c3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#ad43ddee749e87373a2dd035f8eb989e6">connect</a> (const <a class="el" href="classGio_1_1Cancellable.html#a18d005aeefd0da4daab594f4c44ce9cd">SlotCancelledCallback</a>&amp; callback)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to connect to the <a class="el" href="classGio_1_1Cancellable.html#a5a34d4782ccec014684c4eb6c20cf0a6">Cancellable::signal_cancelled()</a> signal. <a href="#ad43ddee749e87373a2dd035f8eb989e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#aa9277479b4bf0b80090e780e26215713">disconnect</a> (gulong handler_id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a handler from a cancellable instance similar to Glib::signal_handler_disconnect(). <a href="#aa9277479b4bf0b80090e780e26215713"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1SignalProxy0.html">Glib::SignalProxy0</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a5a34d4782ccec014684c4eb6c20cf0a6">signal_cancelled</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#a8d59324b4c253f8c890901cd934203a7">create</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#aaf923ce91ddf21fc03bf2902e12cd4e1">get_current</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the top cancellable from the stack. <a href="#aaf923ce91ddf21fc03bf2902e12cd4e1"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#aab7733b6e915e4ebe280fbb669b6af2a">Cancellable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#aff017e200824997b9c26d82f147e078f">on_cancelled</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a default handler for the signal <a class="el" href="classGio_1_1Cancellable.html#a5a34d4782ccec014684c4eb6c20cf0a6">signal_cancelled()</a>. <a href="#aff017e200824997b9c26d82f147e078f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Gio::Cancellable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Cancellable.html#ac45875da91c9c870a0f154a8249047c0">wrap</a> (GCancellable* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#ac45875da91c9c870a0f154a8249047c0"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Allows actions to be cancelled. </p>
<p><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> is a thread-safe operation cancellation stack used throughout GIO to allow for cancellation of synchronous and asynchronous operations.</p>
<dl class="since_2_16"><dt><b><a class="el" href="since_2_16.html#_since_2_16000019">Since glibmm 2.16:</a></b></dt><dd></dd></dl>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a18d005aeefd0da4daab594f4c44ce9cd"></a><!-- doxytag: member="Gio::Cancellable::SlotCancelledCallback" ref="a18d005aeefd0da4daab594f4c44ce9cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;void&gt; <a class="el" href="classGio_1_1Cancellable.html#a18d005aeefd0da4daab594f4c44ce9cd">Gio::Cancellable::SlotCancelledCallback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a97c7c4d728865129bc6f0cd3f4ecfce7"></a><!-- doxytag: member="Gio::Cancellable::~Cancellable" ref="a97c7c4d728865129bc6f0cd3f4ecfce7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGio_1_1Cancellable.html#a97c7c4d728865129bc6f0cd3f4ecfce7">Gio::Cancellable::~Cancellable</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aab7733b6e915e4ebe280fbb669b6af2a"></a><!-- doxytag: member="Gio::Cancellable::Cancellable" ref="aab7733b6e915e4ebe280fbb669b6af2a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1Cancellable.html#aab7733b6e915e4ebe280fbb669b6af2a">Gio::Cancellable::Cancellable</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a86adae0645cec20d09d1a2903fe46cc0"></a><!-- doxytag: member="Gio::Cancellable::cancel" ref="a86adae0645cec20d09d1a2903fe46cc0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Cancellable.html#a86adae0645cec20d09d1a2903fe46cc0">Gio::Cancellable::cancel</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Will set <em>cancellable</em> to cancelled, and will emit the <a class="el" href="classGio_1_1Cancellable.html#a5a34d4782ccec014684c4eb6c20cf0a6">Cancellable::signal_cancelled()</a> signal. </p>
<p>(However, see the warning about race conditions in the documentation for that signal if you are planning to connect to it.)</p>
<p>This function is thread-safe. In other words, you can safely call it from a thread other than the one running the operation that was passed the <em>cancellable</em>.</p>
<p>The convention within gio is that cancelling an asynchronous operation causes it to complete asynchronously. That is, if you cancel the operation from the same thread in which it is running, then the operation's AsyncReadyCallback will not be invoked until the application returns to the main loop. </p>

</div>
</div>
<a class="anchor" id="ad43ddee749e87373a2dd035f8eb989e6"></a><!-- doxytag: member="Gio::Cancellable::connect" ref="ad43ddee749e87373a2dd035f8eb989e6" args="(const SlotCancelledCallback &amp;callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gulong <a class="el" href="classGio_1_1Cancellable.html#ad43ddee749e87373a2dd035f8eb989e6">Gio::Cancellable::connect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGio_1_1Cancellable.html#a18d005aeefd0da4daab594f4c44ce9cd">SlotCancelledCallback</a>&amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience function to connect to the <a class="el" href="classGio_1_1Cancellable.html#a5a34d4782ccec014684c4eb6c20cf0a6">Cancellable::signal_cancelled()</a> signal. </p>
<p>Also handles the race condition that may happen if the cancellable is cancelled right before connecting.</p>
<p><em>callback</em> is called at most once, either directly at the time of the connect if <em>cancellable</em> is already cancelled, or when <em>cancellable</em> is cancelled in some thread.</p>
<p><em>data_destroy_func</em> will be called when the handler is disconnected, or immediately if the cancellable is already cancelled.</p>
<p>See <a class="el" href="classGio_1_1Cancellable.html#a5a34d4782ccec014684c4eb6c20cf0a6">Cancellable::signal_cancelled()</a> for details on how to use this.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000011">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The Callback to connect. </td></tr>
    <tr><td class="paramname">data</td><td>Data to pass to <em>callback</em>. </td></tr>
    <tr><td class="paramname">data_destroy_func</td><td>Free function for <em>data</em> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The id of the signal handler or 0 if <em>cancellable</em> has already been cancelled. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d59324b4c253f8c890901cd934203a7"></a><!-- doxytag: member="Gio::Cancellable::create" ref="a8d59324b4c253f8c890901cd934203a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt; <a class="el" href="classGio_1_1Cancellable.html#a8d59324b4c253f8c890901cd934203a7">Gio::Cancellable::create</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa9277479b4bf0b80090e780e26215713"></a><!-- doxytag: member="Gio::Cancellable::disconnect" ref="aa9277479b4bf0b80090e780e26215713" args="(gulong handler_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Cancellable.html#aa9277479b4bf0b80090e780e26215713">Gio::Cancellable::disconnect</a> </td>
          <td>(</td>
          <td class="paramtype">gulong&#160;</td>
          <td class="paramname"><em>handler_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a handler from a cancellable instance similar to Glib::signal_handler_disconnect(). </p>
<p>Additionally, in the event that a signal handler is currently running, this call will block until the handler has finished. Calling this function from a <a class="el" href="classGio_1_1Cancellable.html#a5a34d4782ccec014684c4eb6c20cf0a6">Cancellable::signal_cancelled()</a> signal handler will therefore result in a deadlock.</p>
<p>This avoids a race condition where a thread cancels at the same time as the cancellable operation is finished and the signal handler is removed. See <a class="el" href="classGio_1_1Cancellable.html#a5a34d4782ccec014684c4eb6c20cf0a6">Cancellable::signal_cancelled()</a> for details on how to use this.</p>
<p>If <em>cancellable</em> is <code>0</code> or <em>handler_id</em> is %0 this function does nothing.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000012">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handler_id</td><td>Handler id of the handler to be disconnected, or %0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf923ce91ddf21fc03bf2902e12cd4e1"></a><!-- doxytag: member="Gio::Cancellable::get_current" ref="aaf923ce91ddf21fc03bf2902e12cd4e1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt; <a class="el" href="classGio_1_1Cancellable.html#aaf923ce91ddf21fc03bf2902e12cd4e1">Gio::Cancellable::get_current</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the top cancellable from the stack. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> from the top of the stack, or <code>0</code> if the stack is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a80df23049daf594fda884f2932ce3b95"></a><!-- doxytag: member="Gio::Cancellable::get_fd" ref="a80df23049daf594fda884f2932ce3b95" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGio_1_1Cancellable.html#a80df23049daf594fda884f2932ce3b95">Gio::Cancellable::get_fd</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the file descriptor for a cancellable job. </p>
<p>This can be used to implement cancellable operations on Unix systems. The returned fd will turn readable when <em>cancellable</em> is cancelled.</p>
<p>You are not supposed to read from the fd yourself, just check for readable status. Reading to unset the readable status is done with g_cancellable_reset().</p>
<p>After a successful return from this function, you should use g_cancellable_release_fd() to free up resources allocated for the returned file descriptor.</p>
<p>See also g_cancellable_make_pollfd(). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A valid file descriptor. %-1 if the file descriptor is not supported, or on errors. </dd></dl>

</div>
</div>
<a class="anchor" id="ae19ec1e85fd9cd7893914d4d7c20120d"></a><!-- doxytag: member="Gio::Cancellable::gobj" ref="ae19ec1e85fd9cd7893914d4d7c20120d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCancellable* <a class="el" href="classGio_1_1Cancellable.html#ae19ec1e85fd9cd7893914d4d7c20120d">Gio::Cancellable::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#a4c6efc18be8cb9c56e58fc0bd20fafbe">Glib::ObjectBase</a>.</p>

</div>
</div>
<a class="anchor" id="a668176a01f7ad3cc13c7448378f37b41"></a><!-- doxytag: member="Gio::Cancellable::gobj" ref="a668176a01f7ad3cc13c7448378f37b41" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GCancellable* <a class="el" href="classGio_1_1Cancellable.html#ae19ec1e85fd9cd7893914d4d7c20120d">Gio::Cancellable::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#a778a94181132976bbfb0519793f3b32e">Glib::ObjectBase</a>.</p>

</div>
</div>
<a class="anchor" id="a379e6394bad0fff1eb11e1a160f30235"></a><!-- doxytag: member="Gio::Cancellable::gobj_copy" ref="a379e6394bad0fff1eb11e1a160f30235" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCancellable* <a class="el" href="classGio_1_1Cancellable.html#a379e6394bad0fff1eb11e1a160f30235">Gio::Cancellable::gobj_copy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a class="anchor" id="a47ce5f2f16541b7ae18bc5114b366d8c"></a><!-- doxytag: member="Gio::Cancellable::is_cancelled" ref="a47ce5f2f16541b7ae18bc5114b366d8c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1Cancellable.html#a47ce5f2f16541b7ae18bc5114b366d8c">Gio::Cancellable::is_cancelled</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if a cancellable job has been cancelled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <em>cancellable</em> is cancelled, <code>false</code> if called with <code>0</code> or if item is not cancelled. </dd></dl>

</div>
</div>
<a class="anchor" id="a6627893047c8a375324b58e955661395"></a><!-- doxytag: member="Gio::Cancellable::make_pollfd" ref="a6627893047c8a375324b58e955661395" args="(GPollFD *pollfd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1Cancellable.html#a6627893047c8a375324b58e955661395">Gio::Cancellable::make_pollfd</a> </td>
          <td>(</td>
          <td class="paramtype">GPollFD *&#160;</td>
          <td class="paramname"><em>pollfd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a PollFD corresponding to <em>cancellable</em>; this can be passed to Glib::poll() and used to poll for cancellation. </p>
<p>This is useful both for unix systems without a native poll and for portability to windows.</p>
<p>When this function returns <code>true</code>, you should use g_cancellable_release_fd() to free up resources allocated for the <em>pollfd</em>. After a <code>false</code> return, do not call g_cancellable_release_fd().</p>
<p>If this function returns <code>false</code>, either no <em>cancellable</em> was given or resource limits prevent this function from allocating the necessary structures for polling. (On Linux, you will likely have reached the maximum number of file descriptors.) The suggested way to handle these cases is to ignore the <em>cancellable</em>.</p>
<p>You are not supposed to read from the fd yourself, just check for readable status. Reading to unset the readable status is done with g_cancellable_reset().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000009">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pollfd</td><td>A pointer to a PollFD. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <em>pollfd</em> was successfully initialized, <code>false</code> on failure to prepare the cancellable. </dd></dl>

</div>
</div>
<a class="anchor" id="aff017e200824997b9c26d82f147e078f"></a><!-- doxytag: member="Gio::Cancellable::on_cancelled" ref="aff017e200824997b9c26d82f147e078f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classGio_1_1Cancellable.html#aff017e200824997b9c26d82f147e078f">Gio::Cancellable::on_cancelled</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is a default handler for the signal <a class="el" href="classGio_1_1Cancellable.html#a5a34d4782ccec014684c4eb6c20cf0a6">signal_cancelled()</a>. </p>

</div>
</div>
<a class="anchor" id="a93b5a39447d2b4eb9fb56748cb687fc8"></a><!-- doxytag: member="Gio::Cancellable::pop_current" ref="a93b5a39447d2b4eb9fb56748cb687fc8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Cancellable.html#a93b5a39447d2b4eb9fb56748cb687fc8">Gio::Cancellable::pop_current</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pops <em>cancellable</em> off the cancellable stack (verifying that <em>cancellable</em> is on the top of the stack). </p>

</div>
</div>
<a class="anchor" id="ad893da5aebfb4baf34ecdbdad7a3608b"></a><!-- doxytag: member="Gio::Cancellable::push_current" ref="ad893da5aebfb4baf34ecdbdad7a3608b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Cancellable.html#ad893da5aebfb4baf34ecdbdad7a3608b">Gio::Cancellable::push_current</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pushes <em>cancellable</em> onto the cancellable stack. </p>
<p>The current cancellable can then be received using g_cancellable_get_current().</p>
<p>This is useful when implementing cancellable operations in code that does not allow you to pass down the cancellable object.</p>
<p>This is typically called automatically by e.g. <a class="el" href="classGio_1_1File.html" title="File and directory handling.">File</a> operations, so you rarely have to call this yourself. </p>

</div>
</div>
<a class="anchor" id="ad8f406bb61e80d382153ebf600822ce2"></a><!-- doxytag: member="Gio::Cancellable::release_fd" ref="ad8f406bb61e80d382153ebf600822ce2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Cancellable.html#ad8f406bb61e80d382153ebf600822ce2">Gio::Cancellable::release_fd</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases a resources previously allocated by g_cancellable_get_fd() or g_cancellable_make_pollfd(). </p>
<p>For compatibility reasons with older releases, calling this function is not strictly required, the resources will be automatically freed when the <em>cancellable</em> is finalized. However, the <em>cancellable</em> will block scarce file descriptors until it is finalized if this function is not called. This can cause the application to run out of file descriptors when many Cancellables are used at the same time.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000010">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a2285370aea5d98141e742e73743b9c3e"></a><!-- doxytag: member="Gio::Cancellable::reset" ref="a2285370aea5d98141e742e73743b9c3e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Cancellable.html#a2285370aea5d98141e742e73743b9c3e">Gio::Cancellable::reset</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets <em>cancellable</em> to its uncancelled state. </p>
<p>If cancellable is currently in use by any cancellable operation then the behavior of this function is undefined. </p>

</div>
</div>
<a class="anchor" id="a5a34d4782ccec014684c4eb6c20cf0a6"></a><!-- doxytag: member="Gio::Cancellable::signal_cancelled" ref="a5a34d4782ccec014684c4eb6c20cf0a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1SignalProxy0.html">Glib::SignalProxy0</a>&lt; void &gt; <a class="el" href="classGio_1_1Cancellable.html#a5a34d4782ccec014684c4eb6c20cf0a6">Gio::Cancellable::signal_cancelled</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Slot Prototype:</b></dt><dd><code>void on_my_cancelled()</code></dd></dl>
<p>Emitted when the operation has been cancelled.</p>
<p>Can be used by implementations of cancellable operations. If the operation is cancelled from another thread, the signal will be emitted in the thread that cancelled the operation, not the thread that is running the operation.</p>
<p>Note that disconnecting from this signal (or any signal) in a multi-threaded program is prone to race conditions. For instance it is possible that a signal handler may be invoked even <em>after</em> a call to Glib::signal_handler_disconnect() for that handler has already returned.</p>
<p>There is also a problem when cancellation happen right before connecting to the signal. If this happens the signal will unexpectedly not be emitted, and checking before connecting to the signal leaves a race condition where this is still happening.</p>
<p>In order to make it safe and easy to connect handlers there are two helper functions: g_cancellable_connect() and g_cancellable_disconnect() which protect against problems like this.</p>
<p>An example of how to us this:</p>
<p>[C example ellipted]</p>
<p>Note that the cancelled signal is emitted in the thread that the user cancelled from, which may be the main thread. So, the cancellable signal should not do something that can block. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ac45875da91c9c870a0f154a8249047c0"></a><!-- doxytag: member="Gio::Cancellable::wrap" ref="ac45875da91c9c870a0f154a8249047c0" args="(GCancellable *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Gio::Cancellable</a> &gt; <a class="el" href="classGio_1_1Cancellable.html#ac45875da91c9c870a0f154a8249047c0">wrap</a> </td>
          <td>(</td>
          <td class="paramtype">GCancellable *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 10 2012 14:20:37 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
