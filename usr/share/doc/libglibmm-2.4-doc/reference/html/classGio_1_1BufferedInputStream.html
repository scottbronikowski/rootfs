<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>glibmm: Gio::BufferedInputStream Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="/home/murrayc/checkouts/gnome30/glibmm/docs/doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.32.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceGio.html">Gio</a> </li>
      <li class="navelem"><a class="el" href="classGio_1_1BufferedInputStream.html">BufferedInputStream</a> </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> </div>
  <div class="headertitle">
<div class="title">Gio::BufferedInputStream Class Reference<div class="ingroups"><a class="el" href="group__Streams.html">Stream Classes</a></div></div> </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Gio::BufferedInputStream" --><!-- doxytag: inherits="Gio::FilterInputStream" -->
<p>The buffered input stream implements <a class="el" href="classGio_1_1FilterInputStream.html" title="Filter Input Stream.">FilterInputStream</a> and provides for buffered reads.  <a href="classGio_1_1BufferedInputStream.html#details">More...</a></p>

<p><code>#include &lt;giomm/bufferedinputstream.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gio::BufferedInputStream:</div>
<div class="dyncontent">
<div class="center"><img src="classGio_1_1BufferedInputStream__inherit__graph.png" border="0" usemap="#Gio_1_1BufferedInputStream_inherit__map" alt="Inheritance graph"/></div>
<map name="Gio_1_1BufferedInputStream_inherit__map" id="Gio_1_1BufferedInputStream_inherit__map">
<area shape="rect" id="node13" href="classGio_1_1DataInputStream.html" title="An implementation of BufferedInputStream that allows for high&#45;level data manipulation of arbitrary da..." alt="" coords="16,469,179,499"/><area shape="rect" id="node2" href="classGio_1_1FilterInputStream.html" title="Filter Input Stream." alt="" coords="17,315,177,344"/><area shape="rect" id="node4" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input." alt="" coords="32,237,163,267"/><area shape="rect" id="node6" href="classGlib_1_1Object.html" title="Glib::Object" alt="" coords="51,160,144,189"/><area shape="rect" id="node8" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="35,83,160,112"/><area shape="rect" id="node10" href="../../../libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="40,5,155,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGio_1_1BufferedInputStream-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a6d961bb2ebe9c213c1e4c49572bae6ed">~BufferedInputStream</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GBufferedInputStream*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#aa9d0c1e643650b9a45831865f06e21be">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#aa9d0c1e643650b9a45831865f06e21be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GBufferedInputStream*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#ad6b09565f69b4c1cf1f0ca05ee53709e">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#ad6b09565f69b4c1cf1f0ca05ee53709e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GBufferedInputStream*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a47dc5f78b1faed25cdaaafe42b526d6d">gobj_copy</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. <a href="#a47dc5f78b1faed25cdaaafe42b526d6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a46384a96dc052e9d25e1a88281d69e40">get_buffer_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the input buffer. <a href="#a46384a96dc052e9d25e1a88281d69e40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#af5f861a5b30aadc48e21fb10a46afaa7">set_buffer_size</a> (gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01616.html#ga445a43f417432dd1b9aed90ef239c700">size</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the internal buffer of <em>stream</em> to <em>size</em>, or to the size of the contents of the buffer. <a href="#af5f861a5b30aadc48e21fb10a46afaa7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a436e3c852afdc67e8ba70d32e39ce6b9">get_available</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the available data within the stream. <a href="#a436e3c852afdc67e8ba70d32e39ce6b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a17a6489d7ab0b72268264c9f0a30e879">peek</a> (void* buffer, gsize offset, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Peeks in the buffer, copying data of size <em>count</em> into <em>buffer</em>, offset <em>offset</em> bytes. <a href="#a17a6489d7ab0b72268264c9f0a30e879"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a27838d9374fa86ae513bc27d939ede24">peek_buffer</a> (gsize&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer with the currently available bytes. <a href="#a27838d9374fa86ae513bc27d939ede24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a197687762599fb7c5b60141b55120cde">fill</a> (gssize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to read <em>count</em> bytes from the stream into the buffer. <a href="#a197687762599fb7c5b60141b55120cde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a271eab4876136b4960d37350738bfdfe">fill</a> (gssize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">non-cancellable version of <a class="el" href="classGio_1_1BufferedInputStream.html#a197687762599fb7c5b60141b55120cde" title="Tries to read count bytes from the stream into the buffer.">fill()</a> <a href="#a271eab4876136b4960d37350738bfdfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a0a41790e04e9ba500eb18d1ce8371d34">fill_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, gssize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data into the stream's buffer asynchronously, up to <em>count</em> size. <a href="#a0a41790e04e9ba500eb18d1ce8371d34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#aadb9c1b367e36c20c91e16ea840b6ef0">fill_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, gssize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data into the stream's buffer asynchronously, up to <em>count</em> size. <a href="#aadb9c1b367e36c20c91e16ea840b6ef0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a13c665ccc722a2544539086846137277">fill_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous read. <a href="#a13c665ccc722a2544539086846137277"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a85477f09b58dfb83e5a1ef62f119457a">read_byte</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to read a single byte from the stream or the buffer. <a href="#a85477f09b58dfb83e5a1ef62f119457a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a8741ffb62c82425f54bc5e005c2a238f">read_byte</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-cancellable version of <a class="el" href="classGio_1_1BufferedInputStream.html#a8741ffb62c82425f54bc5e005c2a238f" title="Non-cancellable version of read_byte().">read_byte()</a>. <a href="#a8741ffb62c82425f54bc5e005c2a238f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; guint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a10be713afc0912c4a5fe89a2c40d943e">property_buffer_size</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the backend buffer. <a href="#a10be713afc0912c4a5fe89a2c40d943e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; guint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a8d77671c76ea9170c32c294d28403378">property_buffer_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the backend buffer. <a href="#a8d77671c76ea9170c32c294d28403378"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1BufferedInputStream.html">BufferedInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#afc33c31f5c437df14d385d3aa9d1a37b">create</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InputStream.html">InputStream</a> &gt;&amp; base_stream)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input.">InputStream</a> from the given base_stream, with a buffer set to the default size (4 kilobytes). <a href="#afc33c31f5c437df14d385d3aa9d1a37b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1BufferedInputStream.html">BufferedInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a0ecd42e418c250abc04bfa03f09b252c">create_sized</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InputStream.html">InputStream</a> &gt;&amp; base_stream, gsize buffer_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input.">InputStream</a> from the given base_stream, with a buffer set to size. <a href="#a0ecd42e418c250abc04bfa03f09b252c"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a0a81d8bea742203e775f796f73f46ea4">BufferedInputStream</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InputStream.html">InputStream</a> &gt;&amp; base_stream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#afdadf0f95e646cdeede70af551f7fa85">BufferedInputStream</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InputStream.html">InputStream</a> &gt;&amp; base_stream, gsize buffer_size)</td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1BufferedInputStream.html">Gio::BufferedInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#adfe9bf4339f83095d6e96dda7b747575">wrap</a> (GBufferedInputStream* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#adfe9bf4339f83095d6e96dda7b747575"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The buffered input stream implements <a class="el" href="classGio_1_1FilterInputStream.html" title="Filter Input Stream.">FilterInputStream</a> and provides for buffered reads. </p>
<p>By default, <a class="el" href="classGio_1_1BufferedInputStream.html" title="The buffered input stream implements FilterInputStream and provides for buffered reads.">BufferedInputStream</a>'s buffer size is set at 4 kilobytes, but you can specify this to the constructor.</p>
<p>To get the size of a buffer within a buffered input stream, use <a class="el" href="classGio_1_1BufferedInputStream.html#a46384a96dc052e9d25e1a88281d69e40" title="Gets the size of the input buffer.">get_buffer_size()</a>. To change the size of a buffered input stream's buffer, use <a class="el" href="classGio_1_1BufferedInputStream.html#af5f861a5b30aadc48e21fb10a46afaa7" title="Sets the size of the internal buffer of stream to size, or to the size of the contents of the buffer...">set_buffer_size()</a>. Note that the buffer's size cannot be reduced below the size of the data within the buffer.</p>
<dl class="since_2_16"><dt><b><a class="el" href="since_2_16.html#_since_2_16000017">Since glibmm 2.16:</a></b></dt><dd></dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6d961bb2ebe9c213c1e4c49572bae6ed"></a><!-- doxytag: member="Gio::BufferedInputStream::~BufferedInputStream" ref="a6d961bb2ebe9c213c1e4c49572bae6ed" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGio_1_1BufferedInputStream.html#a6d961bb2ebe9c213c1e4c49572bae6ed">Gio::BufferedInputStream::~BufferedInputStream</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0a81d8bea742203e775f796f73f46ea4"></a><!-- doxytag: member="Gio::BufferedInputStream::BufferedInputStream" ref="a0a81d8bea742203e775f796f73f46ea4" args="(const Glib::RefPtr&lt; InputStream &gt; &amp;base_stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1BufferedInputStream.html#a0a81d8bea742203e775f796f73f46ea4">Gio::BufferedInputStream::BufferedInputStream</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InputStream.html">InputStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>base_stream</em></td><td>)</td>
          <td><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afdadf0f95e646cdeede70af551f7fa85"></a><!-- doxytag: member="Gio::BufferedInputStream::BufferedInputStream" ref="afdadf0f95e646cdeede70af551f7fa85" args="(const Glib::RefPtr&lt; InputStream &gt; &amp;base_stream, gsize buffer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1BufferedInputStream.html#a0a81d8bea742203e775f796f73f46ea4">Gio::BufferedInputStream::BufferedInputStream</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InputStream.html">InputStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>base_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="afc33c31f5c437df14d385d3aa9d1a37b"></a><!-- doxytag: member="Gio::BufferedInputStream::create" ref="afc33c31f5c437df14d385d3aa9d1a37b" args="(const Glib::RefPtr&lt; InputStream &gt; &amp;base_stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1BufferedInputStream.html">BufferedInputStream</a>&gt; <a class="el" href="classGio_1_1BufferedInputStream.html#afc33c31f5c437df14d385d3aa9d1a37b">Gio::BufferedInputStream::create</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InputStream.html">InputStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>base_stream</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input.">InputStream</a> from the given base_stream, with a buffer set to the default size (4 kilobytes). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">base_stream</td><td>An <a class="el" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input.">InputStream</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an <a class="el" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input.">InputStream</a> for the given base_stream. </dd></dl>

<p>Reimplemented in <a class="el" href="classGio_1_1DataInputStream.html#a5ecca0b3f4fdc5962c3c63e4e6706e4e">Gio::DataInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a0ecd42e418c250abc04bfa03f09b252c"></a><!-- doxytag: member="Gio::BufferedInputStream::create_sized" ref="a0ecd42e418c250abc04bfa03f09b252c" args="(const Glib::RefPtr&lt; InputStream &gt; &amp;base_stream, gsize buffer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1BufferedInputStream.html">BufferedInputStream</a>&gt; <a class="el" href="classGio_1_1BufferedInputStream.html#a0ecd42e418c250abc04bfa03f09b252c">Gio::BufferedInputStream::create_sized</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InputStream.html">InputStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>base_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input.">InputStream</a> from the given base_stream, with a buffer set to size. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">base_stream</td><td>An <a class="el" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input.">InputStream</a>. </td></tr>
    <tr><td class="paramname">size</td><td>A size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an <a class="el" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input.">InputStream</a> for the given base_stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a197687762599fb7c5b60141b55120cde"></a><!-- doxytag: member="Gio::BufferedInputStream::fill" ref="a197687762599fb7c5b60141b55120cde" args="(gssize count, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1BufferedInputStream.html#a197687762599fb7c5b60141b55120cde">Gio::BufferedInputStream::fill</a> </td>
          <td>(</td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to read <em>count</em> bytes from the stream into the buffer. </p>
<p>Will block during this read.</p>
<p>If <em>count</em> is zero, returns zero and does nothing. A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> to be thrown, with INVALID_ARGUMENT.</p>
<p>On success, the number of bytes read into the buffer is returned. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. If an operation was partially finished when the operation was cancelled the partial result will be returned, without an error.</p>
<p>For the asynchronous, non-blocking, version of this function, see g_buffered_input_stream_fill_async(). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes read into <em>stream's</em> buffer, up to <em>count</em>, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a271eab4876136b4960d37350738bfdfe"></a><!-- doxytag: member="Gio::BufferedInputStream::fill" ref="a271eab4876136b4960d37350738bfdfe" args="(gssize count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1BufferedInputStream.html#a197687762599fb7c5b60141b55120cde">Gio::BufferedInputStream::fill</a> </td>
          <td>(</td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>non-cancellable version of <a class="el" href="classGio_1_1BufferedInputStream.html#a197687762599fb7c5b60141b55120cde" title="Tries to read count bytes from the stream into the buffer.">fill()</a> </p>

</div>
</div>
<a class="anchor" id="a0a41790e04e9ba500eb18d1ce8371d34"></a><!-- doxytag: member="Gio::BufferedInputStream::fill_async" ref="a0a41790e04e9ba500eb18d1ce8371d34" args="(const SlotAsyncReady &amp;slot, gssize count, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1BufferedInputStream.html#a0a41790e04e9ba500eb18d1ce8371d34">Gio::BufferedInputStream::fill_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads data into the stream's buffer asynchronously, up to <em>count</em> size. </p>
<p><em>io_priority</em> can be used to prioritize reads. For the synchronous version of this function, see <a class="el" href="classGio_1_1BufferedInputStream.html#a197687762599fb7c5b60141b55120cde" title="Tries to read count bytes from the stream into the buffer.">fill()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A AsyncReadyCallback. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">io_priority</td><td>the I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadb9c1b367e36c20c91e16ea840b6ef0"></a><!-- doxytag: member="Gio::BufferedInputStream::fill_async" ref="aadb9c1b367e36c20c91e16ea840b6ef0" args="(const SlotAsyncReady &amp;slot, gssize count, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1BufferedInputStream.html#a0a41790e04e9ba500eb18d1ce8371d34">Gio::BufferedInputStream::fill_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads data into the stream's buffer asynchronously, up to <em>count</em> size. </p>
<p><em>io_priority</em> can be used to prioritize reads. For the synchronous version of this function, see <a class="el" href="classGio_1_1BufferedInputStream.html#a197687762599fb7c5b60141b55120cde" title="Tries to read count bytes from the stream into the buffer.">fill()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A AsyncReadyCallback. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">io_priority</td><td>the I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13c665ccc722a2544539086846137277"></a><!-- doxytag: member="Gio::BufferedInputStream::fill_finish" ref="a13c665ccc722a2544539086846137277" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize <a class="el" href="classGio_1_1BufferedInputStream.html#a13c665ccc722a2544539086846137277">Gio::BufferedInputStream::fill_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an asynchronous read. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A #gssize of the read stream, or %-1 on an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a436e3c852afdc67e8ba70d32e39ce6b9"></a><!-- doxytag: member="Gio::BufferedInputStream::get_available" ref="a436e3c852afdc67e8ba70d32e39ce6b9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsize <a class="el" href="classGio_1_1BufferedInputStream.html#a436e3c852afdc67e8ba70d32e39ce6b9">Gio::BufferedInputStream::get_available</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of the available data within the stream. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Size of the available stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a46384a96dc052e9d25e1a88281d69e40"></a><!-- doxytag: member="Gio::BufferedInputStream::get_buffer_size" ref="a46384a96dc052e9d25e1a88281d69e40" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsize <a class="el" href="classGio_1_1BufferedInputStream.html#a46384a96dc052e9d25e1a88281d69e40">Gio::BufferedInputStream::get_buffer_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of the input buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current buffer size. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9d0c1e643650b9a45831865f06e21be"></a><!-- doxytag: member="Gio::BufferedInputStream::gobj" ref="aa9d0c1e643650b9a45831865f06e21be" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBufferedInputStream* <a class="el" href="classGio_1_1BufferedInputStream.html#aa9d0c1e643650b9a45831865f06e21be">Gio::BufferedInputStream::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGio_1_1FilterInputStream.html#a6db43589745dcd172f4ca4082bc5d914">Gio::FilterInputStream</a>.</p>

<p>Reimplemented in <a class="el" href="classGio_1_1DataInputStream.html#ad788764326462190e900785f50a50740">Gio::DataInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="ad6b09565f69b4c1cf1f0ca05ee53709e"></a><!-- doxytag: member="Gio::BufferedInputStream::gobj" ref="ad6b09565f69b4c1cf1f0ca05ee53709e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GBufferedInputStream* <a class="el" href="classGio_1_1BufferedInputStream.html#aa9d0c1e643650b9a45831865f06e21be">Gio::BufferedInputStream::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGio_1_1FilterInputStream.html#ac8fbd2cc879bfab4854d952b27ce271c">Gio::FilterInputStream</a>.</p>

<p>Reimplemented in <a class="el" href="classGio_1_1DataInputStream.html#a5d8f01998854eac791a3089acef051c0">Gio::DataInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a47dc5f78b1faed25cdaaafe42b526d6d"></a><!-- doxytag: member="Gio::BufferedInputStream::gobj_copy" ref="a47dc5f78b1faed25cdaaafe42b526d6d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBufferedInputStream* <a class="el" href="classGio_1_1BufferedInputStream.html#a47dc5f78b1faed25cdaaafe42b526d6d">Gio::BufferedInputStream::gobj_copy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

<p>Reimplemented from <a class="el" href="classGio_1_1FilterInputStream.html#a55ef3320e423245cc69066c90785328e">Gio::FilterInputStream</a>.</p>

<p>Reimplemented in <a class="el" href="classGio_1_1DataInputStream.html#a8252806b8ac5548c51a0418162ddb6ab">Gio::DataInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a17a6489d7ab0b72268264c9f0a30e879"></a><!-- doxytag: member="Gio::BufferedInputStream::peek" ref="a17a6489d7ab0b72268264c9f0a30e879" args="(void *buffer, gsize offset, gsize count) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsize <a class="el" href="classGio_1_1BufferedInputStream.html#a17a6489d7ab0b72268264c9f0a30e879">Gio::BufferedInputStream::peek</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Peeks in the buffer, copying data of size <em>count</em> into <em>buffer</em>, offset <em>offset</em> bytes. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A pointer to an allocated chunk of memory. </td></tr>
    <tr><td class="paramname">offset</td><td>A #gsize. </td></tr>
    <tr><td class="paramname">count</td><td>A #gsize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A #gsize of the number of bytes peeked, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a27838d9374fa86ae513bc27d939ede24"></a><!-- doxytag: member="Gio::BufferedInputStream::peek_buffer" ref="a27838d9374fa86ae513bc27d939ede24" args="(gsize &amp;count) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* <a class="el" href="classGio_1_1BufferedInputStream.html#a27838d9374fa86ae513bc27d939ede24">Gio::BufferedInputStream::peek_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the buffer with the currently available bytes. </p>
<p>The returned buffer must not be modified and will become invalid when reading from the stream or filling the buffer. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>A #gsize to get the number of bytes available in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Read-only buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a10be713afc0912c4a5fe89a2c40d943e"></a><!-- doxytag: member="Gio::BufferedInputStream::property_buffer_size" ref="a10be713afc0912c4a5fe89a2c40d943e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; guint &gt; <a class="el" href="classGio_1_1BufferedInputStream.html#a10be713afc0912c4a5fe89a2c40d943e">Gio::BufferedInputStream::property_buffer_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size of the backend buffer. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d77671c76ea9170c32c294d28403378"></a><!-- doxytag: member="Gio::BufferedInputStream::property_buffer_size" ref="a8d77671c76ea9170c32c294d28403378" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; guint &gt; <a class="el" href="classGio_1_1BufferedInputStream.html#a10be713afc0912c4a5fe89a2c40d943e">Gio::BufferedInputStream::property_buffer_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size of the backend buffer. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a85477f09b58dfb83e5a1ef62f119457a"></a><!-- doxytag: member="Gio::BufferedInputStream::read_byte" ref="a85477f09b58dfb83e5a1ef62f119457a" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGio_1_1BufferedInputStream.html#a85477f09b58dfb83e5a1ef62f119457a">Gio::BufferedInputStream::read_byte</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to read a single byte from the stream or the buffer. </p>
<p>Will block during this read.</p>
<p>On success, the byte read from the stream is returned. On end of stream -1 is returned but it's not an exceptional error and <em>error</em> is not set.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. If an operation was partially finished when the operation was cancelled the partial result will be returned, without an error. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The byte read from the <em>stream</em>, or -1 on end of stream or error. </dd></dl>

<p>Reimplemented in <a class="el" href="classGio_1_1DataInputStream.html#aca226b5c2d1248dd079d835dd089570d">Gio::DataInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a8741ffb62c82425f54bc5e005c2a238f"></a><!-- doxytag: member="Gio::BufferedInputStream::read_byte" ref="a8741ffb62c82425f54bc5e005c2a238f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGio_1_1BufferedInputStream.html#a85477f09b58dfb83e5a1ef62f119457a">Gio::BufferedInputStream::read_byte</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-cancellable version of <a class="el" href="classGio_1_1BufferedInputStream.html#a8741ffb62c82425f54bc5e005c2a238f" title="Non-cancellable version of read_byte().">read_byte()</a>. </p>

<p>Reimplemented in <a class="el" href="classGio_1_1DataInputStream.html#af4d01aa4e791d403b79db406befcc28e">Gio::DataInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="af5f861a5b30aadc48e21fb10a46afaa7"></a><!-- doxytag: member="Gio::BufferedInputStream::set_buffer_size" ref="af5f861a5b30aadc48e21fb10a46afaa7" args="(gsize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1BufferedInputStream.html#af5f861a5b30aadc48e21fb10a46afaa7">Gio::BufferedInputStream::set_buffer_size</a> </td>
          <td>(</td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the size of the internal buffer of <em>stream</em> to <em>size</em>, or to the size of the contents of the buffer. </p>
<p>The buffer can never be resized smaller than its current contents. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>A #gsize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="adfe9bf4339f83095d6e96dda7b747575"></a><!-- doxytag: member="Gio::BufferedInputStream::wrap" ref="adfe9bf4339f83095d6e96dda7b747575" args="(GBufferedInputStream *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1BufferedInputStream.html">Gio::BufferedInputStream</a> &gt; <a class="el" href="classGio_1_1BufferedInputStream.html#adfe9bf4339f83095d6e96dda7b747575">wrap</a> </td>
          <td>(</td>
          <td class="paramtype">GBufferedInputStream *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 10 2012 14:20:37 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
