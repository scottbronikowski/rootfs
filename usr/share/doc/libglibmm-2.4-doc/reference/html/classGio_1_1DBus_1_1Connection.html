<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>glibmm: Gio::DBus::Connection Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="/home/murrayc/checkouts/gnome30/glibmm/docs/doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.32.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceGio.html">Gio</a> </li>
      <li class="navelem"><a class="el" href="namespaceGio_1_1DBus.html">DBus</a> </li>
      <li class="navelem"><a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a> </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> </div>
  <div class="headertitle">
<div class="title">Gio::DBus::Connection Class Reference<div class="ingroups"><a class="el" href="group__DBus.html">D-Bus API</a></div></div> </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Gio::DBus::Connection" --><!-- doxytag: inherits="Glib::Object,Gio::Initable,Gio::AsyncInitable" -->
<p>A D-Bus <a class="el" href="classGio_1_1DBus_1_1Connection.html" title="A D-Bus Connection.">Connection</a>.  <a href="classGio_1_1DBus_1_1Connection.html#details">More...</a></p>

<p><code>#include &lt;giomm/dbusconnection.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gio::DBus::Connection:</div>
<div class="dyncontent">
<div class="center"><img src="classGio_1_1DBus_1_1Connection__inherit__graph.png" border="0" usemap="#Gio_1_1DBus_1_1Connection_inherit__map" alt="Inheritance graph"/></div>
<map name="Gio_1_1DBus_1_1Connection_inherit__map" id="Gio_1_1DBus_1_1Connection_inherit__map">
<area shape="rect" id="node2" href="classGlib_1_1Object.html" title="Glib::Object" alt="" coords="5,160,99,189"/><area shape="rect" id="node4" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="52,83,177,112"/><area shape="rect" id="node10" href="classGlib_1_1Interface.html" title="Glib::Interface" alt="" coords="123,160,232,189"/><area shape="rect" id="node6" href="../../../libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="57,5,172,35"/><area shape="rect" id="node8" href="classGio_1_1Initable.html" title="Failable object initialization interface." alt="" coords="89,237,185,267"/><area shape="rect" id="node13" href="classGio_1_1AsyncInitable.html" title="AsyncInitable &#45; Asynchronously failable object initialization interface." alt="" coords="209,237,343,267"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGio_1_1DBus_1_1Connection-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void, <br class="typebreak"/>
const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a> &gt;<br class="typebreak"/>
&amp;, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> <br class="typebreak"/>
&amp;, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> <br class="typebreak"/>
&amp;, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> <br class="typebreak"/>
&amp;, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> <br class="typebreak"/>
&amp;, const <br class="typebreak"/>
<a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>&amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#acecd8faa0ef34d31f74439e71b3c7afc">SlotSignal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for slot used in <a class="el" href="classGio_1_1DBus_1_1Connection.html#af981fb48982bce9d4a27f70127df1cb5" title="Subscribes to signals on the connection and invokes slot with a whenever the signal is received...">signal_subscribe()</a>. <a href="#acecd8faa0ef34d31f74439e71b3c7afc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a><br class="typebreak"/>
&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;<br class="typebreak"/>
, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a> &gt;&amp;, const <br class="typebreak"/>
<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;<br class="typebreak"/>
&amp;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a105c02349fa25ddce651702bb4917869">SlotMessageFilter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for slot used in <a class="el" href="classGio_1_1DBus_1_1Connection.html#a629c7cbe6bd620e240d69db4adf8362e" title="Adds a message filter.">add_filter()</a>. <a href="#a105c02349fa25ddce651702bb4917869"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a596b081d3a033ce4f24fe5c1e07ffe76">~Connection</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GDBusConnection*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#add69f87e326bd9bca8c7f6dc2f0dc26e">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#add69f87e326bd9bca8c7f6dc2f0dc26e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GDBusConnection*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a847a66c3c51c46c57ff96abc8df1a542">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a847a66c3c51c46c57ff96abc8df1a542"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GDBusConnection*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ae347d91fd24a526c1dbdb880ef584bfe">gobj_copy</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. <a href="#ae347d91fd24a526c1dbdb880ef584bfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a3e52adb1ec39322086ea46921086a6e5">close</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the connection. <a href="#a3e52adb1ec39322086ea46921086a6e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a375bd798267feb962c132a45e7374632">close</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the connection. <a href="#a375bd798267feb962c132a45e7374632"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a8fe7ecab2b33dc024906878145750ec6">close</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the connection. <a href="#a8fe7ecab2b33dc024906878145750ec6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a5d909e9af15e824a708b4e588f3ae5e8">close_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an operation started with g_dbus_connection_close(). <a href="#a5d909e9af15e824a708b4e588f3ae5e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ae4d7067d2611ea60fea58b70c2c02b24">close_sync</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously closees the connection. <a href="#ae4d7067d2611ea60fea58b70c2c02b24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#abf8d39afa23b1379e86a0f6b284353a4">close_sync</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously closees <em>connection</em>. <a href="#abf8d39afa23b1379e86a0f6b284353a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a175ef6c874d4cada2e3adfcdaac2fbe9">flush</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously flushes the connection, that is, writes all queued outgoing message to the transport and then flushes the transport (using <a class="el" href="classGio_1_1OutputStream.html#ac76478281be9559cb0a924bcc4ead263" title="Flushes a stream asynchronously.">Gio::OutputStream::flush_async()</a>). <a href="#a175ef6c874d4cada2e3adfcdaac2fbe9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a49483ff5c61943724331d67ebc0206b8">flush</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously flushes the connection, that is, writes all queued outgoing message to the transport and then flushes the transport (using <a class="el" href="classGio_1_1OutputStream.html#ac76478281be9559cb0a924bcc4ead263" title="Flushes a stream asynchronously.">Gio::OutputStream::flush_async()</a>). <a href="#a49483ff5c61943724331d67ebc0206b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ab9018638a894f353a678ab2dfb4f6871">flush</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously flushes the connection, that is, writes all queued outgoing message to the transport and then flushes the transport (using <a class="el" href="classGio_1_1OutputStream.html#ac76478281be9559cb0a924bcc4ead263" title="Flushes a stream asynchronously.">Gio::OutputStream::flush_async()</a>). <a href="#ab9018638a894f353a678ab2dfb4f6871"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a7d42f223b8eb0abb665ab673ff233986">flush_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an operation started with g_dbus_connection_flush(). <a href="#a7d42f223b8eb0abb665ab673ff233986"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a670fdc08181034cc0e0c6648296acca4">flush_sync</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously flushes the connection. <a href="#a670fdc08181034cc0e0c6648296acca4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a230beebae8da6bc51f269faff7c63957">flush_sync</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously flushes <em>connection</em>. <a href="#a230beebae8da6bc51f269faff7c63957"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a51e5d1b5f7166a0db1921f9008863f28">get_exit_on_close</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the process is terminated when <em>connection</em> is closed by the remote peer. <a href="#a51e5d1b5f7166a0db1921f9008863f28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a7457de5a9a316eb6e1b3a9f9093ac635">set_exit_on_close</a> (bool exit_on_close=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the process should be terminated when <em>connection</em> is closed by the remote peer. <a href="#a7457de5a9a316eb6e1b3a9f9093ac635"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#aa7cfa8a2901b8301059a3bee28713037">send_message</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;&amp; message, <a class="el" href="group__giommEnums.html#gab2b457af9dfcf8a106e4b8495d22af2b">SendMessageFlags</a> flags, guint32&amp; out_serial)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sends <em>message</em> to the peer represented by <em>connection</em>. <a href="#aa7cfa8a2901b8301059a3bee28713037"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ad1a7babf2856bea9b12513070c311458">send_message</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;&amp; message, <a class="el" href="group__giommEnums.html#gab2b457af9dfcf8a106e4b8495d22af2b">SendMessageFlags</a> flags=<a class="el" href="group__giommEnums.html#ggab2b457af9dfcf8a106e4b8495d22af2baf93fed1a472ab0c7eb4f51fa35b93577">Gio::DBus::SEND_MESSAGE_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1DBus_1_1Connection.html#aa7cfa8a2901b8301059a3bee28713037" title="Asynchronously sends message to the peer represented by connection.">send_message()</a> without an "out_serial" parameter. <a href="#ad1a7babf2856bea9b12513070c311458"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a90ce8c8c6d8780d47c3d16cfa1b313f6">send_message_with_reply</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;&amp; message, int timeout_msec, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sends message to the peer represented by the connection. <a href="#a90ce8c8c6d8780d47c3d16cfa1b313f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ad218b54738f04a68a40d6d83e7f7a1f6">send_message_with_reply</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;&amp; message, int timeout_msec, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a90ce8c8c6d8780d47c3d16cfa1b313f6" title="Asynchronously sends message to the peer represented by the connection.">send_message_with_reply()</a>. <a href="#ad218b54738f04a68a40d6d83e7f7a1f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a3ccceca6864b5a692805db02224a3de1">send_message_with_reply_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an operation started with g_dbus_connection_send_message_with_reply(). <a href="#a3ccceca6864b5a692805db02224a3de1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a9750c77a26bc9ba12f3c801bc620767d">send_message_with_reply_sync</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;&amp; message, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, gint timeout_msec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously sends <em>message</em> to the peer represented by the connection and blocks the calling thread until a reply is received or the timeout is reached. <a href="#a9750c77a26bc9ba12f3c801bc620767d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ab0b1e37fb685de42b19ded29dbcdccdd">send_message_with_reply_sync</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;&amp; message, gint timeout_msec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a9750c77a26bc9ba12f3c801bc620767d" title="Synchronously sends message to the peer represented by the connection and blocks the calling thread u...">send_message_with_reply_sync()</a>. <a href="#ab0b1e37fb685de42b19ded29dbcdccdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#aa8108e440014500506db4cf1b23ea40a">start_message_processing</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If <em>connection</em> was created with DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method starts processing messages. <a href="#aa8108e440014500506db4cf1b23ea40a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#aa188059029093a62e3d1b3b135e0e79b">is_closed</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether <em>connection</em> is closed. <a href="#aa188059029093a62e3d1b3b135e0e79b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#aebf8f77b4f2aef8d1fa05edce3e48f75">get_stream</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying stream used for IO. <a href="#aebf8f77b4f2aef8d1fa05edce3e48f75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#accaf9db87e08dc4a3cef8917092bd77b">get_stream</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying stream used for IO. <a href="#accaf9db87e08dc4a3cef8917092bd77b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a4bb51d7fc509a98ce5531390ba508804">get_guid</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The GUID of the peer performing the role of server when authenticating. <a href="#a4bb51d7fc509a98ce5531390ba508804"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a0f716d616a32a2e2e7acc210112bc2bc">get_unique_name</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the unique name of <em>connection</em> as assigned by the message bus. <a href="#a0f716d616a32a2e2e7acc210112bc2bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#gadc652797a964763619fdb48a89b42f93">CapabilityFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a791f703904ec858ba568f927d64cb49e">get_capabilities</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the capabilities negotiated with the remote peer. <a href="#a791f703904ec858ba568f927d64cb49e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Credentials.html">Credentials</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ad841b9beb348c2e21dcb9e395ee4f28a">get_peer_credentials</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the credentials of the authenticated peer. <a href="#ad841b9beb348c2e21dcb9e395ee4f28a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1Credentials.html">Credentials</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a2babc0d08159c8b10ffd88c9784c9802">get_peer_credentials</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the credentials of the authenticated peer. <a href="#a2babc0d08159c8b10ffd88c9784c9802"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a8d3e02423495de8270e69cd8d62b7468">call</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; object_path, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; interface_name, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; method_name, const <a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>&amp; parameters, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; bus_name=<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>(), int timeout_msec=-1, <a class="el" href="group__giommEnums.html#gaa2aaa37e1bbc56a65746a9ebc3a5a4db">CallFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa2aaa37e1bbc56a65746a9ebc3a5a4dba58a6f5ca4cfbfa37e2616476b19e66ef">Gio::DBus::CALL_FLAGS_NONE</a>, const <a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>&amp; reply_type=<a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously invokes the <em>method_name</em> method on the <em>interface_name</em> D-Bus interface on the remote object at <em>object_path</em> owned by <em>bus_name</em>. <a href="#a8d3e02423495de8270e69cd8d62b7468"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ac893cdf61255a10e961cebfe01eb3e4e">call</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; object_path, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; interface_name, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; method_name, const <a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>&amp; parameters, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; bus_name=<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>(), int timeout_msec=-1, <a class="el" href="group__giommEnums.html#gaa2aaa37e1bbc56a65746a9ebc3a5a4db">CallFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa2aaa37e1bbc56a65746a9ebc3a5a4dba58a6f5ca4cfbfa37e2616476b19e66ef">Gio::DBus::CALL_FLAGS_NONE</a>, const <a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>&amp; reply_type=<a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a8d3e02423495de8270e69cd8d62b7468" title="Asynchronously invokes the method_name method on the interface_name D-Bus interface on the remote obj...">call()</a>. <a href="#ac893cdf61255a10e961cebfe01eb3e4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a230fbe18c49f2fe73857db0919b14edb">call_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an operation started with <a class="el" href="classGio_1_1DBus_1_1Connection.html#a8d3e02423495de8270e69cd8d62b7468" title="Asynchronously invokes the method_name method on the interface_name D-Bus interface on the remote obj...">call()</a>. <a href="#a230fbe18c49f2fe73857db0919b14edb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a4dff33b1a72b80a4b8250989852515a7">call_sync</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; object_path, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; interface_name, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; method_name, const <a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>&amp; parameters, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; bus_name=<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>(), int timeout_msec=-1, <a class="el" href="group__giommEnums.html#gaa2aaa37e1bbc56a65746a9ebc3a5a4db">CallFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa2aaa37e1bbc56a65746a9ebc3a5a4dba58a6f5ca4cfbfa37e2616476b19e66ef">Gio::DBus::CALL_FLAGS_NONE</a>, const <a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>&amp; reply_type=<a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously invokes the <em>method_name</em> method on the <em>interface_name</em> D-Bus interface on the remote object at <em>object_path</em> owned by <em>bus_name</em>. <a href="#a4dff33b1a72b80a4b8250989852515a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a5ac851e5ccb18bd0adbce4c96e1c5bef">call_sync</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; object_path, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; interface_name, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; method_name, const <a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>&amp; parameters, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; bus_name=<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>(), int timeout_msec=-1, <a class="el" href="group__giommEnums.html#gaa2aaa37e1bbc56a65746a9ebc3a5a4db">CallFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa2aaa37e1bbc56a65746a9ebc3a5a4dba58a6f5ca4cfbfa37e2616476b19e66ef">Gio::DBus::CALL_FLAGS_NONE</a>, const <a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>&amp; reply_type=<a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a4dff33b1a72b80a4b8250989852515a7" title="Synchronously invokes the method_name method on the interface_name D-Bus interface on the remote obje...">call_sync()</a>. <a href="#a5ac851e5ccb18bd0adbce4c96e1c5bef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#aae264d3104fe85f8482580db5b7761fa">emit_signal</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; object_path, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; interface_name, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; signal_name, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; destination_bus_name=<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>(), const <a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>&amp; parameters=<a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an operation started with <a class="el" href="classGio_1_1DBus_1_1Connection.html#a8d3e02423495de8270e69cd8d62b7468" title="Asynchronously invokes the method_name method on the interface_name D-Bus interface on the remote obj...">call()</a> (with a <a class="el" href="classGio_1_1UnixFDList.html" title="UnixFDList - An object containing a set of UNIX file descriptors.">UnixFDList</a>). <a href="#aae264d3104fe85f8482580db5b7761fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af981fb48982bce9d4a27f70127df1cb5">signal_subscribe</a> (const <a class="el" href="classGio_1_1DBus_1_1Connection.html#acecd8faa0ef34d31f74439e71b3c7afc">SlotSignal</a>&amp; slot, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; sender=<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>(), const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; interface_name=<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>(), const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; member=<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>(), const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; object_path=<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>(), const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; arg0=<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>(), <a class="el" href="group__giommEnums.html#ga5978f448a9187eca418eac34799144fa">SignalFlags</a> flags=<a class="el" href="group__giommEnums.html#gga5978f448a9187eca418eac34799144faa08f72890c46ff66ff5df6ea3bbc2d526">Gio::DBus::SIGNAL_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes to signals on the connection and invokes <em>slot</em> with a whenever the signal is received. <a href="#af981fb48982bce9d4a27f70127df1cb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a57d8deeb855f3f88d5a2164d224305ea">signal_unsubscribe</a> (guint subscription_id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribes from signals. <a href="#a57d8deeb855f3f88d5a2164d224305ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a629c7cbe6bd620e240d69db4adf8362e">add_filter</a> (const <a class="el" href="classGio_1_1DBus_1_1Connection.html#a105c02349fa25ddce651702bb4917869">SlotMessageFilter</a>&amp; slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a message filter. <a href="#a629c7cbe6bd620e240d69db4adf8362e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#aa5f078c02692ec5effae8dccbbff2e55">remove_filter</a> (guint filter_id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a filter. <a href="#aa5f078c02692ec5effae8dccbbff2e55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a0c2974543543686c386601b656577593">register_object</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; object_path, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1InterfaceInfo.html">InterfaceInfo</a> &gt;&amp; interface_info, const <a class="el" href="classGio_1_1DBus_1_1InterfaceVTable.html">InterfaceVTable</a>&amp; vtable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers slots for exported objects at <em>object_path</em> with the D-Bus interface that is described in <em>interface_info</em>. <a href="#a0c2974543543686c386601b656577593"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ad8e4a523adc691ff00d946df0fc779c6">register_object</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; object_path, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1InterfaceInfo.html">InterfaceInfo</a> &gt;&amp; interface_info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers exported objects at <em>object_path</em> with the D-Bus interface that is described in <em>interface_info</em>. <a href="#ad8e4a523adc691ff00d946df0fc779c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a32b998fc3e093c678e6ff4e76ec29874">unregister_object</a> (guint registration_id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters an object. <a href="#a32b998fc3e093c678e6ff4e76ec29874"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ade98c63ff3e2ce7906ca4a2f63849e07">register_subtree</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; object_path, const <a class="el" href="classGio_1_1DBus_1_1SubtreeVTable.html">SubtreeVTable</a>&amp; vtable, <a class="el" href="group__giommEnums.html#ga57ca559dd8d3b93c96c4828cb457b975">SubtreeFlags</a> flags=<a class="el" href="group__giommEnums.html#gga57ca559dd8d3b93c96c4828cb457b975aa8559c8d4072f25d7aeaa9b08bc93c66">Gio::DBus::SUBTREE_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a whole subtree of “dynamic” objects. <a href="#ade98c63ff3e2ce7906ca4a2f63849e07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#aae026eab32dc1e6ef7eb865e2d83dc1d">unregister_subtree</a> (guint registration_id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a subtree. <a href="#aae026eab32dc1e6ef7eb865e2d83dc1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a2e5b3f466471359b4595b5846508c1a2">export_action_group</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; object_path, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1ActionGroup.html">ActionGroup</a> &gt;&amp; action_group)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports <em>action_group</em> on <em>connection</em> at <em>object_path</em>. <a href="#a2e5b3f466471359b4595b5846508c1a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a1538b4a84bd4cb0457ba6e6dde0023b3">unexport_action_group</a> (guint export_id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the effect of a previous call to g_dbus_connection_export_action_group(). <a href="#a1538b4a84bd4cb0457ba6e6dde0023b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ad1595ae3e1d1f1c123245d488719923c">export_menu_model</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; object_path, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1MenuModel.html">MenuModel</a> &gt;&amp; menu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports <em>menu</em> on <em>connection</em> at <em>object_path</em>. <a href="#ad1595ae3e1d1f1c123245d488719923c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a3b99e116bcc0a8d15cf0e9c857c62e07">unexport_menu_model</a> (guint export_id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the effect of a previous call to g_dbus_connection_export_menu_model(). <a href="#a3b99e116bcc0a8d15cf0e9c857c62e07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="group__giommEnums.html#gadc652797a964763619fdb48a89b42f93">CapabilityFlags</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ad66c7d3c04c0a39e46a9a5342dc91a59">property_capabilities</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Capabilities. <a href="#ad66c7d3c04c0a39e46a9a5342dc91a59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a8a23822f8e767a79b37238f110eef77c">property_closed</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the connection is closed. <a href="#a8a23822f8e767a79b37238f110eef77c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a05f97a97a09455e024a2f26994d49edd">property_exit_on_close</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the process is terminated when the connection is closed. <a href="#a05f97a97a09455e024a2f26994d49edd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af3402d2b61aee521e7a459067053157d">property_exit_on_close</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the process is terminated when the connection is closed. <a href="#af3402d2b61aee521e7a459067053157d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a13b65cb8957de1a08f67b2a8d6e9c8e6">property_guid</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">GUID of the server peer. <a href="#a13b65cb8957de1a08f67b2a8d6e9c8e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#abefe6a30bf9f66095c24c07c5e535e17">property_stream</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying streams used for I/O. <a href="#abefe6a30bf9f66095c24c07c5e535e17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a991a3b749663686639bc0644b139c65d">property_unique_name</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique name of bus connection. <a href="#a991a3b749663686639bc0644b139c65d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1SignalProxy2.html">Glib::SignalProxy2</a>&lt; void, bool, <br class="typebreak"/>
const <a class="el" href="classGlib_1_1Error.html">Glib::Error</a>&amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a99d65f5ee4424eb0e48fd1725ff6ab37">signal_closed</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a5345c2d7d7f861b0ea4ac67dffd7d5ce">get</a> (<a class="el" href="group__giommEnums.html#gaa00806111608557f425bf09bdf4b0087">BusType</a> bus_type, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously connects to the message bus specified by <em>bus_type</em>. <a href="#a5345c2d7d7f861b0ea4ac67dffd7d5ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a96b8301d5d4e6a273e4bdb7778d44062">get</a> (<a class="el" href="group__giommEnums.html#gaa00806111608557f425bf09bdf4b0087">BusType</a> bus_type, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a5345c2d7d7f861b0ea4ac67dffd7d5ce" title="Asynchronously connects to the message bus specified by bus_type.">get()</a>. <a href="#a96b8301d5d4e6a273e4bdb7778d44062"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a20675d9ff219ddd7b9cd5d1ba4a88bbc">get_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an operation started with g_bus_get(). <a href="#a20675d9ff219ddd7b9cd5d1ba4a88bbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#aa9f6ff4fb7546a1600331322b33fbbfb">get_sync</a> (<a class="el" href="group__giommEnums.html#gaa00806111608557f425bf09bdf4b0087">BusType</a> bus_type, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously connects to the message bus specified by <em>bus_type</em>. <a href="#aa9f6ff4fb7546a1600331322b33fbbfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ae29f76f48d11685c100e8c880e36b3fd">get_sync</a> (<a class="el" href="group__giommEnums.html#gaa00806111608557f425bf09bdf4b0087">BusType</a> bus_type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#aa9f6ff4fb7546a1600331322b33fbbfb" title="Synchronously connects to the message bus specified by bus_type.">get_sync()</a>. <a href="#ae29f76f48d11685c100e8c880e36b3fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ab8be27670e0620aad315dfc0c1622ab6">create</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp; stream, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; guid, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp; observer, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets up a D-Bus connection for exchanging D-Bus messages with the end represented by <em>stream</em>. <a href="#ab8be27670e0620aad315dfc0c1622ab6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a1dcee35e3382f914ad5be4826280863f">create</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp; stream, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; guid, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets up a D-Bus connection for exchanging D-Bus messages with the end represented by <em>stream</em>. <a href="#a1dcee35e3382f914ad5be4826280863f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a6128ef85de1f6a2a51fcd91275e68162">create</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp; stream, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; guid, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp; observer, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#ab8be27670e0620aad315dfc0c1622ab6" title="Asynchronously sets up a D-Bus connection for exchanging D-Bus messages with the end represented by s...">create()</a>. <a href="#a6128ef85de1f6a2a51fcd91275e68162"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ab8706a0e8d8f2da249570e5547269c72">create</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp; stream, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; guid, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#ab8be27670e0620aad315dfc0c1622ab6" title="Asynchronously sets up a D-Bus connection for exchanging D-Bus messages with the end represented by s...">create()</a>. <a href="#ab8706a0e8d8f2da249570e5547269c72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a8c3932d624428f9690f86fa2b2dcee65">create_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an operation started with g_dbus_connection_new(). <a href="#a8c3932d624428f9690f86fa2b2dcee65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a2cfcac77627389fa35f59b52118fe0c5">create_for_address</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; address, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp; observer, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously connects and sets up a D-Bus client connection for exchanging D-Bus messages with an endpoint specified by <em>address</em> which must be in the D-Bus address format. <a href="#a2cfcac77627389fa35f59b52118fe0c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a27dedd455d630f22c3e4b1023fce7bd1">create_for_address</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; address, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously connects and sets up a D-Bus client connection for exchanging D-Bus messages with an endpoint specified by <em>address</em> which must be in the D-Bus address format. <a href="#a27dedd455d630f22c3e4b1023fce7bd1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a7541aa16a44ecc8ed8d64f143db86ebc">create_for_address</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; address, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp; observer, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2cfcac77627389fa35f59b52118fe0c5" title="Asynchronously connects and sets up a D-Bus client connection for exchanging D-Bus messages with an e...">create_for_address()</a>. <a href="#a7541aa16a44ecc8ed8d64f143db86ebc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a7121db082da9ce50211bfab69809837b">create_for_address</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; address, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2cfcac77627389fa35f59b52118fe0c5" title="Asynchronously connects and sets up a D-Bus client connection for exchanging D-Bus messages with an e...">create_for_address()</a>. <a href="#a7121db082da9ce50211bfab69809837b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a4ae2f4459a49c6c839758c38ecdd3672">create_for_address_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an operation started with g_dbus_connection_new_for_address(). <a href="#a4ae2f4459a49c6c839758c38ecdd3672"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a2f7a4d6ca323970acefe79bbbba13249">create_sync</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp; stream, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; guid, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp; observer, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously sets up a D-Bus connection for exchanging D-Bus messages with the end represented by <em>stream</em>. <a href="#a2f7a4d6ca323970acefe79bbbba13249"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#aec7e858016e9d3ae71d0c3012a91a523">create_sync</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp; stream, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; guid, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously sets up a D-Bus connection for exchanging D-Bus messages with the end represented by <em>stream</em>. <a href="#aec7e858016e9d3ae71d0c3012a91a523"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ad43388dd55566edb548d64e32ea36985">create_sync</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp; stream, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; guid, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp; observer, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2f7a4d6ca323970acefe79bbbba13249" title="Synchronously sets up a D-Bus connection for exchanging D-Bus messages with the end represented by st...">create_sync()</a>. <a href="#ad43388dd55566edb548d64e32ea36985"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#aad07acd92fd5f4ed311ea58b1b34283c">create_sync</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp; stream, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; guid, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2f7a4d6ca323970acefe79bbbba13249" title="Synchronously sets up a D-Bus connection for exchanging D-Bus messages with the end represented by st...">create_sync()</a>. <a href="#aad07acd92fd5f4ed311ea58b1b34283c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a112688a795a494f3cce20a04a970e4ef">create_for_address_sync</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; address, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp; observer, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously connects and sets up a D-Bus client connection for exchanging D-Bus messages with an endpoint specified by <em>address</em> which must be in the D-Bus address format. <a href="#a112688a795a494f3cce20a04a970e4ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a253cf6aaeb3ff39e1592e85f1a345f83">create_for_address_sync</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; address, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously connects and sets up a D-Bus client connection for exchanging D-Bus messages with an endpoint specified by <em>address</em> which must be in the D-Bus address format. <a href="#a253cf6aaeb3ff39e1592e85f1a345f83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a86f0ea860d112f58106d301affaa8561">create_for_address_sync</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; address, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp; observer, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a112688a795a494f3cce20a04a970e4ef" title="Synchronously connects and sets up a D-Bus client connection for exchanging D-Bus messages with an en...">create_for_address_sync()</a>. <a href="#a86f0ea860d112f58106d301affaa8561"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a8f8b7483eba4c31bafb913897e5b8fdd">create_for_address_sync</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; address, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags=<a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a112688a795a494f3cce20a04a970e4ef" title="Synchronously connects and sets up a D-Bus client connection for exchanging D-Bus messages with an en...">create_for_address_sync()</a>. <a href="#a8f8b7483eba4c31bafb913897e5b8fdd"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Connection</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp; stream, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; guid, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp; observer, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#aea70bb4950131f4d82369c4cf7ff1ff3">Connection</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp; stream, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; guid, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a8a5dba32c3c0e009d5d708ffa01103ee">Connection</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp; stream, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; guid, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp; observer, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#aa8f6f71d2be7e766d18e9f821cb395a2">Connection</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp; stream, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; guid, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a49a0547444d8d1163539846819ad8d6a">Connection</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp; stream, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; guid, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp; observer, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a54fdc2908d6d79353d20811ac5294043">Connection</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp; stream, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; guid, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a1e3ec1b9a12e9d9bdf75282369beae67">Connection</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp; stream, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; guid, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp; observer, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#ad378cce5c5a126f53777974b61344b48">Connection</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp; stream, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; guid, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a58cdb0630ee4653cb6aacf05e4d658f5">Connection</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; address, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp; observer, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#aa9d757914a177ecad860411a8577dbf8">Connection</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; address, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a2cc37e887b2682139f50384b91d353aa">Connection</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; address, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp; observer, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a11b17fe1e5dffc1a0a172f0567f13cd4">Connection</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; address, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#aea75f881fbeb206f61a58361343a6daa">Connection</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; address, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp; observer, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a45dd0879fd3bf7bd84fd6c2ad27f7f38">Connection</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; address, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#aff151a70d4b13e138b5417c0ee4becaf">Connection</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; address, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp; observer, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a6e0b9bacc7173bb7020506cfcd66cde3">Connection</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; address, <a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a> flags)</td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Gio::DBus::Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DBus_1_1Connection.html#a0969ed44cfb18e10af19b6eec245e420">wrap</a> (GDBusConnection* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#a0969ed44cfb18e10af19b6eec245e420"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A D-Bus <a class="el" href="classGio_1_1DBus_1_1Connection.html" title="A D-Bus Connection.">Connection</a>. </p>
<p>The <a class="el" href="classGio_1_1DBus_1_1Connection.html" title="A D-Bus Connection.">Connection</a> type is used for D-Bus connections to remote peers such as a message buses. It is a low-level API that offers a lot of flexibility. For instance, it lets you establish a connection over any transport that can by represented as an <a class="el" href="classGio_1_1IOStream.html">IOStream</a>.</p>
<p>This class is rarely used directly in D-Bus clients. If you are writing a D-Bus client, it is often easier to use the <a class="el" href="group__DBus.html#ga6e63011eb298f04364d38d44ae51d1e5" title="Starts acquiring name on the bus specified by bus_type and calls name_acquired_slot and name_lost_slo...">Gio::DBus::own_name()</a>, <a class="el" href="group__DBus.html#gaa202af27755f2ea8d0736f8ab3a75dba" title="Starts watching name on the bus specified by bus_type and calls name_appeared_slot and name_vanished_...">Gio::DBus::watch_name()</a> or <a class="el" href="classGio_1_1DBus_1_1Proxy.html#a5cdd31131561783868e2ae4301243abe" title="Like g_dbus_proxy_new() but takes a BusType instead of a DBusConnection.">Gio::DBus::Proxy::create_for_bus()</a> APIs.</p>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000115">Since glibmm 2.28:</a></b></dt><dd></dd></dl>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a105c02349fa25ddce651702bb4917869"></a><!-- doxytag: member="Gio::DBus::Connection::SlotMessageFilter" ref="a105c02349fa25ddce651702bb4917869" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a>&gt;, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a>&gt;&amp;, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a>&gt;&amp;, bool&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a105c02349fa25ddce651702bb4917869">Gio::DBus::Connection::SlotMessageFilter</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signature for slot used in <a class="el" href="classGio_1_1DBus_1_1Connection.html#a629c7cbe6bd620e240d69db4adf8362e" title="Adds a message filter.">add_filter()</a>. </p>
<p>For example, </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classGlib_1_1RefPtr.html" title="RefPtr&lt;&gt; is a reference-counting shared smartpointer.">Glib::RefPtr&lt;Message&gt;</a> on_message_filter(<span class="keyword">const</span>
 <a class="code" href="classGlib_1_1RefPtr.html" title="RefPtr&lt;&gt; is a reference-counting shared smartpointer.">Glib::RefPtr&lt;Connection&gt;</a> connection, <span class="keyword">const</span> <a class="code" href="classGlib_1_1RefPtr.html" title="RefPtr&lt;&gt; is a reference-counting shared smartpointer.">Glib::RefPtr&lt;Message&gt;</a>&amp;
 message, <span class="keywordtype">bool</span> incoming);.
</pre></div><p>A filter function is passed a <a class="el" href="classGio_1_1DBus_1_1Message.html" title="A type for representing D-Bus messages that can be sent or received on a Connection.">Message</a> and expected to return a <a class="el" href="classGio_1_1DBus_1_1Message.html" title="A type for representing D-Bus messages that can be sent or received on a Connection.">Message</a> too. Passive filter functions that don't modify the message can simply return the message object. Filter functions that wants to drop a message can simply return <code>0</code>. And filter function may modify a message by copying it and return the copy. </p>

</div>
</div>
<a class="anchor" id="acecd8faa0ef34d31f74439e71b3c7afc"></a><!-- doxytag: member="Gio::DBus::Connection::SlotSignal" ref="acecd8faa0ef34d31f74439e71b3c7afc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;void, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a>&gt;&amp;, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;, const <a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>&amp;&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#acecd8faa0ef34d31f74439e71b3c7afc">Gio::DBus::Connection::SlotSignal</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signature for slot used in <a class="el" href="classGio_1_1DBus_1_1Connection.html#af981fb48982bce9d4a27f70127df1cb5" title="Subscribes to signals on the connection and invokes slot with a whenever the signal is received...">signal_subscribe()</a>. </p>
<p>For example, </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> on_signal(<span class="keyword">const</span> <a class="code" href="classGlib_1_1RefPtr.html" title="RefPtr&lt;&gt; is a reference-counting shared smartpointer.">Glib::RefPtr&lt;Connection&gt;</a>&amp; connection, <span class="keyword">const</span>
 <a class="code" href="classGlib_1_1ustring.html" title="Glib::ustring has much the same interface as std::string, but contains Unicode characters encoded as ...">Glib::ustring</a>&amp; sender_name, <span class="keyword">const</span> <a class="code" href="classGlib_1_1ustring.html" title="Glib::ustring has much the same interface as std::string, but contains Unicode characters encoded as ...">Glib::ustring</a>&amp; object_path, <span class="keyword">const</span>
 <a class="code" href="classGlib_1_1ustring.html" title="Glib::ustring has much the same interface as std::string, but contains Unicode characters encoded as ...">Glib::ustring</a>&amp; object_path, <span class="keyword">const</span> <a class="code" href="classGlib_1_1ustring.html" title="Glib::ustring has much the same interface as std::string, but contains Unicode characters encoded as ...">Glib::ustring</a>&amp; interface_name, <span class="keyword">const</span>
 <a class="code" href="classGlib_1_1ustring.html" title="Glib::ustring has much the same interface as std::string, but contains Unicode characters encoded as ...">Glib::ustring</a>&amp; signal_name, <span class="keyword">const</span> <a class="code" href="classGlib_1_1VariantContainerBase.html" title="The base class from which multiple-item Variants derive, such as Variants containing tuples or arrays...">Glib::VariantContainerBase</a>&amp; parameters);.
</pre></div> </div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a596b081d3a033ce4f24fe5c1e07ffe76"></a><!-- doxytag: member="Gio::DBus::Connection::~Connection" ref="a596b081d3a033ce4f24fe5c1e07ffe76" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGio_1_1DBus_1_1Connection.html#a596b081d3a033ce4f24fe5c1e07ffe76">Gio::DBus::Connection::~Connection</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af878a70230eb69d741b2d1c8232cc913"></a><!-- doxytag: member="Gio::DBus::Connection::Connection" ref="af878a70230eb69d741b2d1c8232cc913" args="(const Glib::RefPtr&lt; IOStream &gt; &amp;stream, const std::string &amp;guid, const Glib::RefPtr&lt; AuthObserver &gt; &amp;observer, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, ConnectionFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Gio::DBus::Connection::Connection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aea70bb4950131f4d82369c4cf7ff1ff3"></a><!-- doxytag: member="Gio::DBus::Connection::Connection" ref="aea70bb4950131f4d82369c4cf7ff1ff3" args="(const Glib::RefPtr&lt; IOStream &gt; &amp;stream, const std::string &amp;guid, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, ConnectionFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Gio::DBus::Connection::Connection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8a5dba32c3c0e009d5d708ffa01103ee"></a><!-- doxytag: member="Gio::DBus::Connection::Connection" ref="a8a5dba32c3c0e009d5d708ffa01103ee" args="(const Glib::RefPtr&lt; IOStream &gt; &amp;stream, const std::string &amp;guid, const Glib::RefPtr&lt; AuthObserver &gt; &amp;observer, const SlotAsyncReady &amp;slot, ConnectionFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Gio::DBus::Connection::Connection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa8f6f71d2be7e766d18e9f821cb395a2"></a><!-- doxytag: member="Gio::DBus::Connection::Connection" ref="aa8f6f71d2be7e766d18e9f821cb395a2" args="(const Glib::RefPtr&lt; IOStream &gt; &amp;stream, const std::string &amp;guid, const SlotAsyncReady &amp;slot, ConnectionFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Gio::DBus::Connection::Connection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a49a0547444d8d1163539846819ad8d6a"></a><!-- doxytag: member="Gio::DBus::Connection::Connection" ref="a49a0547444d8d1163539846819ad8d6a" args="(const Glib::RefPtr&lt; IOStream &gt; &amp;stream, const std::string &amp;guid, const Glib::RefPtr&lt; AuthObserver &gt; &amp;observer, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, ConnectionFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Gio::DBus::Connection::Connection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a54fdc2908d6d79353d20811ac5294043"></a><!-- doxytag: member="Gio::DBus::Connection::Connection" ref="a54fdc2908d6d79353d20811ac5294043" args="(const Glib::RefPtr&lt; IOStream &gt; &amp;stream, const std::string &amp;guid, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, ConnectionFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Gio::DBus::Connection::Connection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e3ec1b9a12e9d9bdf75282369beae67"></a><!-- doxytag: member="Gio::DBus::Connection::Connection" ref="a1e3ec1b9a12e9d9bdf75282369beae67" args="(const Glib::RefPtr&lt; IOStream &gt; &amp;stream, const std::string &amp;guid, const Glib::RefPtr&lt; AuthObserver &gt; &amp;observer, ConnectionFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Gio::DBus::Connection::Connection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad378cce5c5a126f53777974b61344b48"></a><!-- doxytag: member="Gio::DBus::Connection::Connection" ref="ad378cce5c5a126f53777974b61344b48" args="(const Glib::RefPtr&lt; IOStream &gt; &amp;stream, const std::string &amp;guid, ConnectionFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Gio::DBus::Connection::Connection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a58cdb0630ee4653cb6aacf05e4d658f5"></a><!-- doxytag: member="Gio::DBus::Connection::Connection" ref="a58cdb0630ee4653cb6aacf05e4d658f5" args="(const std::string &amp;address, const Glib::RefPtr&lt; AuthObserver &gt; &amp;observer, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, ConnectionFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Gio::DBus::Connection::Connection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa9d757914a177ecad860411a8577dbf8"></a><!-- doxytag: member="Gio::DBus::Connection::Connection" ref="aa9d757914a177ecad860411a8577dbf8" args="(const std::string &amp;address, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, ConnectionFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Gio::DBus::Connection::Connection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2cc37e887b2682139f50384b91d353aa"></a><!-- doxytag: member="Gio::DBus::Connection::Connection" ref="a2cc37e887b2682139f50384b91d353aa" args="(const std::string &amp;address, const Glib::RefPtr&lt; AuthObserver &gt; &amp;observer, const SlotAsyncReady &amp;slot, ConnectionFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Gio::DBus::Connection::Connection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a11b17fe1e5dffc1a0a172f0567f13cd4"></a><!-- doxytag: member="Gio::DBus::Connection::Connection" ref="a11b17fe1e5dffc1a0a172f0567f13cd4" args="(const std::string &amp;address, const SlotAsyncReady &amp;slot, ConnectionFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Gio::DBus::Connection::Connection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aea75f881fbeb206f61a58361343a6daa"></a><!-- doxytag: member="Gio::DBus::Connection::Connection" ref="aea75f881fbeb206f61a58361343a6daa" args="(const std::string &amp;address, const Glib::RefPtr&lt; AuthObserver &gt; &amp;observer, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, ConnectionFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Gio::DBus::Connection::Connection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a45dd0879fd3bf7bd84fd6c2ad27f7f38"></a><!-- doxytag: member="Gio::DBus::Connection::Connection" ref="a45dd0879fd3bf7bd84fd6c2ad27f7f38" args="(const std::string &amp;address, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, ConnectionFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Gio::DBus::Connection::Connection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aff151a70d4b13e138b5417c0ee4becaf"></a><!-- doxytag: member="Gio::DBus::Connection::Connection" ref="aff151a70d4b13e138b5417c0ee4becaf" args="(const std::string &amp;address, const Glib::RefPtr&lt; AuthObserver &gt; &amp;observer, ConnectionFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Gio::DBus::Connection::Connection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6e0b9bacc7173bb7020506cfcd66cde3"></a><!-- doxytag: member="Gio::DBus::Connection::Connection" ref="a6e0b9bacc7173bb7020506cfcd66cde3" args="(const std::string &amp;address, ConnectionFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DBus_1_1Connection.html#af878a70230eb69d741b2d1c8232cc913">Gio::DBus::Connection::Connection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a629c7cbe6bd620e240d69db4adf8362e"></a><!-- doxytag: member="Gio::DBus::Connection::add_filter" ref="a629c7cbe6bd620e240d69db4adf8362e" args="(const SlotMessageFilter &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint <a class="el" href="classGio_1_1DBus_1_1Connection.html#a629c7cbe6bd620e240d69db4adf8362e">Gio::DBus::Connection::add_filter</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGio_1_1DBus_1_1Connection.html#a105c02349fa25ddce651702bb4917869">SlotMessageFilter</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a message filter. </p>
<p>Filters are handlers that are run on all incoming and outgoing messages, prior to standard dispatch. Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter slot won't be run on the message being processed. Filter slots are allowed to modify and even drop messages.</p>
<p>Note that filters are run in a dedicated message handling thread so they can't block and, generally, can't do anything but signal a worker thread. Also note that filters are rarely needed - use API such as <a class="el" href="classGio_1_1DBus_1_1Connection.html#a90ce8c8c6d8780d47c3d16cfa1b313f6" title="Asynchronously sends message to the peer represented by the connection.">send_message_with_reply()</a>, <a class="el" href="classGio_1_1DBus_1_1Connection.html#af981fb48982bce9d4a27f70127df1cb5" title="Subscribes to signals on the connection and invokes slot with a whenever the signal is received...">signal_subscribe()</a> or <a class="el" href="classGio_1_1DBus_1_1Connection.html#a8d3e02423495de8270e69cd8d62b7468" title="Asynchronously invokes the method_name method on the interface_name D-Bus interface on the remote obj...">call()</a> instead.</p>
<p>If a filter consumes an incoming message the message is not dispatched anywhere else - not even the standard dispatch machinery (that API such as <a class="el" href="classGio_1_1DBus_1_1Connection.html#af981fb48982bce9d4a27f70127df1cb5" title="Subscribes to signals on the connection and invokes slot with a whenever the signal is received...">signal_subscribe()</a> and <a class="el" href="classGio_1_1DBus_1_1Connection.html#a90ce8c8c6d8780d47c3d16cfa1b313f6" title="Asynchronously sends message to the peer represented by the connection.">send_message_with_reply()</a> relies on) will see the message. Similary, if a filter consumes an outgoing message, the message will not be sent to the other peer.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A filter slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A filter identifier that can be used with <a class="el" href="classGio_1_1DBus_1_1Connection.html#aa5f078c02692ec5effae8dccbbff2e55" title="Removes a filter.">remove_filter()</a>. </dd></dl>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000132">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8d3e02423495de8270e69cd8d62b7468"></a><!-- doxytag: member="Gio::DBus::Connection::call" ref="a8d3e02423495de8270e69cd8d62b7468" args="(const Glib::ustring &amp;object_path, const Glib::ustring &amp;interface_name, const Glib::ustring &amp;method_name, const Glib::VariantContainerBase &amp;parameters, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const Glib::ustring &amp;bus_name=Glib::ustring(), int timeout_msec=&#45;1, CallFlags flags=Gio::DBus::CALL_FLAGS_NONE, const Glib::VariantType &amp;reply_type=Glib::VariantType())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a8d3e02423495de8270e69cd8d62b7468">Gio::DBus::Connection::call</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>object_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>&amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>bus_name</em> = <code><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa2aaa37e1bbc56a65746a9ebc3a5a4db">CallFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa2aaa37e1bbc56a65746a9ebc3a5a4dba58a6f5ca4cfbfa37e2616476b19e66ef">Gio::DBus::CALL_FLAGS_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>&amp;&#160;</td>
          <td class="paramname"><em>reply_type</em> = <code><a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously invokes the <em>method_name</em> method on the <em>interface_name</em> D-Bus interface on the remote object at <em>object_path</em> owned by <em>bus_name</em>. </p>
<p>If the connection is closed then the operation will fail with <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9ae7313313612066105fb25db853b1e42f">Gio::IO_ERROR_CLOSED</a>. If <em>cancellable</em> is cancelled, the operation will fail with <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9a46652c381d5526249d2dda56e2a17ba4">Gio::IO_ERROR_CANCELLED</a>. If <em>parameters</em> contains a value not compatible with the D-Bus protocol, the operation fails with <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9a1c3061f60b6a9727c6a3744c88958bd7">Gio::IO_ERROR_INVALID_ARGUMENT</a>.</p>
<p>If <em>reply_type</em> is non-<code>0</code> then the reply will be checked for having this type and an error will be raised if it does not match. Said another way, if you give a <em>reply_type</em> then any non-<code>0</code> return value will be of this type.</p>
<p>This is an asynchronous method. When the operation is finished, callback will be invoked in the thread-default main loop of the thread you are calling this method from. You can then call <a class="el" href="classGio_1_1DBus_1_1Connection.html#a230fbe18c49f2fe73857db0919b14edb" title="Finishes an operation started with call().">call_finish()</a> to get the result of the operation. See <a class="el" href="classGio_1_1DBus_1_1Connection.html#a4dff33b1a72b80a4b8250989852515a7" title="Synchronously invokes the method_name method on the interface_name D-Bus interface on the remote obje...">call_sync()</a> for the synchronous version of this function.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object_path</td><td>Path of remote object. </td></tr>
    <tr><td class="paramname">interface_name</td><td>D-Bus interface to invoke method on. </td></tr>
    <tr><td class="paramname">method_name</td><td>The name of the method to invoke. </td></tr>
    <tr><td class="paramname">parameters</td><td>A <a class="el" href="classGlib_1_1VariantContainerBase.html" title="The base class from which multiple-item Variants derive, such as Variants containing tuples or arrays...">Glib::VariantContainerBase</a> tuple with parameters for the method or <code>0</code> if not passing parameters. </td></tr>
    <tr><td class="paramname">slot</td><td>A SlotAsyncReady to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>. </td></tr>
    <tr><td class="paramname">bus_name</td><td>A unique or well-known bus name or <code>0</code> if the connection is not a message bus connection. </td></tr>
    <tr><td class="paramname">timeout_msec</td><td>The timeout in milliseconds, -1 to use the default timeout or G_MAXINT for no timeout. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags from the <a class="el" href="group__giommEnums.html#gaa2aaa37e1bbc56a65746a9ebc3a5a4db">Gio::DBus::CallFlags</a> enumeration. </td></tr>
    <tr><td class="paramname">reply_type</td><td>The expected type of the reply, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000127">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ac893cdf61255a10e961cebfe01eb3e4e"></a><!-- doxytag: member="Gio::DBus::Connection::call" ref="ac893cdf61255a10e961cebfe01eb3e4e" args="(const Glib::ustring &amp;object_path, const Glib::ustring &amp;interface_name, const Glib::ustring &amp;method_name, const Glib::VariantContainerBase &amp;parameters, const SlotAsyncReady &amp;slot, const Glib::ustring &amp;bus_name=Glib::ustring(), int timeout_msec=&#45;1, CallFlags flags=Gio::DBus::CALL_FLAGS_NONE, const Glib::VariantType &amp;reply_type=Glib::VariantType())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a8d3e02423495de8270e69cd8d62b7468">Gio::DBus::Connection::call</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>object_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>&amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>bus_name</em> = <code><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa2aaa37e1bbc56a65746a9ebc3a5a4db">CallFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa2aaa37e1bbc56a65746a9ebc3a5a4dba58a6f5ca4cfbfa37e2616476b19e66ef">Gio::DBus::CALL_FLAGS_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>&amp;&#160;</td>
          <td class="paramname"><em>reply_type</em> = <code><a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a8d3e02423495de8270e69cd8d62b7468" title="Asynchronously invokes the method_name method on the interface_name D-Bus interface on the remote obj...">call()</a>. </p>

</div>
</div>
<a class="anchor" id="a230fbe18c49f2fe73857db0919b14edb"></a><!-- doxytag: member="Gio::DBus::Connection::call_finish" ref="a230fbe18c49f2fe73857db0919b14edb" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a> <a class="el" href="classGio_1_1DBus_1_1Connection.html#a230fbe18c49f2fe73857db0919b14edb">Gio::DBus::Connection::call_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an operation started with <a class="el" href="classGio_1_1DBus_1_1Connection.html#a8d3e02423495de8270e69cd8d62b7468" title="Asynchronously invokes the method_name method on the interface_name D-Bus interface on the remote obj...">call()</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> obtained from the SlotAsyncReady passed to <a class="el" href="classGio_1_1DBus_1_1Connection.html#a8d3e02423495de8270e69cd8d62b7468" title="Asynchronously invokes the method_name method on the interface_name D-Bus interface on the remote obj...">call()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A Variant tuple with return values. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000128">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a4dff33b1a72b80a4b8250989852515a7"></a><!-- doxytag: member="Gio::DBus::Connection::call_sync" ref="a4dff33b1a72b80a4b8250989852515a7" args="(const Glib::ustring &amp;object_path, const Glib::ustring &amp;interface_name, const Glib::ustring &amp;method_name, const Glib::VariantContainerBase &amp;parameters, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const Glib::ustring &amp;bus_name=Glib::ustring(), int timeout_msec=&#45;1, CallFlags flags=Gio::DBus::CALL_FLAGS_NONE, const Glib::VariantType &amp;reply_type=Glib::VariantType())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a> <a class="el" href="classGio_1_1DBus_1_1Connection.html#a4dff33b1a72b80a4b8250989852515a7">Gio::DBus::Connection::call_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>object_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>&amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>bus_name</em> = <code><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa2aaa37e1bbc56a65746a9ebc3a5a4db">CallFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa2aaa37e1bbc56a65746a9ebc3a5a4dba58a6f5ca4cfbfa37e2616476b19e66ef">Gio::DBus::CALL_FLAGS_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>&amp;&#160;</td>
          <td class="paramname"><em>reply_type</em> = <code><a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously invokes the <em>method_name</em> method on the <em>interface_name</em> D-Bus interface on the remote object at <em>object_path</em> owned by <em>bus_name</em>. </p>
<p>If the connection is closed then the operation will fail with <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9ae7313313612066105fb25db853b1e42f">Gio::IO_ERROR_CLOSED</a>. If <em>cancellable</em> is cancelled, the operation will fail with <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9a46652c381d5526249d2dda56e2a17ba4">Gio::IO_ERROR_CANCELLED</a>. If <em>parameters</em> contains a value not compatible with the D-Bus protocol, the operation fails with <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9a1c3061f60b6a9727c6a3744c88958bd7">Gio::IO_ERROR_INVALID_ARGUMENT</a>.</p>
<p>If <em>reply_type</em> is non-<code>0</code> then the reply will be checked for having this type and an error will be raised if it does not match. Said another way, if you give a <em>reply_type</em> then any non-<code>0</code> return value will be of this type.</p>
<p>The calling thread is blocked until a reply is received. See <a class="el" href="classGio_1_1DBus_1_1Connection.html#a8d3e02423495de8270e69cd8d62b7468" title="Asynchronously invokes the method_name method on the interface_name D-Bus interface on the remote obj...">call()</a> for the asynchronous version of this method.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object_path</td><td>Path of remote object. </td></tr>
    <tr><td class="paramname">interface_name</td><td>D-Bus interface to invoke method on. </td></tr>
    <tr><td class="paramname">method_name</td><td>The name of the method to invoke. </td></tr>
    <tr><td class="paramname">parameters</td><td>A <a class="el" href="classGlib_1_1VariantContainerBase.html" title="The base class from which multiple-item Variants derive, such as Variants containing tuples or arrays...">Glib::VariantContainerBase</a> tuple with parameters for the method or <code>0</code> if not passing parameters. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>. </td></tr>
    <tr><td class="paramname">bus_name</td><td>A unique or well-known bus name or <code>0</code> if the connection is not a message bus connection. </td></tr>
    <tr><td class="paramname">timeout_msec</td><td>The timeout in milliseconds, -1 to use the default timeout or G_MAXINT for no timeout. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags from the <a class="el" href="group__giommEnums.html#gaa2aaa37e1bbc56a65746a9ebc3a5a4db">Gio::DBus::CallFlags</a> enumeration. </td></tr>
    <tr><td class="paramname">reply_type</td><td>The expected type of the reply, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A Variant tuple with return values. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000129">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5ac851e5ccb18bd0adbce4c96e1c5bef"></a><!-- doxytag: member="Gio::DBus::Connection::call_sync" ref="a5ac851e5ccb18bd0adbce4c96e1c5bef" args="(const Glib::ustring &amp;object_path, const Glib::ustring &amp;interface_name, const Glib::ustring &amp;method_name, const Glib::VariantContainerBase &amp;parameters, const Glib::ustring &amp;bus_name=Glib::ustring(), int timeout_msec=&#45;1, CallFlags flags=Gio::DBus::CALL_FLAGS_NONE, const Glib::VariantType &amp;reply_type=Glib::VariantType())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a> <a class="el" href="classGio_1_1DBus_1_1Connection.html#a4dff33b1a72b80a4b8250989852515a7">Gio::DBus::Connection::call_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>object_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>&amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>bus_name</em> = <code><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa2aaa37e1bbc56a65746a9ebc3a5a4db">CallFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa2aaa37e1bbc56a65746a9ebc3a5a4dba58a6f5ca4cfbfa37e2616476b19e66ef">Gio::DBus::CALL_FLAGS_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>&amp;&#160;</td>
          <td class="paramname"><em>reply_type</em> = <code><a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a4dff33b1a72b80a4b8250989852515a7" title="Synchronously invokes the method_name method on the interface_name D-Bus interface on the remote obje...">call_sync()</a>. </p>

</div>
</div>
<a class="anchor" id="a3e52adb1ec39322086ea46921086a6e5"></a><!-- doxytag: member="Gio::DBus::Connection::close" ref="a3e52adb1ec39322086ea46921086a6e5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a3e52adb1ec39322086ea46921086a6e5">Gio::DBus::Connection::close</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the connection. </p>
<p>Note that this never causes the process to exit (this might only happen if the other end of a shared message bus connection disconnects, see <a class="el" href="classGio_1_1DBus_1_1Connection.html#a05f97a97a09455e024a2f26994d49edd" title="Whether the process is terminated when the connection is closed.">property_exit_on_close()</a>).</p>
<p>Once the connection is closed, operations such as sending a message will return with the error <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9ae7313313612066105fb25db853b1e42f">Gio::IO_ERROR_CLOSED</a>. Closing a connection will not automatically flush the connection so queued messages may be lost. Use <a class="el" href="classGio_1_1DBus_1_1Connection.html#a175ef6c874d4cada2e3adfcdaac2fbe9" title="Asynchronously flushes the connection, that is, writes all queued outgoing message to the transport a...">flush()</a> if you need such guarantees.</p>
<p>If the connection is already closed, this method fails with <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9ae7313313612066105fb25db853b1e42f">Gio::IO_ERROR_CLOSED</a>.</p>
<p>When the connection has been closed, the "closed" signal is emitted in the thread-default main loop of the thread that connection was constructed in.</p>
<p>This is an asynchronous method. See <a class="el" href="classGio_1_1DBus_1_1Connection.html#ae4d7067d2611ea60fea58b70c2c02b24" title="Synchronously closees the connection.">close_sync()</a> for the synchronous version.</p>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000117">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a375bd798267feb962c132a45e7374632"></a><!-- doxytag: member="Gio::DBus::Connection::close" ref="a375bd798267feb962c132a45e7374632" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a3e52adb1ec39322086ea46921086a6e5">Gio::DBus::Connection::close</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the connection. </p>
<p>Note that this never causes the process to exit (this might only happen if the other end of a shared message bus connection disconnects, see <a class="el" href="classGio_1_1DBus_1_1Connection.html#a05f97a97a09455e024a2f26994d49edd" title="Whether the process is terminated when the connection is closed.">property_exit_on_close()</a>).</p>
<p>Once the connection is closed, operations such as sending a message will return with the error <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9ae7313313612066105fb25db853b1e42f">Gio::IO_ERROR_CLOSED</a>. Closing a connection will not automatically flush the connection so queued messages may be lost. Use <a class="el" href="classGio_1_1DBus_1_1Connection.html#a175ef6c874d4cada2e3adfcdaac2fbe9" title="Asynchronously flushes the connection, that is, writes all queued outgoing message to the transport a...">flush()</a> if you need such guarantees.</p>
<p>If the connection is already closed, this method fails with <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9ae7313313612066105fb25db853b1e42f">Gio::IO_ERROR_CLOSED</a>.</p>
<p>When the connection has been closed, the "closed" signal is emitted in the thread-default main loop of the thread that connection was constructed in.</p>
<p>This is an asynchronous method. When the operation is finished, <em>slot</em> will be invoked in the thread-default main loop of the thread you are calling this method from. You can then call <a class="el" href="classGio_1_1DBus_1_1Connection.html#a5d909e9af15e824a708b4e588f3ae5e8" title="Finishes an operation started with g_dbus_connection_close().">close_finish()</a> to get the result of the operation. See <a class="el" href="classGio_1_1DBus_1_1Connection.html#ae4d7067d2611ea60fea58b70c2c02b24" title="Synchronously closees the connection.">close_sync()</a> for the synchronous version.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A SlotAsyncReady to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000118">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8fe7ecab2b33dc024906878145750ec6"></a><!-- doxytag: member="Gio::DBus::Connection::close" ref="a8fe7ecab2b33dc024906878145750ec6" args="(const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a3e52adb1ec39322086ea46921086a6e5">Gio::DBus::Connection::close</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the connection. </p>
<p>Note that this never causes the process to exit (this might only happen if the other end of a shared message bus connection disconnects, see <a class="el" href="classGio_1_1DBus_1_1Connection.html#a05f97a97a09455e024a2f26994d49edd" title="Whether the process is terminated when the connection is closed.">property_exit_on_close()</a>).</p>
<p>Once the connection is closed, operations such as sending a message will return with the error <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9ae7313313612066105fb25db853b1e42f">Gio::IO_ERROR_CLOSED</a>. Closing a connection will not automatically flush the connection so queued messages may be lost. Use <a class="el" href="classGio_1_1DBus_1_1Connection.html#a175ef6c874d4cada2e3adfcdaac2fbe9" title="Asynchronously flushes the connection, that is, writes all queued outgoing message to the transport a...">flush()</a> if you need such guarantees.</p>
<p>If the connection is already closed, this method fails with <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9ae7313313612066105fb25db853b1e42f">Gio::IO_ERROR_CLOSED</a>.</p>
<p>When the connection has been closed, the "closed" signal is emitted in the thread-default main loop of the thread that connection was constructed in.</p>
<p>This is an asynchronous method. When the operation is finished, <em>slot</em> will be invoked in the thread-default main loop of the thread you are calling this method from. You can then call <a class="el" href="classGio_1_1DBus_1_1Connection.html#a5d909e9af15e824a708b4e588f3ae5e8" title="Finishes an operation started with g_dbus_connection_close().">close_finish()</a> to get the result of the operation. See <a class="el" href="classGio_1_1DBus_1_1Connection.html#ae4d7067d2611ea60fea58b70c2c02b24" title="Synchronously closees the connection.">close_sync()</a> for the synchronous version.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A SlotAsyncReady to call when the request is satisfied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000119">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5d909e9af15e824a708b4e588f3ae5e8"></a><!-- doxytag: member="Gio::DBus::Connection::close_finish" ref="a5d909e9af15e824a708b4e588f3ae5e8" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DBus_1_1Connection.html#a5d909e9af15e824a708b4e588f3ae5e8">Gio::DBus::Connection::close_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an operation started with g_dbus_connection_close(). </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000090">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> obtained from the AsyncReadyCallback passed to g_dbus_connection_close(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the operation succeeded, <code>false</code> if <em>error</em> is set. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4d7067d2611ea60fea58b70c2c02b24"></a><!-- doxytag: member="Gio::DBus::Connection::close_sync" ref="ae4d7067d2611ea60fea58b70c2c02b24" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#ae4d7067d2611ea60fea58b70c2c02b24">Gio::DBus::Connection::close_sync</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously closees the connection. </p>
<p>The calling thread is blocked until this is done. See <a class="el" href="classGio_1_1DBus_1_1Connection.html#a3e52adb1ec39322086ea46921086a6e5" title="Closes the connection.">close()</a> for the asynchronous version of this method and more details about what it does.</p>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000120">Since glibmm 2.28:</a></b></dt><dd></dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf8d39afa23b1379e86a0f6b284353a4"></a><!-- doxytag: member="Gio::DBus::Connection::close_sync" ref="abf8d39afa23b1379e86a0f6b284353a4" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#ae4d7067d2611ea60fea58b70c2c02b24">Gio::DBus::Connection::close_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously closees <em>connection</em>. </p>
<p>The calling thread is blocked until this is done. See g_dbus_connection_close() for the asynchronous version of this method and more details about what it does.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000091">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the operation succeeded, <code>false</code> if <em>error</em> is set. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8be27670e0620aad315dfc0c1622ab6"></a><!-- doxytag: member="Gio::DBus::Connection::create" ref="ab8be27670e0620aad315dfc0c1622ab6" args="(const Glib::RefPtr&lt; IOStream &gt; &amp;stream, const std::string &amp;guid, const Glib::RefPtr&lt; AuthObserver &gt; &amp;observer, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, ConnectionFlags flags=Gio::DBus::CONNECTION_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classGio_1_1DBus_1_1Connection.html#ab8be27670e0620aad315dfc0c1622ab6">Gio::DBus::Connection::create</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously sets up a D-Bus connection for exchanging D-Bus messages with the end represented by <em>stream</em>. </p>
<p>If <em>stream</em> is a <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a>, then the corresponding <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> will be put into non-blocking mode.</p>
<p>The D-Bus connection will interact with <em>stream</em> from a worker thread. As a result, the caller should not interact with <em>stream</em> after this method has been called, except by calling Glib::object_unref() on it.</p>
<p>If <em>observer</em> is not <code>0</code> it may be used to control the authentication process.</p>
<p>When the operation is finished, <em>callback</em> will be invoked. You can then call g_dbus_connection_new_finish() to get the result of the operation.</p>
<p>This is a asynchronous failable constructor. See g_dbus_connection_new_sync() for the synchronous version.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000080">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A <a class="el" href="classGio_1_1IOStream.html">IOStream</a>. </td></tr>
    <tr><td class="paramname">guid</td><td>The GUID to use if a authenticating as a server or <code>0</code>. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags describing how to make the connection. </td></tr>
    <tr><td class="paramname">observer</td><td>A DBusAuthObserver or <code>0</code>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
    <tr><td class="paramname">callback</td><td>A AsyncReadyCallback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">user_data</td><td>The data to pass to <em>callback</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1dcee35e3382f914ad5be4826280863f"></a><!-- doxytag: member="Gio::DBus::Connection::create" ref="a1dcee35e3382f914ad5be4826280863f" args="(const Glib::RefPtr&lt; IOStream &gt; &amp;stream, const std::string &amp;guid, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, ConnectionFlags flags=Gio::DBus::CONNECTION_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classGio_1_1DBus_1_1Connection.html#ab8be27670e0620aad315dfc0c1622ab6">Gio::DBus::Connection::create</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously sets up a D-Bus connection for exchanging D-Bus messages with the end represented by <em>stream</em>. </p>
<p>If <em>stream</em> is a <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a>, then the corresponding <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> will be put into non-blocking mode.</p>
<p>The D-Bus connection will interact with <em>stream</em> from a worker thread. As a result, the caller should not interact with <em>stream</em> after this method has been called, except by calling Glib::object_unref() on it.</p>
<p>If <em>observer</em> is not <code>0</code> it may be used to control the authentication process.</p>
<p>When the operation is finished, <em>callback</em> will be invoked. You can then call g_dbus_connection_new_finish() to get the result of the operation.</p>
<p>This is a asynchronous failable constructor. See g_dbus_connection_new_sync() for the synchronous version.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000081">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A <a class="el" href="classGio_1_1IOStream.html">IOStream</a>. </td></tr>
    <tr><td class="paramname">guid</td><td>The GUID to use if a authenticating as a server or <code>0</code>. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags describing how to make the connection. </td></tr>
    <tr><td class="paramname">observer</td><td>A DBusAuthObserver or <code>0</code>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
    <tr><td class="paramname">callback</td><td>A AsyncReadyCallback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">user_data</td><td>The data to pass to <em>callback</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6128ef85de1f6a2a51fcd91275e68162"></a><!-- doxytag: member="Gio::DBus::Connection::create" ref="a6128ef85de1f6a2a51fcd91275e68162" args="(const Glib::RefPtr&lt; IOStream &gt; &amp;stream, const std::string &amp;guid, const Glib::RefPtr&lt; AuthObserver &gt; &amp;observer, const SlotAsyncReady &amp;slot, ConnectionFlags flags=Gio::DBus::CONNECTION_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classGio_1_1DBus_1_1Connection.html#ab8be27670e0620aad315dfc0c1622ab6">Gio::DBus::Connection::create</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#ab8be27670e0620aad315dfc0c1622ab6" title="Asynchronously sets up a D-Bus connection for exchanging D-Bus messages with the end represented by s...">create()</a>. </p>

</div>
</div>
<a class="anchor" id="ab8706a0e8d8f2da249570e5547269c72"></a><!-- doxytag: member="Gio::DBus::Connection::create" ref="ab8706a0e8d8f2da249570e5547269c72" args="(const Glib::RefPtr&lt; IOStream &gt; &amp;stream, const std::string &amp;guid, const SlotAsyncReady &amp;slot, ConnectionFlags flags=Gio::DBus::CONNECTION_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classGio_1_1DBus_1_1Connection.html#ab8be27670e0620aad315dfc0c1622ab6">Gio::DBus::Connection::create</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#ab8be27670e0620aad315dfc0c1622ab6" title="Asynchronously sets up a D-Bus connection for exchanging D-Bus messages with the end represented by s...">create()</a>. </p>

</div>
</div>
<a class="anchor" id="a8c3932d624428f9690f86fa2b2dcee65"></a><!-- doxytag: member="Gio::DBus::Connection::create_finish" ref="a8c3932d624428f9690f86fa2b2dcee65" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a8c3932d624428f9690f86fa2b2dcee65">Gio::DBus::Connection::create_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an operation started with g_dbus_connection_new(). </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000082">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> obtained from the AsyncReadyCallback passed to g_dbus_connection_new(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A DBusConnection or <code>0</code> if <em>error</em> is set. Free with Glib::object_unref(). </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classGio_1_1AsyncInitable.html#a9545cbf4fe23c6217d32efd2f75b489d">Gio::AsyncInitable</a>.</p>

</div>
</div>
<a class="anchor" id="a2cfcac77627389fa35f59b52118fe0c5"></a><!-- doxytag: member="Gio::DBus::Connection::create_for_address" ref="a2cfcac77627389fa35f59b52118fe0c5" args="(const std::string &amp;address, const Glib::RefPtr&lt; AuthObserver &gt; &amp;observer, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, ConnectionFlags flags=Gio::DBus::CONNECTION_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2cfcac77627389fa35f59b52118fe0c5">Gio::DBus::Connection::create_for_address</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously connects and sets up a D-Bus client connection for exchanging D-Bus messages with an endpoint specified by <em>address</em> which must be in the D-Bus address format. </p>
<p>This constructor can only be used to initiate client-side connections - use g_dbus_connection_new() if you need to act as the server. In particular, <em>flags</em> cannot contain the DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER or DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS flags.</p>
<p>When the operation is finished, <em>callback</em> will be invoked. You can then call g_dbus_connection_new_finish() to get the result of the operation.</p>
<p>If <em>observer</em> is not <code>0</code> it may be used to control the authentication process.</p>
<p>This is a asynchronous failable constructor. See g_dbus_connection_new_for_address_sync() for the synchronous version.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000083">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>A D-Bus address. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags describing how to make the connection. </td></tr>
    <tr><td class="paramname">observer</td><td>A DBusAuthObserver or <code>0</code>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
    <tr><td class="paramname">callback</td><td>A AsyncReadyCallback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">user_data</td><td>The data to pass to <em>callback</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27dedd455d630f22c3e4b1023fce7bd1"></a><!-- doxytag: member="Gio::DBus::Connection::create_for_address" ref="a27dedd455d630f22c3e4b1023fce7bd1" args="(const std::string &amp;address, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, ConnectionFlags flags=Gio::DBus::CONNECTION_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2cfcac77627389fa35f59b52118fe0c5">Gio::DBus::Connection::create_for_address</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously connects and sets up a D-Bus client connection for exchanging D-Bus messages with an endpoint specified by <em>address</em> which must be in the D-Bus address format. </p>
<p>This constructor can only be used to initiate client-side connections - use g_dbus_connection_new() if you need to act as the server. In particular, <em>flags</em> cannot contain the DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER or DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS flags.</p>
<p>When the operation is finished, <em>callback</em> will be invoked. You can then call g_dbus_connection_new_finish() to get the result of the operation.</p>
<p>If <em>observer</em> is not <code>0</code> it may be used to control the authentication process.</p>
<p>This is a asynchronous failable constructor. See g_dbus_connection_new_for_address_sync() for the synchronous version.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000084">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>A D-Bus address. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags describing how to make the connection. </td></tr>
    <tr><td class="paramname">observer</td><td>A DBusAuthObserver or <code>0</code>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
    <tr><td class="paramname">callback</td><td>A AsyncReadyCallback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">user_data</td><td>The data to pass to <em>callback</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7541aa16a44ecc8ed8d64f143db86ebc"></a><!-- doxytag: member="Gio::DBus::Connection::create_for_address" ref="a7541aa16a44ecc8ed8d64f143db86ebc" args="(const std::string &amp;address, const Glib::RefPtr&lt; AuthObserver &gt; &amp;observer, const SlotAsyncReady &amp;slot, ConnectionFlags flags=Gio::DBus::CONNECTION_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2cfcac77627389fa35f59b52118fe0c5">Gio::DBus::Connection::create_for_address</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2cfcac77627389fa35f59b52118fe0c5" title="Asynchronously connects and sets up a D-Bus client connection for exchanging D-Bus messages with an e...">create_for_address()</a>. </p>

</div>
</div>
<a class="anchor" id="a7121db082da9ce50211bfab69809837b"></a><!-- doxytag: member="Gio::DBus::Connection::create_for_address" ref="a7121db082da9ce50211bfab69809837b" args="(const std::string &amp;address, const SlotAsyncReady &amp;slot, ConnectionFlags flags=Gio::DBus::CONNECTION_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2cfcac77627389fa35f59b52118fe0c5">Gio::DBus::Connection::create_for_address</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2cfcac77627389fa35f59b52118fe0c5" title="Asynchronously connects and sets up a D-Bus client connection for exchanging D-Bus messages with an e...">create_for_address()</a>. </p>

</div>
</div>
<a class="anchor" id="a4ae2f4459a49c6c839758c38ecdd3672"></a><!-- doxytag: member="Gio::DBus::Connection::create_for_address_finish" ref="a4ae2f4459a49c6c839758c38ecdd3672" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a4ae2f4459a49c6c839758c38ecdd3672">Gio::DBus::Connection::create_for_address_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an operation started with g_dbus_connection_new_for_address(). </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000085">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> obtained from the AsyncReadyCallback passed to g_dbus_connection_new(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A DBusConnection or <code>0</code> if <em>error</em> is set. Free with Glib::object_unref(). </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a112688a795a494f3cce20a04a970e4ef"></a><!-- doxytag: member="Gio::DBus::Connection::create_for_address_sync" ref="a112688a795a494f3cce20a04a970e4ef" args="(const std::string &amp;address, const Glib::RefPtr&lt; AuthObserver &gt; &amp;observer, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, ConnectionFlags flags=Gio::DBus::CONNECTION_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a112688a795a494f3cce20a04a970e4ef">Gio::DBus::Connection::create_for_address_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously connects and sets up a D-Bus client connection for exchanging D-Bus messages with an endpoint specified by <em>address</em> which must be in the D-Bus address format. </p>
<p>This constructor can only be used to initiate client-side connections - use g_dbus_connection_new_sync() if you need to act as the server. In particular, <em>flags</em> cannot contain the DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER or DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS flags.</p>
<p>This is a synchronous failable constructor. See g_dbus_connection_new_for_address() for the asynchronous version.</p>
<p>If <em>observer</em> is not <code>0</code> it may be used to control the authentication process.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000088">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>A D-Bus address. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags describing how to make the connection. </td></tr>
    <tr><td class="paramname">observer</td><td>A DBusAuthObserver or <code>0</code>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A DBusConnection or <code>0</code> if <em>error</em> is set. Free with Glib::object_unref(). </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a253cf6aaeb3ff39e1592e85f1a345f83"></a><!-- doxytag: member="Gio::DBus::Connection::create_for_address_sync" ref="a253cf6aaeb3ff39e1592e85f1a345f83" args="(const std::string &amp;address, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, ConnectionFlags flags=Gio::DBus::CONNECTION_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a112688a795a494f3cce20a04a970e4ef">Gio::DBus::Connection::create_for_address_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously connects and sets up a D-Bus client connection for exchanging D-Bus messages with an endpoint specified by <em>address</em> which must be in the D-Bus address format. </p>
<p>This constructor can only be used to initiate client-side connections - use g_dbus_connection_new_sync() if you need to act as the server. In particular, <em>flags</em> cannot contain the DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER or DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS flags.</p>
<p>This is a synchronous failable constructor. See g_dbus_connection_new_for_address() for the asynchronous version.</p>
<p>If <em>observer</em> is not <code>0</code> it may be used to control the authentication process.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000089">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>A D-Bus address. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags describing how to make the connection. </td></tr>
    <tr><td class="paramname">observer</td><td>A DBusAuthObserver or <code>0</code>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A DBusConnection or <code>0</code> if <em>error</em> is set. Free with Glib::object_unref(). </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86f0ea860d112f58106d301affaa8561"></a><!-- doxytag: member="Gio::DBus::Connection::create_for_address_sync" ref="a86f0ea860d112f58106d301affaa8561" args="(const std::string &amp;address, const Glib::RefPtr&lt; AuthObserver &gt; &amp;observer, ConnectionFlags flags=Gio::DBus::CONNECTION_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a112688a795a494f3cce20a04a970e4ef">Gio::DBus::Connection::create_for_address_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a112688a795a494f3cce20a04a970e4ef" title="Synchronously connects and sets up a D-Bus client connection for exchanging D-Bus messages with an en...">create_for_address_sync()</a>. </p>

</div>
</div>
<a class="anchor" id="a8f8b7483eba4c31bafb913897e5b8fdd"></a><!-- doxytag: member="Gio::DBus::Connection::create_for_address_sync" ref="a8f8b7483eba4c31bafb913897e5b8fdd" args="(const std::string &amp;address, ConnectionFlags flags=Gio::DBus::CONNECTION_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a112688a795a494f3cce20a04a970e4ef">Gio::DBus::Connection::create_for_address_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a112688a795a494f3cce20a04a970e4ef" title="Synchronously connects and sets up a D-Bus client connection for exchanging D-Bus messages with an en...">create_for_address_sync()</a>. </p>

</div>
</div>
<a class="anchor" id="a2f7a4d6ca323970acefe79bbbba13249"></a><!-- doxytag: member="Gio::DBus::Connection::create_sync" ref="a2f7a4d6ca323970acefe79bbbba13249" args="(const Glib::RefPtr&lt; IOStream &gt; &amp;stream, const std::string &amp;guid, const Glib::RefPtr&lt; AuthObserver &gt; &amp;observer, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, ConnectionFlags flags=Gio::DBus::CONNECTION_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2f7a4d6ca323970acefe79bbbba13249">Gio::DBus::Connection::create_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously sets up a D-Bus connection for exchanging D-Bus messages with the end represented by <em>stream</em>. </p>
<p>If <em>stream</em> is a <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a>, then the corresponding <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> will be put into non-blocking mode.</p>
<p>The D-Bus connection will interact with <em>stream</em> from a worker thread. As a result, the caller should not interact with <em>stream</em> after this method has been called, except by calling Glib::object_unref() on it.</p>
<p>If <em>observer</em> is not <code>0</code> it may be used to control the authentication process.</p>
<p>This is a synchronous failable constructor. See g_dbus_connection_new() for the asynchronous version.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000086">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A <a class="el" href="classGio_1_1IOStream.html">IOStream</a>. </td></tr>
    <tr><td class="paramname">guid</td><td>The GUID to use if a authenticating as a server or <code>0</code>. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags describing how to make the connection. </td></tr>
    <tr><td class="paramname">observer</td><td>A DBusAuthObserver or <code>0</code>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A DBusConnection or <code>0</code> if <em>error</em> is set. Free with Glib::object_unref(). </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec7e858016e9d3ae71d0c3012a91a523"></a><!-- doxytag: member="Gio::DBus::Connection::create_sync" ref="aec7e858016e9d3ae71d0c3012a91a523" args="(const Glib::RefPtr&lt; IOStream &gt; &amp;stream, const std::string &amp;guid, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, ConnectionFlags flags=Gio::DBus::CONNECTION_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2f7a4d6ca323970acefe79bbbba13249">Gio::DBus::Connection::create_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously sets up a D-Bus connection for exchanging D-Bus messages with the end represented by <em>stream</em>. </p>
<p>If <em>stream</em> is a <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a>, then the corresponding <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> will be put into non-blocking mode.</p>
<p>The D-Bus connection will interact with <em>stream</em> from a worker thread. As a result, the caller should not interact with <em>stream</em> after this method has been called, except by calling Glib::object_unref() on it.</p>
<p>If <em>observer</em> is not <code>0</code> it may be used to control the authentication process.</p>
<p>This is a synchronous failable constructor. See g_dbus_connection_new() for the asynchronous version.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000087">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A <a class="el" href="classGio_1_1IOStream.html">IOStream</a>. </td></tr>
    <tr><td class="paramname">guid</td><td>The GUID to use if a authenticating as a server or <code>0</code>. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags describing how to make the connection. </td></tr>
    <tr><td class="paramname">observer</td><td>A DBusAuthObserver or <code>0</code>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A DBusConnection or <code>0</code> if <em>error</em> is set. Free with Glib::object_unref(). </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad43388dd55566edb548d64e32ea36985"></a><!-- doxytag: member="Gio::DBus::Connection::create_sync" ref="ad43388dd55566edb548d64e32ea36985" args="(const Glib::RefPtr&lt; IOStream &gt; &amp;stream, const std::string &amp;guid, const Glib::RefPtr&lt; AuthObserver &gt; &amp;observer, ConnectionFlags flags=Gio::DBus::CONNECTION_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2f7a4d6ca323970acefe79bbbba13249">Gio::DBus::Connection::create_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1AuthObserver.html">AuthObserver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2f7a4d6ca323970acefe79bbbba13249" title="Synchronously sets up a D-Bus connection for exchanging D-Bus messages with the end represented by st...">create_sync()</a>. </p>

</div>
</div>
<a class="anchor" id="aad07acd92fd5f4ed311ea58b1b34283c"></a><!-- doxytag: member="Gio::DBus::Connection::create_sync" ref="aad07acd92fd5f4ed311ea58b1b34283c" args="(const Glib::RefPtr&lt; IOStream &gt; &amp;stream, const std::string &amp;guid, ConnectionFlags flags=Gio::DBus::CONNECTION_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2f7a4d6ca323970acefe79bbbba13249">Gio::DBus::Connection::create_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1IOStream.html">IOStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa395bc4535e698ee8615a929c947187d">ConnectionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggaa395bc4535e698ee8615a929c947187da0fe8b0a8eab2acb06e7ab0d1743a65fe">Gio::DBus::CONNECTION_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2f7a4d6ca323970acefe79bbbba13249" title="Synchronously sets up a D-Bus connection for exchanging D-Bus messages with the end represented by st...">create_sync()</a>. </p>

</div>
</div>
<a class="anchor" id="aae264d3104fe85f8482580db5b7761fa"></a><!-- doxytag: member="Gio::DBus::Connection::emit_signal" ref="aae264d3104fe85f8482580db5b7761fa" args="(const Glib::ustring &amp;object_path, const Glib::ustring &amp;interface_name, const Glib::ustring &amp;signal_name, const Glib::ustring &amp;destination_bus_name=Glib::ustring(), const Glib::VariantContainerBase &amp;parameters=Glib::VariantContainerBase())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#aae264d3104fe85f8482580db5b7761fa">Gio::DBus::Connection::emit_signal</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>object_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>signal_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>destination_bus_name</em> = <code><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>&amp;&#160;</td>
          <td class="paramname"><em>parameters</em> = <code><a class="el" href="classGlib_1_1VariantContainerBase.html">Glib::VariantContainerBase</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an operation started with <a class="el" href="classGio_1_1DBus_1_1Connection.html#a8d3e02423495de8270e69cd8d62b7468" title="Asynchronously invokes the method_name method on the interface_name D-Bus interface on the remote obj...">call()</a> (with a <a class="el" href="classGio_1_1UnixFDList.html" title="UnixFDList - An object containing a set of UNIX file descriptors.">UnixFDList</a>). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> obtained from the SlotAsyncReady passed to <a class="el" href="classGio_1_1DBus_1_1Connection.html#a8d3e02423495de8270e69cd8d62b7468" title="Asynchronously invokes the method_name method on the interface_name D-Bus interface on the remote obj...">call()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A Variant tuple with return values. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000015">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<p>Emits a signal.</p>
<p>This can only fail if <em>parameters</em> is not compatible with the D-Bus protocol.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object_path</td><td>Path of remote object. </td></tr>
    <tr><td class="paramname">interface_name</td><td>D-Bus interface to emit a signal on. </td></tr>
    <tr><td class="paramname">signal_name</td><td>The name of the signal to emit. </td></tr>
    <tr><td class="paramname">destination_bus_name</td><td>The unique bus name for the destination for the signal or <code>0</code> to emit to all listeners. </td></tr>
    <tr><td class="paramname">parameters</td><td>A <a class="el" href="classGlib_1_1VariantContainerBase.html" title="The base class from which multiple-item Variants derive, such as Variants containing tuples or arrays...">Glib::VariantContainerBase</a> tuple with parameters for the signal or <code>0</code> if not passing parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000130">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a2e5b3f466471359b4595b5846508c1a2"></a><!-- doxytag: member="Gio::DBus::Connection::export_action_group" ref="a2e5b3f466471359b4595b5846508c1a2" args="(const Glib::ustring &amp;object_path, const Glib::RefPtr&lt; ActionGroup &gt; &amp;action_group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint <a class="el" href="classGio_1_1DBus_1_1Connection.html#a2e5b3f466471359b4595b5846508c1a2">Gio::DBus::Connection::export_action_group</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>object_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1ActionGroup.html">ActionGroup</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>action_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exports <em>action_group</em> on <em>connection</em> at <em>object_path</em>. </p>
<p>The implemented D-Bus API should be considered private. It is subject to change in the future.</p>
<p>A given object path can only have one action group exported on it. If this constraint is violated, the export will fail and 0 will be returned (with <em>error</em> set accordingly).</p>
<p>You can unexport the action group using g_dbus_connection_unexport_action_group() with the return value of this function.</p>
<p>The thread default main context is taken at the time of this call. All incoming action activations and state change requests are reported from this context. Any changes on the action group that cause it to emit signals must also come from this same context. Since incoming action activations and state change requests are rather likely to cause changes on the action group, this effectively limits a given action group to being exported from only one main context.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000016">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object_path</td><td>A D-Bus object path. </td></tr>
    <tr><td class="paramname">action_group</td><td>A <a class="el" href="classGio_1_1DBus_1_1ActionGroup.html" title="ActionGroup - A D-Bus Gio::ActionGroup implementation.">ActionGroup</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The ID of the export (never zero), or 0 in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1595ae3e1d1f1c123245d488719923c"></a><!-- doxytag: member="Gio::DBus::Connection::export_menu_model" ref="ad1595ae3e1d1f1c123245d488719923c" args="(const Glib::ustring &amp;object_path, const Glib::RefPtr&lt; MenuModel &gt; &amp;menu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint <a class="el" href="classGio_1_1DBus_1_1Connection.html#ad1595ae3e1d1f1c123245d488719923c">Gio::DBus::Connection::export_menu_model</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>object_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1MenuModel.html">MenuModel</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>menu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exports <em>menu</em> on <em>connection</em> at <em>object_path</em>. </p>
<p>The implemented D-Bus API should be considered private. It is subject to change in the future.</p>
<p>An object path can only have one action group exported on it. If this constraint is violated, the export will fail and 0 will be returned (with <em>error</em> set accordingly).</p>
<p>You can unexport the menu model using g_dbus_connection_unexport_menu_model() with the return value of this function.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000018">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object_path</td><td>A D-Bus object path. </td></tr>
    <tr><td class="paramname">menu</td><td>A <a class="el" href="classGio_1_1DBus_1_1MenuModel.html" title="MenuModel - A D-Bus Gio::MenuModel implementation.">MenuModel</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The ID of the export (never zero), or 0 in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a175ef6c874d4cada2e3adfcdaac2fbe9"></a><!-- doxytag: member="Gio::DBus::Connection::flush" ref="a175ef6c874d4cada2e3adfcdaac2fbe9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a175ef6c874d4cada2e3adfcdaac2fbe9">Gio::DBus::Connection::flush</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously flushes the connection, that is, writes all queued outgoing message to the transport and then flushes the transport (using <a class="el" href="classGio_1_1OutputStream.html#ac76478281be9559cb0a924bcc4ead263" title="Flushes a stream asynchronously.">Gio::OutputStream::flush_async()</a>). </p>
<p>This is useful in programs that wants to emit a D-Bus signal and then exit immediately. Without flushing the connection, there is no guarantee that the message has been sent to the networking buffers in the OS kernel.</p>
<p>This is an asynchronous method. See <a class="el" href="classGio_1_1DBus_1_1Connection.html#a670fdc08181034cc0e0c6648296acca4" title="Synchronously flushes the connection.">flush_sync()</a> for the synchronous version.</p>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000121">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a49483ff5c61943724331d67ebc0206b8"></a><!-- doxytag: member="Gio::DBus::Connection::flush" ref="a49483ff5c61943724331d67ebc0206b8" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a175ef6c874d4cada2e3adfcdaac2fbe9">Gio::DBus::Connection::flush</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously flushes the connection, that is, writes all queued outgoing message to the transport and then flushes the transport (using <a class="el" href="classGio_1_1OutputStream.html#ac76478281be9559cb0a924bcc4ead263" title="Flushes a stream asynchronously.">Gio::OutputStream::flush_async()</a>). </p>
<p>This is useful in programs that wants to emit a D-Bus signal and then exit immediately. Without flushing the connection, there is no guarantee that the message has been sent to the networking buffers in the OS kernel.</p>
<p>This is an asynchronous method. When the operation is finished, <em>slot</em> will be invoked in the thread-default main loop of the thread you are calling this method from. You can then call <a class="el" href="classGio_1_1DBus_1_1Connection.html#a7d42f223b8eb0abb665ab673ff233986" title="Finishes an operation started with g_dbus_connection_flush().">flush_finish()</a> to get the result of the operation. See <a class="el" href="classGio_1_1DBus_1_1Connection.html#a670fdc08181034cc0e0c6648296acca4" title="Synchronously flushes the connection.">flush_sync()</a> for the synchronous version.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A SlotAsyncReady to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000122">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ab9018638a894f353a678ab2dfb4f6871"></a><!-- doxytag: member="Gio::DBus::Connection::flush" ref="ab9018638a894f353a678ab2dfb4f6871" args="(const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a175ef6c874d4cada2e3adfcdaac2fbe9">Gio::DBus::Connection::flush</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously flushes the connection, that is, writes all queued outgoing message to the transport and then flushes the transport (using <a class="el" href="classGio_1_1OutputStream.html#ac76478281be9559cb0a924bcc4ead263" title="Flushes a stream asynchronously.">Gio::OutputStream::flush_async()</a>). </p>
<p>This is useful in programs that wants to emit a D-Bus signal and then exit immediately. Without flushing the connection, there is no guarantee that the message has been sent to the networking buffers in the OS kernel.</p>
<p>This is an asynchronous method. When the operation is finished, <em>slot</em> will be invoked in the thread-default main loop of the thread you are calling this method from. You can then call <a class="el" href="classGio_1_1DBus_1_1Connection.html#a7d42f223b8eb0abb665ab673ff233986" title="Finishes an operation started with g_dbus_connection_flush().">flush_finish()</a> to get the result of the operation. See <a class="el" href="classGio_1_1DBus_1_1Connection.html#a670fdc08181034cc0e0c6648296acca4" title="Synchronously flushes the connection.">flush_sync()</a> for the synchronous version.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A SlotAsyncReady to call when the request is satisfied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000123">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a7d42f223b8eb0abb665ab673ff233986"></a><!-- doxytag: member="Gio::DBus::Connection::flush_finish" ref="a7d42f223b8eb0abb665ab673ff233986" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DBus_1_1Connection.html#a7d42f223b8eb0abb665ab673ff233986">Gio::DBus::Connection::flush_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an operation started with g_dbus_connection_flush(). </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000092">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> obtained from the AsyncReadyCallback passed to g_dbus_connection_flush(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the operation succeeded, <code>false</code> if <em>error</em> is set. </dd></dl>

</div>
</div>
<a class="anchor" id="a670fdc08181034cc0e0c6648296acca4"></a><!-- doxytag: member="Gio::DBus::Connection::flush_sync" ref="a670fdc08181034cc0e0c6648296acca4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a670fdc08181034cc0e0c6648296acca4">Gio::DBus::Connection::flush_sync</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously flushes the connection. </p>
<p>The calling thread is blocked until this is done. See <a class="el" href="classGio_1_1DBus_1_1Connection.html#a175ef6c874d4cada2e3adfcdaac2fbe9" title="Asynchronously flushes the connection, that is, writes all queued outgoing message to the transport a...">flush()</a> for the asynchronous version of this method and more details about what it does.</p>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000124">Since glibmm 2.28:</a></b></dt><dd></dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a230beebae8da6bc51f269faff7c63957"></a><!-- doxytag: member="Gio::DBus::Connection::flush_sync" ref="a230beebae8da6bc51f269faff7c63957" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a670fdc08181034cc0e0c6648296acca4">Gio::DBus::Connection::flush_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously flushes <em>connection</em>. </p>
<p>The calling thread is blocked until this is done. See g_dbus_connection_flush() for the asynchronous version of this method and more details about what it does.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000093">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the operation succeeded, <code>false</code> if <em>error</em> is set. </dd></dl>

</div>
</div>
<a class="anchor" id="a5345c2d7d7f861b0ea4ac67dffd7d5ce"></a><!-- doxytag: member="Gio::DBus::Connection::get" ref="a5345c2d7d7f861b0ea4ac67dffd7d5ce" args="(BusType bus_type, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a5345c2d7d7f861b0ea4ac67dffd7d5ce">Gio::DBus::Connection::get</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa00806111608557f425bf09bdf4b0087">BusType</a>&#160;</td>
          <td class="paramname"><em>bus_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously connects to the message bus specified by <em>bus_type</em>. </p>
<p>When the operation is finished, <em>slot</em> will be invoked. You can then call <a class="el" href="classGio_1_1DBus_1_1Connection.html#a20675d9ff219ddd7b9cd5d1ba4a88bbc" title="Finishes an operation started with g_bus_get().">get_finish()</a> to get the result of the operation.</p>
<p>This is a asynchronous failable function. See <a class="el" href="classGio_1_1DBus_1_1Connection.html#aa9f6ff4fb7546a1600331322b33fbbfb" title="Synchronously connects to the message bus specified by bus_type.">get_sync()</a> for the synchronous version.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bus_type</td><td>A BusType. </td></tr>
    <tr><td class="paramname">slot</td><td>A SlotAsyncReady to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000116">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a96b8301d5d4e6a273e4bdb7778d44062"></a><!-- doxytag: member="Gio::DBus::Connection::get" ref="a96b8301d5d4e6a273e4bdb7778d44062" args="(BusType bus_type, const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a5345c2d7d7f861b0ea4ac67dffd7d5ce">Gio::DBus::Connection::get</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa00806111608557f425bf09bdf4b0087">BusType</a>&#160;</td>
          <td class="paramname"><em>bus_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a5345c2d7d7f861b0ea4ac67dffd7d5ce" title="Asynchronously connects to the message bus specified by bus_type.">get()</a>. </p>

</div>
</div>
<a class="anchor" id="a791f703904ec858ba568f927d64cb49e"></a><!-- doxytag: member="Gio::DBus::Connection::get_capabilities" ref="a791f703904ec858ba568f927d64cb49e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#gadc652797a964763619fdb48a89b42f93">CapabilityFlags</a> <a class="el" href="classGio_1_1DBus_1_1Connection.html#a791f703904ec858ba568f927d64cb49e">Gio::DBus::Connection::get_capabilities</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the capabilities negotiated with the remote peer. </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000104">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero or more flags from the DBusCapabilityFlags enumeration. </dd></dl>

</div>
</div>
<a class="anchor" id="a51e5d1b5f7166a0db1921f9008863f28"></a><!-- doxytag: member="Gio::DBus::Connection::get_exit_on_close" ref="a51e5d1b5f7166a0db1921f9008863f28" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DBus_1_1Connection.html#a51e5d1b5f7166a0db1921f9008863f28">Gio::DBus::Connection::get_exit_on_close</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets whether the process is terminated when <em>connection</em> is closed by the remote peer. </p>
<p>See DBusConnection::property_exit_on_close() for more details.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000094">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the process is terminated when <em>connection</em> is closed by the remote peer. </dd></dl>

</div>
</div>
<a class="anchor" id="a20675d9ff219ddd7b9cd5d1ba4a88bbc"></a><!-- doxytag: member="Gio::DBus::Connection::get_finish" ref="a20675d9ff219ddd7b9cd5d1ba4a88bbc" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a20675d9ff219ddd7b9cd5d1ba4a88bbc">Gio::DBus::Connection::get_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an operation started with g_bus_get(). </p>
<p>The returned object is a singleton, that is, shared with other callers of g_bus_get() and g_bus_get_sync() for <em>bus_type</em>. In the event that you need a private message bus connection, use g_dbus_address_get_for_bus_sync() and g_dbus_connection_new_for_address().</p>
<p>Note that the returned DBusConnection object will (usually) have the DBusConnection::property_exit_on_close() property set to <code>true</code>.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000078">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> obtained from the AsyncReadyCallback passed to g_bus_get(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A DBusConnection or <code>0</code> if <em>error</em> is set. Free with Glib::object_unref(). </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4bb51d7fc509a98ce5531390ba508804"></a><!-- doxytag: member="Gio::DBus::Connection::get_guid" ref="a4bb51d7fc509a98ce5531390ba508804" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> <a class="el" href="classGio_1_1DBus_1_1Connection.html#a4bb51d7fc509a98ce5531390ba508804">Gio::DBus::Connection::get_guid</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The GUID of the peer performing the role of server when authenticating. </p>
<p>See DBusConnection::property_guid() for more details.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000102">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The GUID. Do not free this string, it is owned by <em>connection</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad841b9beb348c2e21dcb9e395ee4f28a"></a><!-- doxytag: member="Gio::DBus::Connection::get_peer_credentials" ref="ad841b9beb348c2e21dcb9e395ee4f28a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Credentials.html">Credentials</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#ad841b9beb348c2e21dcb9e395ee4f28a">Gio::DBus::Connection::get_peer_credentials</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the credentials of the authenticated peer. </p>
<p>This will always return <code>0</code> unless <em>connection</em> acted as a server (e.g. DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed) when set up and the client passed credentials as part of the authentication process.</p>
<p>In a message bus setup, the message bus is always the server and each application is a client. So this method will always return <code>0</code> for message bus clients.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000105">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Credentials.html" title="An object containing credentials.">Credentials</a> or <code>0</code> if not available. Do not free this object, it is owned by <em>connection</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2babc0d08159c8b10ffd88c9784c9802"></a><!-- doxytag: member="Gio::DBus::Connection::get_peer_credentials" ref="a2babc0d08159c8b10ffd88c9784c9802" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;const <a class="el" href="classGio_1_1Credentials.html">Credentials</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#ad841b9beb348c2e21dcb9e395ee4f28a">Gio::DBus::Connection::get_peer_credentials</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the credentials of the authenticated peer. </p>
<p>This will always return <code>0</code> unless <em>connection</em> acted as a server (e.g. DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed) when set up and the client passed credentials as part of the authentication process.</p>
<p>In a message bus setup, the message bus is always the server and each application is a client. So this method will always return <code>0</code> for message bus clients.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000106">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Credentials.html" title="An object containing credentials.">Credentials</a> or <code>0</code> if not available. Do not free this object, it is owned by <em>connection</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="aebf8f77b4f2aef8d1fa05edce3e48f75"></a><!-- doxytag: member="Gio::DBus::Connection::get_stream" ref="aebf8f77b4f2aef8d1fa05edce3e48f75" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1IOStream.html">IOStream</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#aebf8f77b4f2aef8d1fa05edce3e48f75">Gio::DBus::Connection::get_stream</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the underlying stream used for IO. </p>
<p>While the DBusConnection is active, it will interact with this stream from a worker thread, so it is not safe to interact with the stream directly.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000100">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The stream used for IO. </dd></dl>

</div>
</div>
<a class="anchor" id="accaf9db87e08dc4a3cef8917092bd77b"></a><!-- doxytag: member="Gio::DBus::Connection::get_stream" ref="accaf9db87e08dc4a3cef8917092bd77b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;const <a class="el" href="classGio_1_1IOStream.html">IOStream</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#aebf8f77b4f2aef8d1fa05edce3e48f75">Gio::DBus::Connection::get_stream</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the underlying stream used for IO. </p>
<p>While the DBusConnection is active, it will interact with this stream from a worker thread, so it is not safe to interact with the stream directly.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000101">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The stream used for IO. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9f6ff4fb7546a1600331322b33fbbfb"></a><!-- doxytag: member="Gio::DBus::Connection::get_sync" ref="aa9f6ff4fb7546a1600331322b33fbbfb" args="(BusType bus_type, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#aa9f6ff4fb7546a1600331322b33fbbfb">Gio::DBus::Connection::get_sync</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa00806111608557f425bf09bdf4b0087">BusType</a>&#160;</td>
          <td class="paramname"><em>bus_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously connects to the message bus specified by <em>bus_type</em>. </p>
<p>Note that the returned object may shared with other callers, e.g. if two separate parts of a process calls this function with the same <em>bus_type</em>, they will share the same object.</p>
<p>This is a synchronous failable function. See g_bus_get() and g_bus_get_finish() for the asynchronous version.</p>
<p>The returned object is a singleton, that is, shared with other callers of g_bus_get() and g_bus_get_sync() for <em>bus_type</em>. In the event that you need a private message bus connection, use g_dbus_address_get_for_bus_sync() and g_dbus_connection_new_for_address().</p>
<p>Note that the returned DBusConnection object will (usually) have the DBusConnection::property_exit_on_close() property set to <code>true</code>.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000079">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bus_type</td><td>A BusType. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A DBusConnection or <code>0</code> if <em>error</em> is set. Free with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="ae29f76f48d11685c100e8c880e36b3fd"></a><!-- doxytag: member="Gio::DBus::Connection::get_sync" ref="ae29f76f48d11685c100e8c880e36b3fd" args="(BusType bus_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Connection.html">Connection</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#aa9f6ff4fb7546a1600331322b33fbbfb">Gio::DBus::Connection::get_sync</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaa00806111608557f425bf09bdf4b0087">BusType</a>&#160;</td>
          <td class="paramname"><em>bus_type</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#aa9f6ff4fb7546a1600331322b33fbbfb" title="Synchronously connects to the message bus specified by bus_type.">get_sync()</a>. </p>

</div>
</div>
<a class="anchor" id="a0f716d616a32a2e2e7acc210112bc2bc"></a><!-- doxytag: member="Gio::DBus::Connection::get_unique_name" ref="a0f716d616a32a2e2e7acc210112bc2bc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> <a class="el" href="classGio_1_1DBus_1_1Connection.html#a0f716d616a32a2e2e7acc210112bc2bc">Gio::DBus::Connection::get_unique_name</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the unique name of <em>connection</em> as assigned by the message bus. </p>
<p>This can also be used to figure out if <em>connection</em> is a message bus connection.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000103">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unique name or <code>0</code> if <em>connection</em> is not a message bus connection. Do not free this string, it is owned by <em>connection</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="add69f87e326bd9bca8c7f6dc2f0dc26e"></a><!-- doxytag: member="Gio::DBus::Connection::gobj" ref="add69f87e326bd9bca8c7f6dc2f0dc26e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GDBusConnection* <a class="el" href="classGio_1_1DBus_1_1Connection.html#add69f87e326bd9bca8c7f6dc2f0dc26e">Gio::DBus::Connection::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGio_1_1AsyncInitable.html#a17b715d899d7ff40a10e98cbc04fb950">Gio::AsyncInitable</a>.</p>

</div>
</div>
<a class="anchor" id="a847a66c3c51c46c57ff96abc8df1a542"></a><!-- doxytag: member="Gio::DBus::Connection::gobj" ref="a847a66c3c51c46c57ff96abc8df1a542" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GDBusConnection* <a class="el" href="classGio_1_1DBus_1_1Connection.html#add69f87e326bd9bca8c7f6dc2f0dc26e">Gio::DBus::Connection::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGio_1_1AsyncInitable.html#a470b482fc15de1b5ca307a9ba9c18649">Gio::AsyncInitable</a>.</p>

</div>
</div>
<a class="anchor" id="ae347d91fd24a526c1dbdb880ef584bfe"></a><!-- doxytag: member="Gio::DBus::Connection::gobj_copy" ref="ae347d91fd24a526c1dbdb880ef584bfe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GDBusConnection* <a class="el" href="classGio_1_1DBus_1_1Connection.html#ae347d91fd24a526c1dbdb880ef584bfe">Gio::DBus::Connection::gobj_copy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a class="anchor" id="aa188059029093a62e3d1b3b135e0e79b"></a><!-- doxytag: member="Gio::DBus::Connection::is_closed" ref="aa188059029093a62e3d1b3b135e0e79b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DBus_1_1Connection.html#aa188059029093a62e3d1b3b135e0e79b">Gio::DBus::Connection::is_closed</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets whether <em>connection</em> is closed. </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000099">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the connection is closed, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad66c7d3c04c0a39e46a9a5342dc91a59"></a><!-- doxytag: member="Gio::DBus::Connection::property_capabilities" ref="ad66c7d3c04c0a39e46a9a5342dc91a59" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="group__giommEnums.html#gadc652797a964763619fdb48a89b42f93">CapabilityFlags</a> &gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#ad66c7d3c04c0a39e46a9a5342dc91a59">Gio::DBus::Connection::property_capabilities</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Capabilities. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a23822f8e767a79b37238f110eef77c"></a><!-- doxytag: member="Gio::DBus::Connection::property_closed" ref="a8a23822f8e767a79b37238f110eef77c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; bool &gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a8a23822f8e767a79b37238f110eef77c">Gio::DBus::Connection::property_closed</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether the connection is closed. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a05f97a97a09455e024a2f26994d49edd"></a><!-- doxytag: member="Gio::DBus::Connection::property_exit_on_close" ref="a05f97a97a09455e024a2f26994d49edd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a05f97a97a09455e024a2f26994d49edd">Gio::DBus::Connection::property_exit_on_close</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether the process is terminated when the connection is closed. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="af3402d2b61aee521e7a459067053157d"></a><!-- doxytag: member="Gio::DBus::Connection::property_exit_on_close" ref="af3402d2b61aee521e7a459067053157d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; bool &gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a05f97a97a09455e024a2f26994d49edd">Gio::DBus::Connection::property_exit_on_close</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether the process is terminated when the connection is closed. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a13b65cb8957de1a08f67b2a8d6e9c8e6"></a><!-- doxytag: member="Gio::DBus::Connection::property_guid" ref="a13b65cb8957de1a08f67b2a8d6e9c8e6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a13b65cb8957de1a08f67b2a8d6e9c8e6">Gio::DBus::Connection::property_guid</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GUID of the server peer. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="abefe6a30bf9f66095c24c07c5e535e17"></a><!-- doxytag: member="Gio::DBus::Connection::property_stream" ref="abefe6a30bf9f66095c24c07c5e535e17" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1IOStream.html">IOStream</a>&gt; &gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#abefe6a30bf9f66095c24c07c5e535e17">Gio::DBus::Connection::property_stream</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The underlying streams used for I/O. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a991a3b749663686639bc0644b139c65d"></a><!-- doxytag: member="Gio::DBus::Connection::property_unique_name" ref="a991a3b749663686639bc0644b139c65d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> &gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a991a3b749663686639bc0644b139c65d">Gio::DBus::Connection::property_unique_name</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unique name of bus connection. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c2974543543686c386601b656577593"></a><!-- doxytag: member="Gio::DBus::Connection::register_object" ref="a0c2974543543686c386601b656577593" args="(const Glib::ustring &amp;object_path, const Glib::RefPtr&lt; InterfaceInfo &gt; &amp;interface_info, const InterfaceVTable &amp;vtable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint <a class="el" href="classGio_1_1DBus_1_1Connection.html#a0c2974543543686c386601b656577593">Gio::DBus::Connection::register_object</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>object_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1InterfaceInfo.html">InterfaceInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>interface_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1DBus_1_1InterfaceVTable.html">InterfaceVTable</a>&amp;&#160;</td>
          <td class="paramname"><em>vtable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers slots for exported objects at <em>object_path</em> with the D-Bus interface that is described in <em>interface_info</em>. </p>
<p>Calls to slots in <em>vtable</em> will happen in the thread-default main loop of the thread you are calling this method from.</p>
<p>Note that all <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types.">Glib::VariantBase</a> values passed to functions in <em>vtable</em> will match the signature given in <em>interface_info</em> - if a remote caller passes incorrect values, the <code>org.freedesktop.DBus.Error.InvalidArgs</code> is returned to the remote caller.</p>
<p>Additionally, if the remote caller attempts to invoke methods or access properties not mentioned in <em>interface_info</em> the <code>org.freedesktop.DBus.Error.UnknownMethod</code> resp. <code>org.freedesktop.DBus.Error.InvalidArgs</code> errors are returned to the caller.</p>
<p>It is considered a programming error if the SlotDBusInterfaceGetProperty slot in <em>vtable</em> returns a <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types.">Glib::VariantBase</a> of incorrect type.</p>
<p>If an existing slot is already registered at <em>object_path</em> and <em>interface_name</em>, then a <a class="el" href="classGlib_1_1Error.html">Glib::Error</a> is thrown.</p>
<p>GDBus automatically implements the standard D-Bus interfaces org.freedesktop.DBus.Properties, org.freedesktop.DBus.Introspectable and org.freedesktop.Peer, so you don't have to implement those for the objects you export. You can implement org.freedesktop.DBus.Properties yourself, e.g. to handle getting and setting of properties asynchronously.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object_path</td><td>The object path to register at. </td></tr>
    <tr><td class="paramname">interface_info</td><td>Introspection data for the interface. </td></tr>
    <tr><td class="paramname">vtable</td><td>An <a class="el" href="classGio_1_1DBus_1_1InterfaceVTable.html" title="This represents a virtual table for handling properties and method calls for a D-Bus interface...">InterfaceVTable</a> to call into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A registration id (never 0) that can be used with <a class="el" href="classGio_1_1DBus_1_1Connection.html#a32b998fc3e093c678e6ff4e76ec29874" title="Unregisters an object.">unregister_object()</a> if no <a class="el" href="classGlib_1_1Error.html">Glib::Error</a> is thrown. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000133">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ad8e4a523adc691ff00d946df0fc779c6"></a><!-- doxytag: member="Gio::DBus::Connection::register_object" ref="ad8e4a523adc691ff00d946df0fc779c6" args="(const Glib::ustring &amp;object_path, const Glib::RefPtr&lt; InterfaceInfo &gt; &amp;interface_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint <a class="el" href="classGio_1_1DBus_1_1Connection.html#a0c2974543543686c386601b656577593">Gio::DBus::Connection::register_object</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>object_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1InterfaceInfo.html">InterfaceInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>interface_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers exported objects at <em>object_path</em> with the D-Bus interface that is described in <em>interface_info</em>. </p>
<p>This method overload, which does not take a VTable, is useful for &lt;a href=="http://en.wikipedia.org/wiki/Marker_interface_pattern"&gt;marker interfaces&lt;/href&gt;.</p>
<p>If an existing slot is already registered at <em>object_path</em> and <em>interface_name</em>, then a <a class="el" href="classGlib_1_1Error.html">Glib::Error</a> is thrown.</p>
<p>GDBus automatically implements the standard D-Bus interfaces org.freedesktop.DBus.Properties, org.freedesktop.DBus.Introspectable and org.freedesktop.Peer, so you don't have to implement those for the objects you export.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object_path</td><td>The object path to register at. </td></tr>
    <tr><td class="paramname">interface_info</td><td>Introspection data for the interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A registration id (never 0) that can be used with <a class="el" href="classGio_1_1DBus_1_1Connection.html#a32b998fc3e093c678e6ff4e76ec29874" title="Unregisters an object.">unregister_object()</a> if no <a class="el" href="classGlib_1_1Error.html">Glib::Error</a> is thrown. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000134">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ade98c63ff3e2ce7906ca4a2f63849e07"></a><!-- doxytag: member="Gio::DBus::Connection::register_subtree" ref="ade98c63ff3e2ce7906ca4a2f63849e07" args="(const Glib::ustring &amp;object_path, const SubtreeVTable &amp;vtable, SubtreeFlags flags=Gio::DBus::SUBTREE_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint <a class="el" href="classGio_1_1DBus_1_1Connection.html#ade98c63ff3e2ce7906ca4a2f63849e07">Gio::DBus::Connection::register_subtree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>object_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1DBus_1_1SubtreeVTable.html">SubtreeVTable</a>&amp;&#160;</td>
          <td class="paramname"><em>vtable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga57ca559dd8d3b93c96c4828cb457b975">SubtreeFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga57ca559dd8d3b93c96c4828cb457b975aa8559c8d4072f25d7aeaa9b08bc93c66">Gio::DBus::SUBTREE_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers a whole subtree of “dynamic” objects. </p>
<p>Copies of the enumerate and introspection slots usted to create <em>vtable</em> are used to convey, to remote callers, what nodes exist in the subtree rooted by <em>object_path</em>.</p>
<p>When handling remote calls into any node in the subtree, first the enumerate slot is used to check if the node exists. If the node exists or the <a class="el" href="group__giommEnums.html#gga57ca559dd8d3b93c96c4828cb457b975a0765ee03c950bcaf808a9c178261ec53">Gio::DBus::SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES</a> flag is set the introspection slot is used to check if the node supports the requested method. If so, the dispatch function is used to determine where to dispatch the call. The collected <a class="el" href="classGio_1_1DBus_1_1InterfaceVTable.html" title="This represents a virtual table for handling properties and method calls for a D-Bus interface...">InterfaceVTable</a> will be used to call into the interface vtable for processing the request.</p>
<p>All calls into user-provided code will be invoked in the thread-default main loop of the thread you are calling this method from.</p>
<p>If an existing subtree is already registered at <em>object_path</em> or then a <a class="el" href="classGlib_1_1Error.html">Glib::Error</a> is thrown.</p>
<p>Note that it is valid to register regular objects (using <a class="el" href="classGio_1_1DBus_1_1Connection.html#a0c2974543543686c386601b656577593" title="Registers slots for exported objects at object_path with the D-Bus interface that is described in int...">register_object()</a>) in a subtree registered with <a class="el" href="classGio_1_1DBus_1_1Connection.html#ade98c63ff3e2ce7906ca4a2f63849e07" title="Registers a whole subtree of “dynamic” objects.">register_subtree()</a> - if so, the subtree handler is tried as the last resort. One way to think about a subtree handler is to consider it a “fallback handler” for object paths not registered via <a class="el" href="classGio_1_1DBus_1_1Connection.html#a0c2974543543686c386601b656577593" title="Registers slots for exported objects at object_path with the D-Bus interface that is described in int...">register_object()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object_path</td><td>The object path to register the subtree at. </td></tr>
    <tr><td class="paramname">vtable</td><td>A <a class="el" href="classGio_1_1DBus_1_1SubtreeVTable.html" title="This represents a virtual table for subtrees registered with Gio::DBus::Connection::register_subtree(...">SubtreeVTable</a> to enumerate, introspect and dispatch nodes in the subtree. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags used to fine tune the behavior of the subtree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A subtree registration id (never 0) that can be used with <a class="el" href="classGio_1_1DBus_1_1Connection.html#aae026eab32dc1e6ef7eb865e2d83dc1d" title="Unregisters a subtree.">unregister_subtree()</a> if no <a class="el" href="classGlib_1_1Error.html">Glib::Error</a> is thrown.</dd></dl>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000135">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aa5f078c02692ec5effae8dccbbff2e55"></a><!-- doxytag: member="Gio::DBus::Connection::remove_filter" ref="aa5f078c02692ec5effae8dccbbff2e55" args="(guint filter_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#aa5f078c02692ec5effae8dccbbff2e55">Gio::DBus::Connection::remove_filter</a> </td>
          <td>(</td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>filter_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a filter. </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000108">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filter_id</td><td>An identifier obtained from g_dbus_connection_add_filter(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7cfa8a2901b8301059a3bee28713037"></a><!-- doxytag: member="Gio::DBus::Connection::send_message" ref="aa7cfa8a2901b8301059a3bee28713037" args="(const Glib::RefPtr&lt; Message &gt; &amp;message, SendMessageFlags flags, guint32 &amp;out_serial)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DBus_1_1Connection.html#aa7cfa8a2901b8301059a3bee28713037">Gio::DBus::Connection::send_message</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gab2b457af9dfcf8a106e4b8495d22af2b">SendMessageFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint32 &amp;&#160;</td>
          <td class="paramname"><em>out_serial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously sends <em>message</em> to the peer represented by <em>connection</em>. </p>
<p>Unless <em>flags</em> contain the DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number will be assigned by <em>connection</em> and set on <em>message</em> via g_dbus_message_set_serial(). If <em>out_serial</em> is not <code>0</code>, then the serial number used will be written to this location prior to submitting the message to the underlying transport.</p>
<p>If <em>connection</em> is closed then the operation will fail with IO_ERROR_CLOSED. If <em>message</em> is not well-formed, the operation fails with IO_ERROR_INVALID_ARGUMENT.</p>
<p>See &lt;xref linkend="gdbus-server"&gt; and &lt;xref linkend="gdbus-unix-fd-client"&gt; for an example of how to use this low-level API to send and receive UNIX file descriptors.</p>
<p>Note that <em>message</em> must be unlocked, unless <em>flags</em> contain the DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000096">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>A DBusMessage. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting how the message is sent. </td></tr>
    <tr><td class="paramname">out_serial</td><td>Return location for serial number assigned to <em>message</em> when sending it or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the message was well-formed and queued for transmission, <code>false</code> if <em>error</em> is set. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1a7babf2856bea9b12513070c311458"></a><!-- doxytag: member="Gio::DBus::Connection::send_message" ref="ad1a7babf2856bea9b12513070c311458" args="(const Glib::RefPtr&lt; Message &gt; &amp;message, SendMessageFlags flags=Gio::DBus::SEND_MESSAGE_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DBus_1_1Connection.html#aa7cfa8a2901b8301059a3bee28713037">Gio::DBus::Connection::send_message</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gab2b457af9dfcf8a106e4b8495d22af2b">SendMessageFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#ggab2b457af9dfcf8a106e4b8495d22af2baf93fed1a472ab0c7eb4f51fa35b93577">Gio::DBus::SEND_MESSAGE_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="classGio_1_1DBus_1_1Connection.html#aa7cfa8a2901b8301059a3bee28713037" title="Asynchronously sends message to the peer represented by connection.">send_message()</a> without an "out_serial" parameter. </p>

</div>
</div>
<a class="anchor" id="a90ce8c8c6d8780d47c3d16cfa1b313f6"></a><!-- doxytag: member="Gio::DBus::Connection::send_message_with_reply" ref="a90ce8c8c6d8780d47c3d16cfa1b313f6" args="(const Glib::RefPtr&lt; Message &gt; &amp;message, int timeout_msec, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a90ce8c8c6d8780d47c3d16cfa1b313f6">Gio::DBus::Connection::send_message_with_reply</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronously sends message to the peer represented by the connection. </p>
<p>Unless flags contain the <a class="el" href="group__giommEnums.html#ggab2b457af9dfcf8a106e4b8495d22af2baa438996b2b25c2ddfc7bb610b067ce37">Gio::DBus::SEND_MESSAGE_FLAGS_PRESERVE_SERIAL</a> flag, the serial number will be assigned by the connection and set on message via <a class="el" href="classGio_1_1DBus_1_1Message.html#af69369632ec43d609032963e3a09797a" title="Sets the serial for message.">Gio::DBus::Message::set_serial()</a>.</p>
<p>If the connection is closed then the operation will fail with <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9ae7313313612066105fb25db853b1e42f">Gio::IO_ERROR_CLOSED</a>. If <em>cancellable</em> is canceled, the operation will fail with <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9a46652c381d5526249d2dda56e2a17ba4">Gio::IO_ERROR_CANCELLED</a>. If <em>message</em> is not well-formed, the operation fails with <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9a1c3061f60b6a9727c6a3744c88958bd7">Gio::IO_ERROR_INVALID_ARGUMENT</a>.</p>
<p>This is an asynchronous method. When the operation is finished, <em>slot</em> will be invoked in the thread-default main loop of the thread you are calling this method from. You can then call <a class="el" href="classGio_1_1DBus_1_1Connection.html#a3ccceca6864b5a692805db02224a3de1" title="Finishes an operation started with g_dbus_connection_send_message_with_reply().">send_message_with_reply_finish()</a> to get the result of the operation. See <a class="el" href="classGio_1_1DBus_1_1Connection.html#a9750c77a26bc9ba12f3c801bc620767d" title="Synchronously sends message to the peer represented by the connection and blocks the calling thread u...">send_message_with_reply_sync()</a> for the synchronous version.</p>
<p>Note that message must be unlocked, unless flags contain the <a class="el" href="group__giommEnums.html#ggab2b457af9dfcf8a106e4b8495d22af2baa438996b2b25c2ddfc7bb610b067ce37">Gio::DBus::SEND_MESSAGE_FLAGS_PRESERVE_SERIAL</a> flag.</p>
<p>See the C API docs for examples.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>A <a class="el" href="classGio_1_1DBus_1_1Message.html" title="A type for representing D-Bus messages that can be sent or received on a Connection.">Message</a>. </td></tr>
    <tr><td class="paramname">timeout_msec</td><td>The timeout in milliseconds or -1 to use the default timeout. </td></tr>
    <tr><td class="paramname">slot</td><td>A SlotAsyncReady to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000125">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ad218b54738f04a68a40d6d83e7f7a1f6"></a><!-- doxytag: member="Gio::DBus::Connection::send_message_with_reply" ref="ad218b54738f04a68a40d6d83e7f7a1f6" args="(const Glib::RefPtr&lt; Message &gt; &amp;message, int timeout_msec, const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a90ce8c8c6d8780d47c3d16cfa1b313f6">Gio::DBus::Connection::send_message_with_reply</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a90ce8c8c6d8780d47c3d16cfa1b313f6" title="Asynchronously sends message to the peer represented by the connection.">send_message_with_reply()</a>. </p>

</div>
</div>
<a class="anchor" id="a3ccceca6864b5a692805db02224a3de1"></a><!-- doxytag: member="Gio::DBus::Connection::send_message_with_reply_finish" ref="a3ccceca6864b5a692805db02224a3de1" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a3ccceca6864b5a692805db02224a3de1">Gio::DBus::Connection::send_message_with_reply_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an operation started with g_dbus_connection_send_message_with_reply(). </p>
<p>Note that <em>error</em> is only set if a local in-process error occurred. That is to say that the returned DBusMessage object may be of type DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode this to a <a class="el" href="classGio_1_1DBus_1_1Error.html">Error</a>.</p>
<p>See &lt;xref linkend="gdbus-server"&gt; and &lt;xref linkend="gdbus-unix-fd-client"&gt; for an example of how to use this low-level API to send and receive UNIX file descriptors.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000097">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> obtained from the AsyncReadyCallback passed to g_dbus_connection_send_message_with_reply(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A locked DBusMessage or <code>0</code> if <em>error</em> is set. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9750c77a26bc9ba12f3c801bc620767d"></a><!-- doxytag: member="Gio::DBus::Connection::send_message_with_reply_sync" ref="a9750c77a26bc9ba12f3c801bc620767d" args="(const Glib::RefPtr&lt; Message &gt; &amp;message, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, gint timeout_msec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a9750c77a26bc9ba12f3c801bc620767d">Gio::DBus::Connection::send_message_with_reply_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>timeout_msec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously sends <em>message</em> to the peer represented by the connection and blocks the calling thread until a reply is received or the timeout is reached. </p>
<p>See <a class="el" href="classGio_1_1DBus_1_1Connection.html#a90ce8c8c6d8780d47c3d16cfa1b313f6" title="Asynchronously sends message to the peer represented by the connection.">send_message_with_reply()</a> for the asynchronous version of this method.</p>
<p>Unless flags contain the <a class="el" href="group__giommEnums.html#ggab2b457af9dfcf8a106e4b8495d22af2baa438996b2b25c2ddfc7bb610b067ce37">Gio::DBus::SEND_MESSAGE_FLAGS_PRESERVE_SERIAL</a> flag, the serial number will be assigned by the connection and set on message via <a class="el" href="classGio_1_1DBus_1_1Message.html#af69369632ec43d609032963e3a09797a" title="Sets the serial for message.">Gio::DBus::Message::set_serial()</a>.</p>
<p>If the connection is closed then the operation will fail with <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9ae7313313612066105fb25db853b1e42f">Gio::IO_ERROR_CLOSED</a>. If <em>cancellable</em> is canceled, the operation will fail with <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9a46652c381d5526249d2dda56e2a17ba4">Gio::IO_ERROR_CANCELLED</a>. If <em>message</em> is not well-formed, the operation fails with <a class="el" href="group__giommEnums.html#gga0f8fdeead92e74b78d209cb3c3e9f0e9a1c3061f60b6a9727c6a3744c88958bd7">Gio::IO_ERROR_INVALID_ARGUMENT</a>.</p>
<p>Note that a <a class="el" href="classGlib_1_1Error.html">Glib::Error</a> is thrown if a local in-process error occured. That is to say that the returned <a class="el" href="classGio_1_1DBus_1_1Message.html" title="A type for representing D-Bus messages that can be sent or received on a Connection.">Message</a> object may be of type G_DBUS_MESSAGE_TYPE_ERROR. Use <a class="el" href="classGio_1_1DBus_1_1Message.html#a1cbb8f345228711415e10c07a0d02bce" title="If message is not of type DBUS_MESSAGE_TYPE_ERROR does nothing and returns false.">Gio::DBus::Message::to_exception()</a> to transcode this to a <a class="el" href="classGlib_1_1Error.html">Glib::Error</a>.</p>
<p>See the C API docs for examples.</p>
<p>Note that message must be unlocked, unless flags contain the <a class="el" href="group__giommEnums.html#ggab2b457af9dfcf8a106e4b8495d22af2baa438996b2b25c2ddfc7bb610b067ce37">Gio::DBus::SEND_MESSAGE_FLAGS_PRESERVE_SERIAL</a> flag.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>A <a class="el" href="classGio_1_1DBus_1_1Message.html" title="A type for representing D-Bus messages that can be sent or received on a Connection.">Message</a>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>. </td></tr>
    <tr><td class="paramname">timeout_msec</td><td>The timeout in milliseconds or -1 to use the default timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A locked <a class="el" href="classGio_1_1DBus_1_1Message.html" title="A type for representing D-Bus messages that can be sent or received on a Connection.">Message</a> that is the reply to <em>message</em> or <code>0</code> if a <a class="el" href="classGlib_1_1Error.html">Glib::Error</a> is thrown. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000126">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ab0b1e37fb685de42b19ded29dbcdccdd"></a><!-- doxytag: member="Gio::DBus::Connection::send_message_with_reply_sync" ref="ab0b1e37fb685de42b19ded29dbcdccdd" args="(const Glib::RefPtr&lt; Message &gt; &amp;message, gint timeout_msec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a>&gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a9750c77a26bc9ba12f3c801bc620767d">Gio::DBus::Connection::send_message_with_reply_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Message.html">Message</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>timeout_msec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A non-cancellable version of <a class="el" href="classGio_1_1DBus_1_1Connection.html#a9750c77a26bc9ba12f3c801bc620767d" title="Synchronously sends message to the peer represented by the connection and blocks the calling thread u...">send_message_with_reply_sync()</a>. </p>

</div>
</div>
<a class="anchor" id="a7457de5a9a316eb6e1b3a9f9093ac635"></a><!-- doxytag: member="Gio::DBus::Connection::set_exit_on_close" ref="a7457de5a9a316eb6e1b3a9f9093ac635" args="(bool exit_on_close=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a7457de5a9a316eb6e1b3a9f9093ac635">Gio::DBus::Connection::set_exit_on_close</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exit_on_close</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets whether the process should be terminated when <em>connection</em> is closed by the remote peer. </p>
<p>See DBusConnection::property_exit_on_close() for more details.</p>
<p>Note that this function should be used with care. Most modern UNIX desktops tie the notion of a user session the session bus, and expect all of a users applications to quit when their bus connection goes away. If you are setting <em>exit_on_close</em> to <code>false</code> for the shared session bus connection, you should make sure that your application exits when the user session ends.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000095">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">exit_on_close</td><td>Whether the process should be terminated when <em>connection</em> is closed by the remote peer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99d65f5ee4424eb0e48fd1725ff6ab37"></a><!-- doxytag: member="Gio::DBus::Connection::signal_closed" ref="a99d65f5ee4424eb0e48fd1725ff6ab37" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1SignalProxy2.html">Glib::SignalProxy2</a>&lt; void,bool,const <a class="el" href="classGlib_1_1Error.html">Glib::Error</a>&amp; &gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a99d65f5ee4424eb0e48fd1725ff6ab37">Gio::DBus::Connection::signal_closed</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Slot Prototype:</b></dt><dd><code>void on_my_closed(bool remote_peer_vanished, const <a class="el" href="classGlib_1_1Error.html">Glib::Error</a>&amp; error)</code></dd></dl>
<p>Emitted when the connection is closed.</p>
<p>The cause of this event can be</p>
<ul>
<li>If g_dbus_connection_close() is called. In this case <em>remote_peer_vanished</em> is set to <code>false</code> and <em>error</em> is <code>0</code>.</li>
<li>If the remote peer closes the connection. In this case <em>remote_peer_vanished</em> is set to <code>true</code> and <em>error</em> is set.</li>
<li>If the remote peer sends invalid or malformed data. In this case <em>remote_peer_vanished</em> is set to <code>false</code> and <em>error</em> is set.</li>
</ul>
<p>Upon receiving this signal, you should give up your reference to <em>connection</em>. You are guaranteed that this signal is emitted only once.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000111">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">remote_peer_vanished</td><td><code>true</code> if <em>connection</em> is closed because the remote peer closed its end of the connection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af981fb48982bce9d4a27f70127df1cb5"></a><!-- doxytag: member="Gio::DBus::Connection::signal_subscribe" ref="af981fb48982bce9d4a27f70127df1cb5" args="(const SlotSignal &amp;slot, const Glib::ustring &amp;sender=Glib::ustring(), const Glib::ustring &amp;interface_name=Glib::ustring(), const Glib::ustring &amp;member=Glib::ustring(), const Glib::ustring &amp;object_path=Glib::ustring(), const Glib::ustring &amp;arg0=Glib::ustring(), SignalFlags flags=Gio::DBus::SIGNAL_FLAGS_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint <a class="el" href="classGio_1_1DBus_1_1Connection.html#af981fb48982bce9d4a27f70127df1cb5">Gio::DBus::Connection::signal_subscribe</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGio_1_1DBus_1_1Connection.html#acecd8faa0ef34d31f74439e71b3c7afc">SlotSignal</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>sender</em> = <code><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>member</em> = <code><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>object_path</em> = <code><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>arg0</em> = <code><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5978f448a9187eca418eac34799144fa">SignalFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="group__giommEnums.html#gga5978f448a9187eca418eac34799144faa08f72890c46ff66ff5df6ea3bbc2d526">Gio::DBus::SIGNAL_FLAGS_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subscribes to signals on the connection and invokes <em>slot</em> with a whenever the signal is received. </p>
<p>Note that <em>slot</em> will be invoked in the thread-default main loop of the thread you are calling this method from.</p>
<p>If the connection is not a message bus connection, <em>sender</em> must be <code>0</code>.</p>
<p>If <em>sender</em> is a well-known name note that <em>slot</em> is invoked with the unique name for the owner of <em>sender</em>, not the well-known name as one would expect. This is because the message bus rewrites the name. As such, to avoid certain race conditions, users should be tracking the name owner of the well-known name and use that when processing the received signal.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>Slot to invoke when there is a signal matching the requested data. </td></tr>
    <tr><td class="paramname">sender</td><td>Sender name to match on (unique or well-known name) or <code>0</code> to listen from all senders. </td></tr>
    <tr><td class="paramname">interface_name</td><td>D-Bus interface name to match on or <code>0</code> to match on all interfaces. </td></tr>
    <tr><td class="paramname">member</td><td>D-Bus signal name to match on or <code>0</code> to match on all signals. </td></tr>
    <tr><td class="paramname">object_path</td><td><a class="el" href="classGio_1_1DBus_1_1Object.html" title="Object - Base type for D-Bus objects.">Object</a> path to match on or <code>0</code> to match on all object paths. </td></tr>
    <tr><td class="paramname">arg0</td><td>Contents of first string argument to match on or <code>0</code> to match on all kinds of arguments. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags describing how to subscribe to the signal (currently unused). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A subscription identifier that can be used with <a class="el" href="classGio_1_1DBus_1_1Connection.html#a57d8deeb855f3f88d5a2164d224305ea" title="Unsubscribes from signals.">signal_unsubscribe()</a>. </dd></dl>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000131">Since glibmm 2.28:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a57d8deeb855f3f88d5a2164d224305ea"></a><!-- doxytag: member="Gio::DBus::Connection::signal_unsubscribe" ref="a57d8deeb855f3f88d5a2164d224305ea" args="(guint subscription_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a57d8deeb855f3f88d5a2164d224305ea">Gio::DBus::Connection::signal_unsubscribe</a> </td>
          <td>(</td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>subscription_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unsubscribes from signals. </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000107">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">subscription_id</td><td>A subscription id obtained from g_dbus_connection_signal_subscribe(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8108e440014500506db4cf1b23ea40a"></a><!-- doxytag: member="Gio::DBus::Connection::start_message_processing" ref="aa8108e440014500506db4cf1b23ea40a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#aa8108e440014500506db4cf1b23ea40a">Gio::DBus::Connection::start_message_processing</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If <em>connection</em> was created with DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method starts processing messages. </p>
<p>Does nothing on if <em>connection</em> wasn't created with this flag or if the method has already been called.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000098">Since glibmm 2.26:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a1538b4a84bd4cb0457ba6e6dde0023b3"></a><!-- doxytag: member="Gio::DBus::Connection::unexport_action_group" ref="a1538b4a84bd4cb0457ba6e6dde0023b3" args="(guint export_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a1538b4a84bd4cb0457ba6e6dde0023b3">Gio::DBus::Connection::unexport_action_group</a> </td>
          <td>(</td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>export_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverses the effect of a previous call to g_dbus_connection_export_action_group(). </p>
<p>It is an error to call this function with an ID that wasn't returned from g_dbus_connection_export_action_group() or to call it with the same ID more than once.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000017">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">export_id</td><td>The ID from g_dbus_connection_export_action_group(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b99e116bcc0a8d15cf0e9c857c62e07"></a><!-- doxytag: member="Gio::DBus::Connection::unexport_menu_model" ref="a3b99e116bcc0a8d15cf0e9c857c62e07" args="(guint export_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DBus_1_1Connection.html#a3b99e116bcc0a8d15cf0e9c857c62e07">Gio::DBus::Connection::unexport_menu_model</a> </td>
          <td>(</td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>export_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverses the effect of a previous call to g_dbus_connection_export_menu_model(). </p>
<p>It is an error to call this function with an ID that wasn't returned from g_dbus_connection_export_menu_model() or to call it with the same ID more than once.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000019">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">export_id</td><td>The ID from g_dbus_connection_export_menu_model(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32b998fc3e093c678e6ff4e76ec29874"></a><!-- doxytag: member="Gio::DBus::Connection::unregister_object" ref="a32b998fc3e093c678e6ff4e76ec29874" args="(guint registration_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DBus_1_1Connection.html#a32b998fc3e093c678e6ff4e76ec29874">Gio::DBus::Connection::unregister_object</a> </td>
          <td>(</td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>registration_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters an object. </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000109">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">registration_id</td><td>A registration id obtained from g_dbus_connection_register_object(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the object was unregistered, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aae026eab32dc1e6ef7eb865e2d83dc1d"></a><!-- doxytag: member="Gio::DBus::Connection::unregister_subtree" ref="aae026eab32dc1e6ef7eb865e2d83dc1d" args="(guint registration_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DBus_1_1Connection.html#aae026eab32dc1e6ef7eb865e2d83dc1d">Gio::DBus::Connection::unregister_subtree</a> </td>
          <td>(</td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>registration_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters a subtree. </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000110">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">registration_id</td><td>A subtree registration id obtained from g_dbus_connection_register_subtree(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the subtree was unregistered, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a0969ed44cfb18e10af19b6eec245e420"></a><!-- doxytag: member="Gio::DBus::Connection::wrap" ref="a0969ed44cfb18e10af19b6eec245e420" args="(GDBusConnection *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DBus_1_1Connection.html">Gio::DBus::Connection</a> &gt; <a class="el" href="classGio_1_1DBus_1_1Connection.html#a0969ed44cfb18e10af19b6eec245e420">wrap</a> </td>
          <td>(</td>
          <td class="paramtype">GDBusConnection *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 10 2012 14:20:38 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
