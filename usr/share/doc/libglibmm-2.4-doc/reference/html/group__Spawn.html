<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>glibmm: Spawning Processes</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="/home/murrayc/checkouts/gnome30/glibmm/docs/doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.32.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> </div>
  <div class="headertitle">
<div class="title">Spawning Processes</div> </div>
</div><!--header-->
<div class="contents">

<p>Process launching with fork()/exec(). <a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1SpawnError.html">Glib::SpawnError</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classGlib_1_1Exception.html">Exception</a> class for errors occuring when spawning processes. <a href="classGlib_1_1SpawnError.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Spawn.html#ga0a530eed9f6343ea1d51cb8ec8051ce7">Glib::spawn_async_with_pipes</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; working_directory, const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp; argv, const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp; envp, SpawnFlags flags=SpawnFlags(0), const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&amp; child_setup=<a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;(), Pid* child_pid=0, int* standard_input=0, int* standard_output=0, int* standard_error=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a child program asynchronously (your program will not block waiting for the child to exit). <a href="#ga0a530eed9f6343ea1d51cb8ec8051ce7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Spawn.html#ga36b7c1d110d10f86f3ef5d6e10db206f">Glib::spawn_async_with_pipes</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; working_directory, const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp; argv, SpawnFlags flags=SpawnFlags(0), const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&amp; child_setup=<a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;(), Pid* child_pid=0, int* standard_input=0, int* standard_output=0, int* standard_error=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the main <a class="el" href="group__Spawn.html#ga0a530eed9f6343ea1d51cb8ec8051ce7" title="Executes a child program asynchronously (your program will not block waiting for the child to exit)...">spawn_async_with_pipes()</a> method, but inheriting the parent's environment. <a href="#ga36b7c1d110d10f86f3ef5d6e10db206f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Spawn.html#ga5d42ba801678215f3820382388df32b0">Glib::spawn_async</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; working_directory, const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp; argv, const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp; envp, SpawnFlags flags=SpawnFlags(0), const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&amp; child_setup=<a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;(), Pid* child_pid=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">See pawn_async_with_pipes() for a full description. <a href="#ga5d42ba801678215f3820382388df32b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Spawn.html#ga0c4e1708989b50fb34266504cc038ee6">Glib::spawn_async</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; working_directory, const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp; argv, SpawnFlags flags=SpawnFlags(0), const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&amp; child_setup=<a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;(), Pid* child_pid=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the main <a class="el" href="group__Spawn.html#ga5d42ba801678215f3820382388df32b0" title="See pawn_async_with_pipes() for a full description.">spawn_async()</a> method, but inheriting the parent's environment. <a href="#ga0c4e1708989b50fb34266504cc038ee6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Spawn.html#gad4fbf31fdb5536b104f4f75bf58c60e1">Glib::spawn_sync</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; working_directory, const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp; argv, const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp; envp, SpawnFlags flags=SpawnFlags(0), const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&amp; child_setup=<a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;(), <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>* standard_output=0, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>* standard_error=0, int* exit_status=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a child synchronously (waits for the child to exit before returning). <a href="#gad4fbf31fdb5536b104f4f75bf58c60e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Spawn.html#gacc157258907be90b58184baeebc9c740">Glib::spawn_sync</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; working_directory, const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp; argv, SpawnFlags flags=SpawnFlags(0), const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&amp; child_setup=<a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;(), <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>* standard_output=0, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>* standard_error=0, int* exit_status=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the main <a class="el" href="group__Spawn.html#gad4fbf31fdb5536b104f4f75bf58c60e1" title="Executes a child synchronously (waits for the child to exit before returning).">spawn_sync()</a> method, but inheriting the parent's environment. <a href="#gacc157258907be90b58184baeebc9c740"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Spawn.html#ga648167a4af607f87763f1334fe5a472f">Glib::spawn_command_line_async</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; command_line)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple version of <a class="el" href="group__Spawn.html#ga5d42ba801678215f3820382388df32b0" title="See pawn_async_with_pipes() for a full description.">spawn_async()</a> that parses a command line with <a class="el" href="group__ShellUtils.html#gabc52fcb14cfc7a5ba37ca821cc837818" title="Parses a command line into an argument vector, in much the same way the shell would, but without many of the expansions the shell would perform (variable expansion, globs, operators, filename expansion, etc. are not supported).">shell_parse_argv()</a> and passes it to <a class="el" href="group__Spawn.html#ga5d42ba801678215f3820382388df32b0" title="See pawn_async_with_pipes() for a full description.">spawn_async()</a>. <a href="#ga648167a4af607f87763f1334fe5a472f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Spawn.html#ga713bdb79396eda85ad186cb2db89564f">Glib::spawn_command_line_sync</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; command_line, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>* standard_output=0, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>* standard_error=0, int* exit_status=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple version of <a class="el" href="group__Spawn.html#gad4fbf31fdb5536b104f4f75bf58c60e1" title="Executes a child synchronously (waits for the child to exit before returning).">spawn_sync()</a> with little-used parameters removed, taking a command line instead of an argument vector. <a href="#ga713bdb79396eda85ad186cb2db89564f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Spawn.html#gaaea8f41c7a08af3b2919ce64fd0c27e5">Glib::spawn_close_pid</a> (Pid pid)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">On some platforms, notably WIN32, the Pid type represents a resource which must be closed to prevent resource leaking. <a href="#gaaea8f41c7a08af3b2919ce64fd0c27e5"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Process launching with fork()/exec(). </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga5d42ba801678215f3820382388df32b0"></a><!-- doxytag: member="Glib::spawn_async" ref="ga5d42ba801678215f3820382388df32b0" args="(const std::string &amp;working_directory, const Glib::ArrayHandle&lt; std::string &gt; &amp;argv, const Glib::ArrayHandle&lt; std::string &gt; &amp;envp, SpawnFlags flags=SpawnFlags(0), const sigc::slot&lt; void &gt; &amp;child_setup=sigc::slot&lt; void &gt;(), Pid *child_pid=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Spawn.html#ga5d42ba801678215f3820382388df32b0">Glib::spawn_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>working_directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>envp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpawnFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>SpawnFlags(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>child_setup</em> = <code><a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;&#160;void&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pid *&#160;</td>
          <td class="paramname"><em>child_pid</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>See pawn_async_with_pipes() for a full description. </p>
<p>This function simply calls the <a class="el" href="group__Spawn.html#ga0a530eed9f6343ea1d51cb8ec8051ce7" title="Executes a child program asynchronously (your program will not block waiting for the child to exit)...">spawn_async_with_pipes()</a> without any pipes.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If you are writing a GTK+ application, and the program you are spawning is a graphical application, too, then you may want to use gdk_spawn_on_screen() instead to ensure that the spawned program opens its windows on the right screen.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">working_directory</td><td>Child's current working directory, or an empty string to inherit parent's. </td></tr>
    <tr><td class="paramname">argv</td><td>Child's argument vector. </td></tr>
    <tr><td class="paramname">env</td><td>Child's environment. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags from SpawnFlags. </td></tr>
    <tr><td class="paramname">child_setup</td><td>Slot to run in the child just before exec(). </td></tr>
    <tr><td class="paramname">child_pid</td><td>Return location for child process ID, or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1SpawnError.html" title="Exception class for errors occuring when spawning processes.">SpawnError</a></td><td>Errors are reported even if they occur in the child (for example if the executable in argv[0] is not found). Typically the message field of returned errors should be displayed to users. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0c4e1708989b50fb34266504cc038ee6"></a><!-- doxytag: member="Glib::spawn_async" ref="ga0c4e1708989b50fb34266504cc038ee6" args="(const std::string &amp;working_directory, const Glib::ArrayHandle&lt; std::string &gt; &amp;argv, SpawnFlags flags=SpawnFlags(0), const sigc::slot&lt; void &gt; &amp;child_setup=sigc::slot&lt; void &gt;(), Pid *child_pid=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Spawn.html#ga5d42ba801678215f3820382388df32b0">Glib::spawn_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>working_directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpawnFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>SpawnFlags(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>child_setup</em> = <code><a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;&#160;void&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pid *&#160;</td>
          <td class="paramname"><em>child_pid</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like the main <a class="el" href="group__Spawn.html#ga5d42ba801678215f3820382388df32b0" title="See pawn_async_with_pipes() for a full description.">spawn_async()</a> method, but inheriting the parent's environment. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">working_directory</td><td>Child's current working directory, or an empty string to inherit parent's. </td></tr>
    <tr><td class="paramname">argv</td><td>Child's argument vector. </td></tr>
    <tr><td class="paramname">env</td><td>Child's environment. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags from SpawnFlags. </td></tr>
    <tr><td class="paramname">child_setup</td><td>Slot to run in the child just before exec(). </td></tr>
    <tr><td class="paramname">child_pid</td><td>Return location for child process ID, or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1SpawnError.html" title="Exception class for errors occuring when spawning processes.">SpawnError</a></td><td>Errors are reported even if they occur in the child (for example if the executable in argv[0] is not found). Typically the message field of returned errors should be displayed to users. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0a530eed9f6343ea1d51cb8ec8051ce7"></a><!-- doxytag: member="Glib::spawn_async_with_pipes" ref="ga0a530eed9f6343ea1d51cb8ec8051ce7" args="(const std::string &amp;working_directory, const Glib::ArrayHandle&lt; std::string &gt; &amp;argv, const Glib::ArrayHandle&lt; std::string &gt; &amp;envp, SpawnFlags flags=SpawnFlags(0), const sigc::slot&lt; void &gt; &amp;child_setup=sigc::slot&lt; void &gt;(), Pid *child_pid=0, int *standard_input=0, int *standard_output=0, int *standard_error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Spawn.html#ga0a530eed9f6343ea1d51cb8ec8051ce7">Glib::spawn_async_with_pipes</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>working_directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>envp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpawnFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>SpawnFlags(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>child_setup</em> = <code><a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;&#160;void&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pid *&#160;</td>
          <td class="paramname"><em>child_pid</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>standard_input</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>standard_output</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>standard_error</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Executes a child program asynchronously (your program will not block waiting for the child to exit). </p>
<p>The child program is specified by the only argument that must be provided, <em>argv</em>. The first string in <em>argv</em> is of course the name of the program to execute. By default, the name of the program must be a full path; the PATH shell variable will only be searched if you pass the SPAWN_SEARCH_PATH flag.</p>
<p>On Windows, note that all the string or string vector arguments to this function and the other spawn*() functions are in UTF-8, the GLib file name encoding. <a class="el" href="namespaceGlib_1_1Unicode.html">Unicode</a> characters that are not part of the system codepage passed in these arguments will be correctly available in the spawned program only if it uses wide character API to retrieve its command line. For C programs built with Microsoft's tools it is enough to make the program have a wmain() instead of main(). wmain() has a wide character argument vector as parameter.</p>
<p>At least currently, mingw doesn't support wmain(), so if you use mingw to develop the spawned program, it will have to call the undocumented function __wgetmainargs() to get the wide character argument vector and environment. See gspawn-win32-helper.c in the GLib sources or init.c in the mingw runtime sources for a prototype for that function. Alternatively, you can retrieve the Win32 system level wide character command line passed to the spawned program using the GetCommandLineW() function.</p>
<p>On Windows the low-level child process creation API CreateProcess() doesn't use argument vectors, but a command line. The C runtime library's spawn*() family of functions (which <a class="el" href="group__Spawn.html#ga0a530eed9f6343ea1d51cb8ec8051ce7" title="Executes a child program asynchronously (your program will not block waiting for the child to exit)...">spawn_async_with_pipes()</a> eventually calls) paste the argument vector elements together into a command line, and the C runtime startup code does a corresponding reconstruction of an argument vector from the command line, to be passed to main(). Complications arise when you have argument vector elements that contain spaces of double quotes. The spawn*() functions don't do any quoting or escaping, but on the other hand the startup code does do unquoting and unescaping in order to enable receiving arguments with embedded spaces or double quotes. To work around this asymmetry, <a class="el" href="group__Spawn.html#ga0a530eed9f6343ea1d51cb8ec8051ce7" title="Executes a child program asynchronously (your program will not block waiting for the child to exit)...">spawn_async_with_pipes()</a> will do quoting and escaping on argument vector elements that need it before calling the C runtime spawn() function.</p>
<p><em>envp</em> is a lists of strings, where each string has the form KEY=VALUE. This will become the child's environment.</p>
<p><em>flags</em> should be the bitwise OR of any flags you want to affect the function's behaviour. The SPAWN_DO_NOT_REAP_CHILD flags means that the child will not automatically be reaped; you must use a ChildWatch source to be notified about the death of the child process. Eventually you must call <a class="el" href="group__Spawn.html#gaaea8f41c7a08af3b2919ce64fd0c27e5" title="On some platforms, notably WIN32, the Pid type represents a resource which must be closed to prevent ...">spawn_close_pid()</a> on the <em>child_pid</em>, in order to free resources which may be associated with the child process. (On Unix, using a ChildWatch source is equivalent to calling waitpid() or handling the SIGCHLD signal manually. On Windows, calling <a class="el" href="group__Spawn.html#gaaea8f41c7a08af3b2919ce64fd0c27e5" title="On some platforms, notably WIN32, the Pid type represents a resource which must be closed to prevent ...">spawn_close_pid()</a> is equivalent to calling CloseHandle() on the process handle returned in <em>child_pid</em>).</p>
<p>PAWN_LEAVE_DESCRIPTORS_OPEN means that the parent's open file descriptors will be inherited by the child; otherwise all descriptors except stdin/stdout/stderr will be closed before calling exec() in the child. SPAWN_SEARCH_PATH means that argv[0] need not be an absolute path, it will be looked for in the user's PATH. SPAWN_STDOUT_TO_DEV_NULL means that the child's standard output will be discarded, instead of going to the same location as the parent's standard output. If you use this flag, <em>standard_output</em> must be NULL. SPAWN_STDERR_TO_DEV_NULL means that the child's standard error will be discarded, instead of going to the same location as the parent's standard error. If you use this flag, <em>standard_error</em> must be NULL. SPAWN_CHILD_INHERITS_STDIN means that the child will inherit the parent's standard input (by default, the child's standard input is attached to /dev/null). If you use this flag, <em>standard_input</em> must be NULL. G_SPAWN_FILE_AND_ARGV_ZERO means that the first element of <em>argv</em> is the file to execute, while the remaining elements are the actual argument vector to pass to the file. Normally <a class="el" href="group__Spawn.html#ga0a530eed9f6343ea1d51cb8ec8051ce7" title="Executes a child program asynchronously (your program will not block waiting for the child to exit)...">spawn_async_with_pipes()</a> uses argv[0] as the file to execute, and passes all of <em>argv</em> to the child.</p>
<p><em>child_setup</em> is a callback slot. On POSIX platforms, the function is called in the child after GLib has performed all the setup it plans to perform (including creating pipes, closing file descriptors, etc.) but before calling exec(). That is, <em>child_setup</em> is called just before calling exec() in the child. Obviously actions taken in this function will only affect the child, not the parent. On Windows, there is no separate fork() and exec() functionality. Child processes are created and run with a single API call, CreateProcess(). <em>child_setup</em> is called in the parent process just before creating the child process. You should carefully consider what you do in <em>child_setup</em> if you intend your software to be portable to Windows.</p>
<p>If non-NULL, <em>child_pid</em> will on Unix be filled with the child's process ID. You can use the process ID to send signals to the child, or to use child_watch_add() (or waitpid()) if you specified the SPAWN_DO_NOT_REAP_CHILD flag. On Windows, <em>child_pid</em> will be filled with a handle to the child process only if you specified the SPAWN_DO_NOT_REAP_CHILD flag. You can then access the child process using the Win32 API, for example wait for its termination with the WaitFor*() functions, or examine its exit code with GetExitCodeProcess(). You should close the handle with CloseHandle() or <a class="el" href="group__Spawn.html#gaaea8f41c7a08af3b2919ce64fd0c27e5" title="On some platforms, notably WIN32, the Pid type represents a resource which must be closed to prevent ...">spawn_close_pid()</a> when you no longer need it.</p>
<p>If non-NULL, the <em>standard_input</em>, <em>standard_output</em>, <em>standard_error</em> locations will be filled with file descriptors for writing to the child's standard input or reading from its standard output or standard error. The caller of pawn_async_with_pipes() must close these file descriptors when they are no longer in use. If these parameters are NULL, the corresponding pipe won't be created.</p>
<p>If <em>standard_input</em> is NULL, the child's standard input is attached to /dev/null unless SPAWN_CHILD_INHERITS_STDIN is set.</p>
<p>If <em>standard_error</em> is NULL, the child's standard error goes to the same location as the parent's standard error unless SPAWN_STDERR_TO_DEV_NULL is set.</p>
<p>If <em>standard_output</em> is NULL, the child's standard output goes to the same location as the parent's standard output unless SPAWN_STDOUT_TO_DEV_NULL is set.</p>
<p>If <em>child_pid</em> is not NULL and an error does not occur then the returned pid must be closed using <a class="el" href="group__Spawn.html#gaaea8f41c7a08af3b2919ce64fd0c27e5" title="On some platforms, notably WIN32, the Pid type represents a resource which must be closed to prevent ...">spawn_close_pid()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If you are writing a gtkmm application, and the program you are spawning is a graphical application, too, then you may want to use spawn_on_screen_with_pipes() instead to ensure that the spawned program opens its windows on the right screen.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">working_directory</td><td>Child's current working directory, or an empty string to inherit the parent's, in the GLib file name encoding. </td></tr>
    <tr><td class="paramname">argv</td><td>Child's argument vector. </td></tr>
    <tr><td class="paramname">envp</td><td>Child's environment. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags from SpawnFlags </td></tr>
    <tr><td class="paramname">child_setup</td><td>Slot to run in the child just before exec(). </td></tr>
    <tr><td class="paramname">child_pid</td><td>Return location for child process ID, or NULL. </td></tr>
    <tr><td class="paramname">standard_input</td><td>Return location for file descriptor to write to child's stdin, or NULL. </td></tr>
    <tr><td class="paramname">standard_output</td><td>Return location for file descriptor to read child's stdout, or NULL. </td></tr>
    <tr><td class="paramname">standard_error</td><td>Return location for file descriptor to read child's stderr, or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1SpawnError.html" title="Exception class for errors occuring when spawning processes.">SpawnError</a></td><td>Errors are reported even if they occur in the child (for example if the executable in argv[0] is not found). Typically the message field of returned errors should be displayed to users. If an error occurs, <em>child_pid</em>, <em>standard_input</em>, <em>standard_output</em>, and <em>standard_error</em> will not be filled with valid values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga36b7c1d110d10f86f3ef5d6e10db206f"></a><!-- doxytag: member="Glib::spawn_async_with_pipes" ref="ga36b7c1d110d10f86f3ef5d6e10db206f" args="(const std::string &amp;working_directory, const Glib::ArrayHandle&lt; std::string &gt; &amp;argv, SpawnFlags flags=SpawnFlags(0), const sigc::slot&lt; void &gt; &amp;child_setup=sigc::slot&lt; void &gt;(), Pid *child_pid=0, int *standard_input=0, int *standard_output=0, int *standard_error=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Spawn.html#ga0a530eed9f6343ea1d51cb8ec8051ce7">Glib::spawn_async_with_pipes</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>working_directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpawnFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>SpawnFlags(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>child_setup</em> = <code><a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;&#160;void&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pid *&#160;</td>
          <td class="paramname"><em>child_pid</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>standard_input</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>standard_output</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>standard_error</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like the main <a class="el" href="group__Spawn.html#ga0a530eed9f6343ea1d51cb8ec8051ce7" title="Executes a child program asynchronously (your program will not block waiting for the child to exit)...">spawn_async_with_pipes()</a> method, but inheriting the parent's environment. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">working_directory</td><td>Child's current working directory, or an empty string to inherit the parent's, in the GLib file name encoding. </td></tr>
    <tr><td class="paramname">argv</td><td>Child's argument vector. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags from SpawnFlags </td></tr>
    <tr><td class="paramname">child_setup</td><td>Slot to run in the child just before exec(). </td></tr>
    <tr><td class="paramname">child_pid</td><td>Return location for child process ID, or NULL. </td></tr>
    <tr><td class="paramname">standard_input</td><td>Return location for file descriptor to write to child's stdin, or NULL. </td></tr>
    <tr><td class="paramname">standard_output</td><td>Return location for file descriptor to read child's stdout, or NULL. </td></tr>
    <tr><td class="paramname">standard_error</td><td>Return location for file descriptor to read child's stderr, or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1SpawnError.html" title="Exception class for errors occuring when spawning processes.">SpawnError</a></td><td>Errors are reported even if they occur in the child (for example if the executable in argv[0] is not found). Typically the message field of returned errors should be displayed to users. If an error occurs, <em>child_pid</em>, <em>standard_input</em>, <em>standard_output</em>, and <em>standard_error</em> will not be filled with valid values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaea8f41c7a08af3b2919ce64fd0c27e5"></a><!-- doxytag: member="Glib::spawn_close_pid" ref="gaaea8f41c7a08af3b2919ce64fd0c27e5" args="(Pid pid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Spawn.html#gaaea8f41c7a08af3b2919ce64fd0c27e5">Glib::spawn_close_pid</a> </td>
          <td>(</td>
          <td class="paramtype">Pid&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>On some platforms, notably WIN32, the Pid type represents a resource which must be closed to prevent resource leaking. </p>
<p>close_pid() is provided for this purpose. It should be used on all platforms, even though it doesn't do anything under UNIX.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>The process identifier to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga648167a4af607f87763f1334fe5a472f"></a><!-- doxytag: member="Glib::spawn_command_line_async" ref="ga648167a4af607f87763f1334fe5a472f" args="(const std::string &amp;command_line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Spawn.html#ga648167a4af607f87763f1334fe5a472f">Glib::spawn_command_line_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>command_line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A simple version of <a class="el" href="group__Spawn.html#ga5d42ba801678215f3820382388df32b0" title="See pawn_async_with_pipes() for a full description.">spawn_async()</a> that parses a command line with <a class="el" href="group__ShellUtils.html#gabc52fcb14cfc7a5ba37ca821cc837818" title="Parses a command line into an argument vector, in much the same way the shell would, but without many of the expansions the shell would perform (variable expansion, globs, operators, filename expansion, etc. are not supported).">shell_parse_argv()</a> and passes it to <a class="el" href="group__Spawn.html#ga5d42ba801678215f3820382388df32b0" title="See pawn_async_with_pipes() for a full description.">spawn_async()</a>. </p>
<p>It runs a command line in the background. Unlike <a class="el" href="group__Spawn.html#ga5d42ba801678215f3820382388df32b0" title="See pawn_async_with_pipes() for a full description.">spawn_async()</a>, the SPAWN_SEARCH_PATH flag is enabled, other flags are not. Note that SPAWN_SEARCH_PATH can have security implications, so consider using <a class="el" href="group__Spawn.html#ga5d42ba801678215f3820382388df32b0" title="See pawn_async_with_pipes() for a full description.">spawn_async()</a> directly if appropriate.</p>
<p>The same concerns on Windows apply as for <a class="el" href="group__Spawn.html#ga713bdb79396eda85ad186cb2db89564f" title="A simple version of spawn_sync() with little-used parameters removed, taking a command line instead o...">spawn_command_line_sync()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">command_line</td><td>A command line.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1SpawnError.html" title="Exception class for errors occuring when spawning processes.">SpawnError</a></td><td>Errors are reported even if they occur in the child (for example if the executable in argv[0] is not found). Typically the message field of returned errors should be displayed to users. </td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ShellError.html" title="Exception class for shell utility errors.">ShellError</a></td><td>If the command line could not be parsed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga713bdb79396eda85ad186cb2db89564f"></a><!-- doxytag: member="Glib::spawn_command_line_sync" ref="ga713bdb79396eda85ad186cb2db89564f" args="(const std::string &amp;command_line, std::string *standard_output=0, std::string *standard_error=0, int *exit_status=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Spawn.html#ga713bdb79396eda85ad186cb2db89564f">Glib::spawn_command_line_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>command_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> *&#160;</td>
          <td class="paramname"><em>standard_output</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> *&#160;</td>
          <td class="paramname"><em>standard_error</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>exit_status</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A simple version of <a class="el" href="group__Spawn.html#gad4fbf31fdb5536b104f4f75bf58c60e1" title="Executes a child synchronously (waits for the child to exit before returning).">spawn_sync()</a> with little-used parameters removed, taking a command line instead of an argument vector. </p>
<p>See <a class="el" href="group__Spawn.html#gad4fbf31fdb5536b104f4f75bf58c60e1" title="Executes a child synchronously (waits for the child to exit before returning).">spawn_sync()</a> for full details. <em>command_line</em> will be parsed by <a class="el" href="group__ShellUtils.html#gabc52fcb14cfc7a5ba37ca821cc837818" title="Parses a command line into an argument vector, in much the same way the shell would, but without many of the expansions the shell would perform (variable expansion, globs, operators, filename expansion, etc. are not supported).">shell_parse_argv()</a>. Unlike <a class="el" href="group__Spawn.html#gad4fbf31fdb5536b104f4f75bf58c60e1" title="Executes a child synchronously (waits for the child to exit before returning).">spawn_sync()</a>, the SPAWN_SEARCH_PATH flag is enabled. Note that SPAWN_SEARCH_PATH can have security implications, so consider using <a class="el" href="group__Spawn.html#gad4fbf31fdb5536b104f4f75bf58c60e1" title="Executes a child synchronously (waits for the child to exit before returning).">spawn_sync()</a> directly if appropriate.</p>
<p>If <em>exit_status</em> is non-NULL, the exit status of the child is stored there as it would be returned by waitpid(); standard UNIX macros such as WIFEXITED() and WEXITSTATUS() must be used to evaluate the exit status.</p>
<p>On Windows, please note the implications of <a class="el" href="group__ShellUtils.html#gabc52fcb14cfc7a5ba37ca821cc837818" title="Parses a command line into an argument vector, in much the same way the shell would, but without many of the expansions the shell would perform (variable expansion, globs, operators, filename expansion, etc. are not supported).">shell_parse_argv()</a> parsing <em>command_line</em>. Parsing is done according to Unix shell rules, not Windows command interpreter rules. Space is a separator, and backslashes are special. Thus you cannot simply pass a <em>command_line</em> containing canonical Windows paths, like "c:\\program files\\app\\app.exe", as the backslashes will be eaten, and the space will act as a separator. You need to enclose such paths with single quotes, like "'c:\\program files\\app\\app.exe' 'e:\\folder\\argument.txt'".</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">command_line</td><td>A command line. </td></tr>
    <tr><td class="paramname">standard_output</td><td>Return location for child output. </td></tr>
    <tr><td class="paramname">standard_error</td><td>Return location for child errors. </td></tr>
    <tr><td class="paramname">exit_status</td><td>Return location for child exit status, as returned by waitpid().</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1SpawnError.html" title="Exception class for errors occuring when spawning processes.">SpawnError</a></td><td>Errors are reported even if they occur in the child (for example if the executable in argv[0] is not found). Typically the message field of returned errors should be displayed to users. </td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ShellError.html" title="Exception class for shell utility errors.">ShellError</a></td><td>If the command line could not be parsed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad4fbf31fdb5536b104f4f75bf58c60e1"></a><!-- doxytag: member="Glib::spawn_sync" ref="gad4fbf31fdb5536b104f4f75bf58c60e1" args="(const std::string &amp;working_directory, const Glib::ArrayHandle&lt; std::string &gt; &amp;argv, const Glib::ArrayHandle&lt; std::string &gt; &amp;envp, SpawnFlags flags=SpawnFlags(0), const sigc::slot&lt; void &gt; &amp;child_setup=sigc::slot&lt; void &gt;(), std::string *standard_output=0, std::string *standard_error=0, int *exit_status=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Spawn.html#gad4fbf31fdb5536b104f4f75bf58c60e1">Glib::spawn_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>working_directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>envp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpawnFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>SpawnFlags(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>child_setup</em> = <code><a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;&#160;void&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> *&#160;</td>
          <td class="paramname"><em>standard_output</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> *&#160;</td>
          <td class="paramname"><em>standard_error</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>exit_status</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Executes a child synchronously (waits for the child to exit before returning). </p>
<p>All output from the child is stored in <em>standard_output</em> and <em>standard_error</em>, if those parameters are non-NULL. Note that you must set the SPAWN_STDOUT_TO_DEV_NULL and SPAWN_STDERR_TO_DEV_NULL flags when passing NULL for <em>standard_output</em> and <em>standard_error</em>. If <em>exit_status</em> is non-NULL, the exit status of the child is stored there as it would be returned by waitpid(); standard UNIX macros such as WIFEXITED() and WEXITSTATUS() must be used to evaluate the exit status. Note that this function calls waitpid() even if <em>exit_status</em> is NULL, and does not accept the SPAWN_DO_NOT_REAP_CHILD flag. If an error occurs, no data is returned in <em>standard_output</em>, <em>standard_error</em>, or <em>exit_status</em>.</p>
<p>This function calls <a class="el" href="group__Spawn.html#ga0a530eed9f6343ea1d51cb8ec8051ce7" title="Executes a child program asynchronously (your program will not block waiting for the child to exit)...">spawn_async_with_pipes()</a> internally; see that function for full details on the other parameters and details on how these functions work on Windows.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">working_directory</td><td>Child's current working directory, or an empty string to inherit the parent's, in the GLib file name encoding. </td></tr>
    <tr><td class="paramname">argv</td><td>Child's argument vector. </td></tr>
    <tr><td class="paramname">envp</td><td>Child's environment. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags from SpawnFlags </td></tr>
    <tr><td class="paramname">child_setup</td><td>Slot to run in the child just before exec(). </td></tr>
    <tr><td class="paramname">standard_output</td><td>Return location for file descriptor to read child's stdout, or NULL. </td></tr>
    <tr><td class="paramname">standard_error</td><td>Return location for file descriptor to read child's stderr, or NULL. </td></tr>
    <tr><td class="paramname">exit_status</td><td>Return location for child exit status, as returned by waitpid(), or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1SpawnError.html" title="Exception class for errors occuring when spawning processes.">SpawnError</a></td><td>Errors are reported even if they occur in the child (for example if the executable in argv[0] is not found). Typically the message field of returned errors should be displayed to users. If an error occurs, <em>child_pid</em>, <em>standard_input</em>, <em>standard_output</em>, and <em>standard_error</em> will not be filled with valid values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacc157258907be90b58184baeebc9c740"></a><!-- doxytag: member="Glib::spawn_sync" ref="gacc157258907be90b58184baeebc9c740" args="(const std::string &amp;working_directory, const Glib::ArrayHandle&lt; std::string &gt; &amp;argv, SpawnFlags flags=SpawnFlags(0), const sigc::slot&lt; void &gt; &amp;child_setup=sigc::slot&lt; void &gt;(), std::string *standard_output=0, std::string *standard_error=0, int *exit_status=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Spawn.html#gad4fbf31fdb5536b104f4f75bf58c60e1">Glib::spawn_sync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>working_directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpawnFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>SpawnFlags(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>child_setup</em> = <code><a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;&#160;void&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> *&#160;</td>
          <td class="paramname"><em>standard_output</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> *&#160;</td>
          <td class="paramname"><em>standard_error</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>exit_status</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like the main <a class="el" href="group__Spawn.html#gad4fbf31fdb5536b104f4f75bf58c60e1" title="Executes a child synchronously (waits for the child to exit before returning).">spawn_sync()</a> method, but inheriting the parent's environment. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">working_directory</td><td>Child's current working directory, or an empty string to inherit the parent's, in the GLib file name encoding. </td></tr>
    <tr><td class="paramname">argv</td><td>Child's argument vector. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags from SpawnFlags </td></tr>
    <tr><td class="paramname">child_setup</td><td>Slot to run in the child just before exec(). </td></tr>
    <tr><td class="paramname">standard_output</td><td>Return location for file descriptor to read child's stdout, or NULL. </td></tr>
    <tr><td class="paramname">standard_error</td><td>Return location for file descriptor to read child's stderr, or NULL. </td></tr>
    <tr><td class="paramname">exit_status</td><td>Return location for child exit status, as returned by waitpid(), or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1SpawnError.html" title="Exception class for errors occuring when spawning processes.">SpawnError</a></td><td>Errors are reported even if they occur in the child (for example if the executable in argv[0] is not found). Typically the message field of returned errors should be displayed to users. If an error occurs, <em>child_pid</em>, <em>standard_input</em>, <em>standard_output</em>, and <em>standard_error</em> will not be filled with valid values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 10 2012 14:20:36 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
