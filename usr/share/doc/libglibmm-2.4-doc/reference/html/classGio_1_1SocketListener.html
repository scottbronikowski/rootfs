<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>glibmm: Gio::SocketListener Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="/home/murrayc/checkouts/gnome30/glibmm/docs/doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.32.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceGio.html">Gio</a> </li>
      <li class="navelem"><a class="el" href="classGio_1_1SocketListener.html">SocketListener</a> </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> </div>
  <div class="headertitle">
<div class="title">Gio::SocketListener Class Reference<div class="ingroups"><a class="el" href="group__NetworkIO.html">Portable Network I/O Functionality</a></div></div> </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Gio::SocketListener" --><!-- doxytag: inherits="Glib::Object" -->
<p>Helper for accepting network client connections.  <a href="classGio_1_1SocketListener.html#details">More...</a></p>

<p><code>#include &lt;giomm/socketlistener.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gio::SocketListener:</div>
<div class="dyncontent">
<div class="center"><img src="classGio_1_1SocketListener__inherit__graph.png" border="0" usemap="#Gio_1_1SocketListener_inherit__map" alt="Inheritance graph"/></div>
<map name="Gio_1_1SocketListener_inherit__map" id="Gio_1_1SocketListener_inherit__map">
<area shape="rect" id="node9" href="classGio_1_1SocketService.html" title="Make it easy to implement a network service." alt="" coords="36,315,177,344"/><area shape="rect" id="node2" href="classGlib_1_1Object.html" title="Glib::Object" alt="" coords="60,160,153,189"/><area shape="rect" id="node4" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="44,83,169,112"/><area shape="rect" id="node6" href="../../../libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="49,5,164,35"/><area shape="rect" id="node11" href="classGio_1_1ThreadedSocketService.html" title="A threaded GSocketService." alt="" coords="5,392,208,421"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGio_1_1SocketListener-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a72cc482888057f1e6747309e382ae669">~SocketListener</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GSocketListener*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a112233a13be0e663a39b677d8c1a8952">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a112233a13be0e663a39b677d8c1a8952"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GSocketListener*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#aa0befe419ff983ed1b28e5b1c99b511b">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#aa0befe419ff983ed1b28e5b1c99b511b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GSocketListener*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a9cdd04703b826b397f73f0bbf6badf99">gobj_copy</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. <a href="#a9cdd04703b826b397f73f0bbf6badf99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a1e0b34890d5475229a96696b3bc136c8">set_backlog</a> (int listen_backlog)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the listen backlog on the sockets in the listener. <a href="#a1e0b34890d5475229a96696b3bc136c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#af14e9d38af77406d829fda8c1090c06b">add_socket</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&amp; socket, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&amp; source_object)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <em>socket</em> to the set of sockets that we try to accept new clients from. <a href="#af14e9d38af77406d829fda8c1090c06b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#aa24cb88b5d0e78505e533e65fb8e7dea">add_socket</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&amp; socket)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <em>socket</em> to the set of sockets that we try to accept new clients from. <a href="#aa24cb88b5d0e78505e533e65fb8e7dea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a478b171019370dee7059c4a8fdaf6ec2">add_address</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, <a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a> <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01612.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, <a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a> protocol, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&amp; source_object, <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; effective_address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a socket of type <em>type</em> and protocol <em>protocol</em>, binds it to <em>address</em> and adds it to the set of sockets we're accepting sockets from. <a href="#a478b171019370dee7059c4a8fdaf6ec2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a17961c5dff54d2d6e311c50d2c744bc1">add_address</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, <a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a> <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01612.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, <a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a> protocol, <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; effective_address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a socket of type <em>type</em> and protocol <em>protocol</em>, binds it to <em>address</em> and adds it to the set of sockets we're accepting sockets from. <a href="#a17961c5dff54d2d6e311c50d2c744bc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a3ccffa841f43c0df0f632eb54ad1b441">add_inet_port</a> (guint16 port, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&amp; source_object)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for g_socket_listener_add_address() that creates a TCP/IP socket listening on IPv4 and IPv6 (if supported) on the specified port on all interfaces. <a href="#a3ccffa841f43c0df0f632eb54ad1b441"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a59491f0159709ed08cd71c55cb738def">add_inet_port</a> (guint16 port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for g_socket_listener_add_address() that creates a TCP/IP socket listening on IPv4 and IPv6 (if supported) on the specified port on all interfaces. <a href="#a59491f0159709ed08cd71c55cb738def"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a7639ca25eb3efe301ba08df635c2fc37">add_any_inet_port</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&amp; source_object)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Listens for TCP connections on any available port number for both IPv6 and IPv4 (if each is available). <a href="#a7639ca25eb3efe301ba08df635c2fc37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a8cf1d0491124ef2eb40de9a4392e973b">add_any_inet_port</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Listens for TCP connections on any available port number for both IPv6 and IPv4 (if each is available). <a href="#a8cf1d0491124ef2eb40de9a4392e973b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a5a9657d9840d3e9d85efb406bb2393d2">accept_socket</a> (<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&amp; source_object, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks waiting for a client to connect to any of the sockets added to the listener. <a href="#a5a9657d9840d3e9d85efb406bb2393d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a3e79b5b10555b73e4359671cdb53e038">accept_socket</a> (<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&amp; source_object)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks waiting for a client to connect to any of the sockets added to the listener. <a href="#a3e79b5b10555b73e4359671cdb53e038"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#ac1951a2d25a34ee2305e8d82ae45250f">accept_socket</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks waiting for a client to connect to any of the sockets added to the listener. <a href="#ac1951a2d25a34ee2305e8d82ae45250f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a7caaf5afa1bf47bce88db9322271f804">accept_socket</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks waiting for a client to connect to any of the sockets added to the listener. <a href="#a7caaf5afa1bf47bce88db9322271f804"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a8fcc271647a1aa8628d2b2e60dd53d16">accept_socket_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the asynchronous version of g_socket_listener_accept_socket(). <a href="#a8fcc271647a1aa8628d2b2e60dd53d16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#aac3928ba157107d4f7609d8686ae4c6e">accept_socket_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the asynchronous version of g_socket_listener_accept_socket(). <a href="#aac3928ba157107d4f7609d8686ae4c6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a8875402a2dd1c5b1705236fd89081b3c">accept_socket_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&amp; source_object)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an async accept operation. <a href="#a8875402a2dd1c5b1705236fd89081b3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#ad6aeb8c8c05167b47a1479e2cbf8453c">accept_socket_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an async accept operation. <a href="#ad6aeb8c8c05167b47a1479e2cbf8453c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketConnection.html">SocketConnection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a9329c1c706b3e53e8afbf29b8b320a68">accept</a> (<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html#ad43f7c5ad0336e1eb3af622392a112eb">Object</a> &gt;&amp; source_object, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks waiting for a client to connect to any of the sockets added to the listener. <a href="#a9329c1c706b3e53e8afbf29b8b320a68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketConnection.html">SocketConnection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#ae6658e2ae53b7108ee7f6b15dddbfa56">accept</a> (<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html#ad43f7c5ad0336e1eb3af622392a112eb">Object</a> &gt;&amp; source_object)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks waiting for a client to connect to any of the sockets added to the listener. <a href="#ae6658e2ae53b7108ee7f6b15dddbfa56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketConnection.html">SocketConnection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a2a0508771a9423713be6bf642fd1a3c4">accept</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks waiting for a client to connect to any of the sockets added to the listener. <a href="#a2a0508771a9423713be6bf642fd1a3c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketConnection.html">SocketConnection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#ac06069d9d192be5fe770272f213bc9e3">accept</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks waiting for a client to connect to any of the sockets added to the listener. <a href="#ac06069d9d192be5fe770272f213bc9e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a671c1485ca21446d5e0d2e555c05fa21">accept_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the asynchronous version of g_socket_listener_accept(). <a href="#a671c1485ca21446d5e0d2e555c05fa21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a27c6ce168ebbebd3848b246d7b9ecb64">accept_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the asynchronous version of g_socket_listener_accept(). <a href="#a27c6ce168ebbebd3848b246d7b9ecb64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketConnection.html">SocketConnection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#ad09943bd09686f6cba2a6ad661000592">accept_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&amp; source_object)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an async accept operation. <a href="#ad09943bd09686f6cba2a6ad661000592"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketConnection.html">SocketConnection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#ab9a973269f259350e38b7843dfa93aa5">accept_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an async accept operation. <a href="#ab9a973269f259350e38b7843dfa93aa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#aa6da0570259eeeee527757628dc0f351">close</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes all the sockets in the listener. <a href="#aa6da0570259eeeee527757628dc0f351"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a272ea9e83e8ca5a33d9e5701a5d5e87e">property_listen_backlog</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">outstanding connections in the listen queue. <a href="#a272ea9e83e8ca5a33d9e5701a5d5e87e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a8750daf6ee0ba95a864df26c1a5e6d3a">property_listen_backlog</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">outstanding connections in the listen queue. <a href="#a8750daf6ee0ba95a864df26c1a5e6d3a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1SocketListener.html">SocketListener</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#a9ccbd6cc071b99b9631a84e50f920c67">create</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#ac60f15482d07f3d1396f7aba35f03462">SocketListener</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketListener.html">Gio::SocketListener</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1SocketListener.html#ad1255a07751ad4ab4cf8c76ffef73d7e">wrap</a> (GSocketListener* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#ad1255a07751ad4ab4cf8c76ffef73d7e"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Helper for accepting network client connections. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGio_1_1ThreadedSocketService.html" title="A threaded GSocketService.">ThreadedSocketService</a>, <a class="el" href="classGio_1_1SocketService.html" title="Make it easy to implement a network service.">SocketService</a>.</dd></dl>
<p>A <a class="el" href="classGio_1_1SocketListener.html" title="Helper for accepting network client connections.">SocketListener</a> is an object that keeps track of a set of server sockets and helps you accept sockets from any of the socket, either sync or async.</p>
<p>If you want to implement a network server, also look at <a class="el" href="classGio_1_1SocketService.html" title="Make it easy to implement a network service.">SocketService</a> and <a class="el" href="classGio_1_1ThreadedSocketService.html" title="A threaded GSocketService.">ThreadedSocketService</a> which are subclass of <a class="el" href="classGio_1_1SocketListener.html" title="Helper for accepting network client connections.">SocketListener</a> that makes this even easier.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000035">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a72cc482888057f1e6747309e382ae669"></a><!-- doxytag: member="Gio::SocketListener::~SocketListener" ref="a72cc482888057f1e6747309e382ae669" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGio_1_1SocketListener.html#a72cc482888057f1e6747309e382ae669">Gio::SocketListener::~SocketListener</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac60f15482d07f3d1396f7aba35f03462"></a><!-- doxytag: member="Gio::SocketListener::SocketListener" ref="ac60f15482d07f3d1396f7aba35f03462" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1SocketListener.html#ac60f15482d07f3d1396f7aba35f03462">Gio::SocketListener::SocketListener</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9329c1c706b3e53e8afbf29b8b320a68"></a><!-- doxytag: member="Gio::SocketListener::accept" ref="a9329c1c706b3e53e8afbf29b8b320a68" args="(Glib::RefPtr&lt; Object &gt; &amp;source_object, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketConnection.html">SocketConnection</a>&gt; <a class="el" href="classGio_1_1SocketListener.html#a9329c1c706b3e53e8afbf29b8b320a68">Gio::SocketListener::accept</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html#ad43f7c5ad0336e1eb3af622392a112eb">Object</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>source_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blocks waiting for a client to connect to any of the sockets added to the listener. </p>
<p>Returns a <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a> for the socket that was accepted.</p>
<p>If <em>source_object</em> is not <code>0</code> it will be filled out with the source object specified when the corresponding socket or address was added to the listener.</p>
<p>If <em>cancellable</em> is not <code>0</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error IO_ERROR_CANCELLED will be returned.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000161">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source_object</td><td>Location where Object pointer will be stored, or <code>0</code>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a> on success, <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6658e2ae53b7108ee7f6b15dddbfa56"></a><!-- doxytag: member="Gio::SocketListener::accept" ref="ae6658e2ae53b7108ee7f6b15dddbfa56" args="(Glib::RefPtr&lt; Object &gt; &amp;source_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketConnection.html">SocketConnection</a>&gt; <a class="el" href="classGio_1_1SocketListener.html#a9329c1c706b3e53e8afbf29b8b320a68">Gio::SocketListener::accept</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html#ad43f7c5ad0336e1eb3af622392a112eb">Object</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>source_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blocks waiting for a client to connect to any of the sockets added to the listener. </p>
<p>Returns a <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a> for the socket that was accepted.</p>
<p>If <em>source_object</em> is not <code>0</code> it will be filled out with the source object specified when the corresponding socket or address was added to the listener.</p>
<p>If <em>cancellable</em> is not <code>0</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error IO_ERROR_CANCELLED will be returned.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000162">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source_object</td><td>Location where Object pointer will be stored, or <code>0</code>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a> on success, <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a0508771a9423713be6bf642fd1a3c4"></a><!-- doxytag: member="Gio::SocketListener::accept" ref="a2a0508771a9423713be6bf642fd1a3c4" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketConnection.html">SocketConnection</a>&gt; <a class="el" href="classGio_1_1SocketListener.html#a9329c1c706b3e53e8afbf29b8b320a68">Gio::SocketListener::accept</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blocks waiting for a client to connect to any of the sockets added to the listener. </p>
<p>Returns a <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a> for the socket that was accepted.</p>
<p>If <em>source_object</em> is not <code>0</code> it will be filled out with the source object specified when the corresponding socket or address was added to the listener.</p>
<p>If <em>cancellable</em> is not <code>0</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error IO_ERROR_CANCELLED will be returned.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000163">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source_object</td><td>Location where Object pointer will be stored, or <code>0</code>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a> on success, <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ac06069d9d192be5fe770272f213bc9e3"></a><!-- doxytag: member="Gio::SocketListener::accept" ref="ac06069d9d192be5fe770272f213bc9e3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketConnection.html">SocketConnection</a>&gt; <a class="el" href="classGio_1_1SocketListener.html#a9329c1c706b3e53e8afbf29b8b320a68">Gio::SocketListener::accept</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blocks waiting for a client to connect to any of the sockets added to the listener. </p>
<p>Returns a <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a> for the socket that was accepted.</p>
<p>If <em>source_object</em> is not <code>0</code> it will be filled out with the source object specified when the corresponding socket or address was added to the listener.</p>
<p>If <em>cancellable</em> is not <code>0</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error IO_ERROR_CANCELLED will be returned.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000164">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source_object</td><td>Location where Object pointer will be stored, or <code>0</code>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a> on success, <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a671c1485ca21446d5e0d2e555c05fa21"></a><!-- doxytag: member="Gio::SocketListener::accept_async" ref="a671c1485ca21446d5e0d2e555c05fa21" args="(const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1SocketListener.html#a671c1485ca21446d5e0d2e555c05fa21">Gio::SocketListener::accept_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the asynchronous version of g_socket_listener_accept(). </p>
<p>When the operation is finished <em>callback</em> will be called. You can then call g_socket_listener_accept_socket() to get the result of the operation.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000165">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>, or <code>0</code>. </td></tr>
    <tr><td class="paramname">callback</td><td>A AsyncReadyCallback. </td></tr>
    <tr><td class="paramname">user_data</td><td>User data for the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27c6ce168ebbebd3848b246d7b9ecb64"></a><!-- doxytag: member="Gio::SocketListener::accept_async" ref="a27c6ce168ebbebd3848b246d7b9ecb64" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1SocketListener.html#a671c1485ca21446d5e0d2e555c05fa21">Gio::SocketListener::accept_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the asynchronous version of g_socket_listener_accept(). </p>
<p>When the operation is finished <em>callback</em> will be called. You can then call g_socket_listener_accept_socket() to get the result of the operation.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000166">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>, or <code>0</code>. </td></tr>
    <tr><td class="paramname">callback</td><td>A AsyncReadyCallback. </td></tr>
    <tr><td class="paramname">user_data</td><td>User data for the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad09943bd09686f6cba2a6ad661000592"></a><!-- doxytag: member="Gio::SocketListener::accept_finish" ref="ad09943bd09686f6cba2a6ad661000592" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, Glib::RefPtr&lt; Glib::Object &gt; &amp;source_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketConnection.html">SocketConnection</a>&gt; <a class="el" href="classGio_1_1SocketListener.html#ad09943bd09686f6cba2a6ad661000592">Gio::SocketListener::accept_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>source_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an async accept operation. </p>
<p>See g_socket_listener_accept_async()</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000167">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">source_object</td><td>Optional Object identifying this source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a> on success, <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9a973269f259350e38b7843dfa93aa5"></a><!-- doxytag: member="Gio::SocketListener::accept_finish" ref="ab9a973269f259350e38b7843dfa93aa5" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketConnection.html">SocketConnection</a>&gt; <a class="el" href="classGio_1_1SocketListener.html#ad09943bd09686f6cba2a6ad661000592">Gio::SocketListener::accept_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an async accept operation. </p>
<p>See g_socket_listener_accept_async()</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000168">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">source_object</td><td>Optional Object identifying this source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a> on success, <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a9657d9840d3e9d85efb406bb2393d2"></a><!-- doxytag: member="Gio::SocketListener::accept_socket" ref="a5a9657d9840d3e9d85efb406bb2393d2" args="(Glib::RefPtr&lt; Glib::Object &gt; &amp;source_object, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; <a class="el" href="classGio_1_1SocketListener.html#a5a9657d9840d3e9d85efb406bb2393d2">Gio::SocketListener::accept_socket</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>source_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blocks waiting for a client to connect to any of the sockets added to the listener. </p>
<p>Returns the <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> that was accepted.</p>
<p>If you want to accept the high-level <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a>, not a <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>, which is often the case, then you should use g_socket_listener_accept() instead.</p>
<p>If <em>source_object</em> is not <code>0</code> it will be filled out with the source object specified when the corresponding socket or address was added to the listener.</p>
<p>If <em>cancellable</em> is not <code>0</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error IO_ERROR_CANCELLED will be returned.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000153">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source_object</td><td>Location where Object pointer will be stored, or <code>0</code>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> on success, <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e79b5b10555b73e4359671cdb53e038"></a><!-- doxytag: member="Gio::SocketListener::accept_socket" ref="a3e79b5b10555b73e4359671cdb53e038" args="(Glib::RefPtr&lt; Glib::Object &gt; &amp;source_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; <a class="el" href="classGio_1_1SocketListener.html#a5a9657d9840d3e9d85efb406bb2393d2">Gio::SocketListener::accept_socket</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>source_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blocks waiting for a client to connect to any of the sockets added to the listener. </p>
<p>Returns the <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> that was accepted.</p>
<p>If you want to accept the high-level <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a>, not a <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>, which is often the case, then you should use g_socket_listener_accept() instead.</p>
<p>If <em>source_object</em> is not <code>0</code> it will be filled out with the source object specified when the corresponding socket or address was added to the listener.</p>
<p>If <em>cancellable</em> is not <code>0</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error IO_ERROR_CANCELLED will be returned.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000154">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source_object</td><td>Location where Object pointer will be stored, or <code>0</code>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> on success, <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1951a2d25a34ee2305e8d82ae45250f"></a><!-- doxytag: member="Gio::SocketListener::accept_socket" ref="ac1951a2d25a34ee2305e8d82ae45250f" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; <a class="el" href="classGio_1_1SocketListener.html#a5a9657d9840d3e9d85efb406bb2393d2">Gio::SocketListener::accept_socket</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blocks waiting for a client to connect to any of the sockets added to the listener. </p>
<p>Returns the <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> that was accepted.</p>
<p>If you want to accept the high-level <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a>, not a <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>, which is often the case, then you should use g_socket_listener_accept() instead.</p>
<p>If <em>source_object</em> is not <code>0</code> it will be filled out with the source object specified when the corresponding socket or address was added to the listener.</p>
<p>If <em>cancellable</em> is not <code>0</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error IO_ERROR_CANCELLED will be returned.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000155">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source_object</td><td>Location where Object pointer will be stored, or <code>0</code>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> on success, <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a7caaf5afa1bf47bce88db9322271f804"></a><!-- doxytag: member="Gio::SocketListener::accept_socket" ref="a7caaf5afa1bf47bce88db9322271f804" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; <a class="el" href="classGio_1_1SocketListener.html#a5a9657d9840d3e9d85efb406bb2393d2">Gio::SocketListener::accept_socket</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blocks waiting for a client to connect to any of the sockets added to the listener. </p>
<p>Returns the <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> that was accepted.</p>
<p>If you want to accept the high-level <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a>, not a <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>, which is often the case, then you should use g_socket_listener_accept() instead.</p>
<p>If <em>source_object</em> is not <code>0</code> it will be filled out with the source object specified when the corresponding socket or address was added to the listener.</p>
<p>If <em>cancellable</em> is not <code>0</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error IO_ERROR_CANCELLED will be returned.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000156">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source_object</td><td>Location where Object pointer will be stored, or <code>0</code>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> on success, <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a8fcc271647a1aa8628d2b2e60dd53d16"></a><!-- doxytag: member="Gio::SocketListener::accept_socket_async" ref="a8fcc271647a1aa8628d2b2e60dd53d16" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1SocketListener.html#a8fcc271647a1aa8628d2b2e60dd53d16">Gio::SocketListener::accept_socket_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the asynchronous version of g_socket_listener_accept_socket(). </p>
<p>When the operation is finished <em>callback</em> will be called. You can then call g_socket_listener_accept_socket_finish() to get the result of the operation.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000157">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>, or <code>0</code>. </td></tr>
    <tr><td class="paramname">callback</td><td>A AsyncReadyCallback. </td></tr>
    <tr><td class="paramname">user_data</td><td>User data for the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac3928ba157107d4f7609d8686ae4c6e"></a><!-- doxytag: member="Gio::SocketListener::accept_socket_async" ref="aac3928ba157107d4f7609d8686ae4c6e" args="(const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1SocketListener.html#a8fcc271647a1aa8628d2b2e60dd53d16">Gio::SocketListener::accept_socket_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the asynchronous version of g_socket_listener_accept_socket(). </p>
<p>When the operation is finished <em>callback</em> will be called. You can then call g_socket_listener_accept_socket_finish() to get the result of the operation.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000158">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>, or <code>0</code>. </td></tr>
    <tr><td class="paramname">callback</td><td>A AsyncReadyCallback. </td></tr>
    <tr><td class="paramname">user_data</td><td>User data for the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8875402a2dd1c5b1705236fd89081b3c"></a><!-- doxytag: member="Gio::SocketListener::accept_socket_finish" ref="a8875402a2dd1c5b1705236fd89081b3c" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, Glib::RefPtr&lt; Glib::Object &gt; &amp;source_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; <a class="el" href="classGio_1_1SocketListener.html#a8875402a2dd1c5b1705236fd89081b3c">Gio::SocketListener::accept_socket_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>source_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an async accept operation. </p>
<p>See g_socket_listener_accept_socket_async()</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000159">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">source_object</td><td>Optional Object identifying this source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> on success, <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6aeb8c8c05167b47a1479e2cbf8453c"></a><!-- doxytag: member="Gio::SocketListener::accept_socket_finish" ref="ad6aeb8c8c05167b47a1479e2cbf8453c" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; <a class="el" href="classGio_1_1SocketListener.html#a8875402a2dd1c5b1705236fd89081b3c">Gio::SocketListener::accept_socket_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes an async accept operation. </p>
<p>See g_socket_listener_accept_socket_async()</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000160">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">source_object</td><td>Optional Object identifying this source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> on success, <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a478b171019370dee7059c4a8fdaf6ec2"></a><!-- doxytag: member="Gio::SocketListener::add_address" ref="a478b171019370dee7059c4a8fdaf6ec2" args="(const Glib::RefPtr&lt; SocketAddress &gt; &amp;address, SocketType type, SocketProtocol protocol, const Glib::RefPtr&lt; Glib::Object &gt; &amp;source_object, Glib::RefPtr&lt; SocketAddress &gt; &amp;effective_address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1SocketListener.html#a478b171019370dee7059c4a8fdaf6ec2">Gio::SocketListener::add_address</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a>&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>source_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>effective_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a socket of type <em>type</em> and protocol <em>protocol</em>, binds it to <em>address</em> and adds it to the set of sockets we're accepting sockets from. </p>
<p>Note that adding an IPv6 address, depending on the platform, may or may not result in a listener that also accepts IPv4 connections. For more deterministic behavior, see g_socket_listener_add_inet_port().</p>
<p><em>source_object</em> will be passed out in the various calls to accept to identify this particular source, which is useful if you're listening on multiple addresses and do different things depending on what address is connected to.</p>
<p>If successful and <em>effective_address</em> is non-<code>0</code> then it will be set to the address that the binding actually occurred at. This is helpful for determining the port number that was used for when requesting a binding to port 0 (ie: "any port"). This address, if requested, belongs to the caller and must be freed.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000149">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a>. </td></tr>
    <tr><td class="paramname">type</td><td>A SocketType. </td></tr>
    <tr><td class="paramname">protocol</td><td>A SocketProtocol. </td></tr>
    <tr><td class="paramname">source_object</td><td>Optional Object identifying this source. </td></tr>
    <tr><td class="paramname">effective_address</td><td>Location to store the address that was bound to, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a17961c5dff54d2d6e311c50d2c744bc1"></a><!-- doxytag: member="Gio::SocketListener::add_address" ref="a17961c5dff54d2d6e311c50d2c744bc1" args="(const Glib::RefPtr&lt; SocketAddress &gt; &amp;address, SocketType type, SocketProtocol protocol, Glib::RefPtr&lt; SocketAddress &gt; &amp;effective_address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1SocketListener.html#a478b171019370dee7059c4a8fdaf6ec2">Gio::SocketListener::add_address</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a>&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>effective_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a socket of type <em>type</em> and protocol <em>protocol</em>, binds it to <em>address</em> and adds it to the set of sockets we're accepting sockets from. </p>
<p>Note that adding an IPv6 address, depending on the platform, may or may not result in a listener that also accepts IPv4 connections. For more deterministic behavior, see g_socket_listener_add_inet_port().</p>
<p><em>source_object</em> will be passed out in the various calls to accept to identify this particular source, which is useful if you're listening on multiple addresses and do different things depending on what address is connected to.</p>
<p>If successful and <em>effective_address</em> is non-<code>0</code> then it will be set to the address that the binding actually occurred at. This is helpful for determining the port number that was used for when requesting a binding to port 0 (ie: "any port"). This address, if requested, belongs to the caller and must be freed.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000150">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a>. </td></tr>
    <tr><td class="paramname">type</td><td>A SocketType. </td></tr>
    <tr><td class="paramname">protocol</td><td>A SocketProtocol. </td></tr>
    <tr><td class="paramname">source_object</td><td>Optional Object identifying this source. </td></tr>
    <tr><td class="paramname">effective_address</td><td>Location to store the address that was bound to, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a7639ca25eb3efe301ba08df635c2fc37"></a><!-- doxytag: member="Gio::SocketListener::add_any_inet_port" ref="a7639ca25eb3efe301ba08df635c2fc37" args="(const Glib::RefPtr&lt; Glib::Object &gt; &amp;source_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint16 <a class="el" href="classGio_1_1SocketListener.html#a7639ca25eb3efe301ba08df635c2fc37">Gio::SocketListener::add_any_inet_port</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>source_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Listens for TCP connections on any available port number for both IPv6 and IPv4 (if each is available). </p>
<p>This is useful if you need to have a socket for incoming connections but don't care about the specific port number.</p>
<p><em>source_object</em> will be passed out in the various calls to accept to identify this particular source, which is useful if you're listening on multiple addresses and do different things depending on what address is connected to.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000036">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source_object</td><td>Optional Object identifying this source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The port number, or 0 in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a8cf1d0491124ef2eb40de9a4392e973b"></a><!-- doxytag: member="Gio::SocketListener::add_any_inet_port" ref="a8cf1d0491124ef2eb40de9a4392e973b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint16 <a class="el" href="classGio_1_1SocketListener.html#a7639ca25eb3efe301ba08df635c2fc37">Gio::SocketListener::add_any_inet_port</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Listens for TCP connections on any available port number for both IPv6 and IPv4 (if each is available). </p>
<p>This is useful if you need to have a socket for incoming connections but don't care about the specific port number.</p>
<p><em>source_object</em> will be passed out in the various calls to accept to identify this particular source, which is useful if you're listening on multiple addresses and do different things depending on what address is connected to.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000037">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source_object</td><td>Optional Object identifying this source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The port number, or 0 in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ccffa841f43c0df0f632eb54ad1b441"></a><!-- doxytag: member="Gio::SocketListener::add_inet_port" ref="a3ccffa841f43c0df0f632eb54ad1b441" args="(guint16 port, const Glib::RefPtr&lt; Glib::Object &gt; &amp;source_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1SocketListener.html#a3ccffa841f43c0df0f632eb54ad1b441">Gio::SocketListener::add_inet_port</a> </td>
          <td>(</td>
          <td class="paramtype">guint16&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>source_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function for g_socket_listener_add_address() that creates a TCP/IP socket listening on IPv4 and IPv6 (if supported) on the specified port on all interfaces. </p>
<p><em>source_object</em> will be passed out in the various calls to accept to identify this particular source, which is useful if you're listening on multiple addresses and do different things depending on what address is connected to.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000151">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>An IP port number (non-zero). </td></tr>
    <tr><td class="paramname">source_object</td><td>Optional Object identifying this source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a59491f0159709ed08cd71c55cb738def"></a><!-- doxytag: member="Gio::SocketListener::add_inet_port" ref="a59491f0159709ed08cd71c55cb738def" args="(guint16 port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1SocketListener.html#a3ccffa841f43c0df0f632eb54ad1b441">Gio::SocketListener::add_inet_port</a> </td>
          <td>(</td>
          <td class="paramtype">guint16&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function for g_socket_listener_add_address() that creates a TCP/IP socket listening on IPv4 and IPv6 (if supported) on the specified port on all interfaces. </p>
<p><em>source_object</em> will be passed out in the various calls to accept to identify this particular source, which is useful if you're listening on multiple addresses and do different things depending on what address is connected to.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000152">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>An IP port number (non-zero). </td></tr>
    <tr><td class="paramname">source_object</td><td>Optional Object identifying this source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="af14e9d38af77406d829fda8c1090c06b"></a><!-- doxytag: member="Gio::SocketListener::add_socket" ref="af14e9d38af77406d829fda8c1090c06b" args="(const Glib::RefPtr&lt; Socket &gt; &amp;socket, const Glib::RefPtr&lt; Glib::Object &gt; &amp;source_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1SocketListener.html#af14e9d38af77406d829fda8c1090c06b">Gio::SocketListener::add_socket</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>source_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <em>socket</em> to the set of sockets that we try to accept new clients from. </p>
<p>The socket must be bound to a local address and listened to.</p>
<p><em>source_object</em> will be passed out in the various calls to accept to identify this particular source, which is useful if you're listening on multiple addresses and do different things depending on what address is connected to.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000147">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>A listening <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>. </td></tr>
    <tr><td class="paramname">source_object</td><td>Optional Object identifying this source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa24cb88b5d0e78505e533e65fb8e7dea"></a><!-- doxytag: member="Gio::SocketListener::add_socket" ref="aa24cb88b5d0e78505e533e65fb8e7dea" args="(const Glib::RefPtr&lt; Socket &gt; &amp;socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1SocketListener.html#af14e9d38af77406d829fda8c1090c06b">Gio::SocketListener::add_socket</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <em>socket</em> to the set of sockets that we try to accept new clients from. </p>
<p>The socket must be bound to a local address and listened to.</p>
<p><em>source_object</em> will be passed out in the various calls to accept to identify this particular source, which is useful if you're listening on multiple addresses and do different things depending on what address is connected to.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000148">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>A listening <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>. </td></tr>
    <tr><td class="paramname">source_object</td><td>Optional Object identifying this source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6da0570259eeeee527757628dc0f351"></a><!-- doxytag: member="Gio::SocketListener::close" ref="aa6da0570259eeeee527757628dc0f351" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1SocketListener.html#aa6da0570259eeeee527757628dc0f351">Gio::SocketListener::close</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes all the sockets in the listener. </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000169">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a9ccbd6cc071b99b9631a84e50f920c67"></a><!-- doxytag: member="Gio::SocketListener::create" ref="a9ccbd6cc071b99b9631a84e50f920c67" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketListener.html">SocketListener</a>&gt; <a class="el" href="classGio_1_1SocketListener.html#a9ccbd6cc071b99b9631a84e50f920c67">Gio::SocketListener::create</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classGio_1_1SocketService.html#a40a2042eaff19ac07203edf3563770e0">Gio::SocketService</a>.</p>

</div>
</div>
<a class="anchor" id="a112233a13be0e663a39b677d8c1a8952"></a><!-- doxytag: member="Gio::SocketListener::gobj" ref="a112233a13be0e663a39b677d8c1a8952" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSocketListener* <a class="el" href="classGio_1_1SocketListener.html#a112233a13be0e663a39b677d8c1a8952">Gio::SocketListener::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#a4c6efc18be8cb9c56e58fc0bd20fafbe">Glib::ObjectBase</a>.</p>

<p>Reimplemented in <a class="el" href="classGio_1_1SocketService.html#a6e08a8e365648d3b7b8d78e694f9e136">Gio::SocketService</a>, and <a class="el" href="classGio_1_1ThreadedSocketService.html#a96312b53e69f1f46fc6de0561dfaeef2">Gio::ThreadedSocketService</a>.</p>

</div>
</div>
<a class="anchor" id="aa0befe419ff983ed1b28e5b1c99b511b"></a><!-- doxytag: member="Gio::SocketListener::gobj" ref="aa0befe419ff983ed1b28e5b1c99b511b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GSocketListener* <a class="el" href="classGio_1_1SocketListener.html#a112233a13be0e663a39b677d8c1a8952">Gio::SocketListener::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#a778a94181132976bbfb0519793f3b32e">Glib::ObjectBase</a>.</p>

<p>Reimplemented in <a class="el" href="classGio_1_1SocketService.html#adf4f54dcaa8e285061e5101e1ca37187">Gio::SocketService</a>, and <a class="el" href="classGio_1_1ThreadedSocketService.html#afb30f6700033321e12b7cf6aff933a6e">Gio::ThreadedSocketService</a>.</p>

</div>
</div>
<a class="anchor" id="a9cdd04703b826b397f73f0bbf6badf99"></a><!-- doxytag: member="Gio::SocketListener::gobj_copy" ref="a9cdd04703b826b397f73f0bbf6badf99" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSocketListener* <a class="el" href="classGio_1_1SocketListener.html#a9cdd04703b826b397f73f0bbf6badf99">Gio::SocketListener::gobj_copy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

<p>Reimplemented in <a class="el" href="classGio_1_1SocketService.html#a02c4f3bec98ba70fd2cc2663227cc5d3">Gio::SocketService</a>, and <a class="el" href="classGio_1_1ThreadedSocketService.html#abe79abc5c8e85b5a5a7147060a145318">Gio::ThreadedSocketService</a>.</p>

</div>
</div>
<a class="anchor" id="a272ea9e83e8ca5a33d9e5701a5d5e87e"></a><!-- doxytag: member="Gio::SocketListener::property_listen_backlog" ref="a272ea9e83e8ca5a33d9e5701a5d5e87e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; int &gt; <a class="el" href="classGio_1_1SocketListener.html#a272ea9e83e8ca5a33d9e5701a5d5e87e">Gio::SocketListener::property_listen_backlog</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>outstanding connections in the listen queue. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a8750daf6ee0ba95a864df26c1a5e6d3a"></a><!-- doxytag: member="Gio::SocketListener::property_listen_backlog" ref="a8750daf6ee0ba95a864df26c1a5e6d3a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; int &gt; <a class="el" href="classGio_1_1SocketListener.html#a272ea9e83e8ca5a33d9e5701a5d5e87e">Gio::SocketListener::property_listen_backlog</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>outstanding connections in the listen queue. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e0b34890d5475229a96696b3bc136c8"></a><!-- doxytag: member="Gio::SocketListener::set_backlog" ref="a1e0b34890d5475229a96696b3bc136c8" args="(int listen_backlog)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1SocketListener.html#a1e0b34890d5475229a96696b3bc136c8">Gio::SocketListener::set_backlog</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>listen_backlog</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the listen backlog on the sockets in the listener. </p>
<p>See g_socket_set_listen_backlog() for details</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000146">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">listen_backlog</td><td>An integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ad1255a07751ad4ab4cf8c76ffef73d7e"></a><!-- doxytag: member="Gio::SocketListener::wrap" ref="ad1255a07751ad4ab4cf8c76ffef73d7e" args="(GSocketListener *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketListener.html">Gio::SocketListener</a> &gt; <a class="el" href="classGio_1_1SocketListener.html#ad1255a07751ad4ab4cf8c76ffef73d7e">wrap</a> </td>
          <td>(</td>
          <td class="paramtype">GSocketListener *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 10 2012 14:20:38 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
