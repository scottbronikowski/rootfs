<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>glibmm: Gio::DataInputStream Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="/home/murrayc/checkouts/gnome30/glibmm/docs/doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.32.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceGio.html">Gio</a> </li>
      <li class="navelem"><a class="el" href="classGio_1_1DataInputStream.html">DataInputStream</a> </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> </div>
  <div class="headertitle">
<div class="title">Gio::DataInputStream Class Reference<div class="ingroups"><a class="el" href="group__Streams.html">Stream Classes</a></div></div> </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Gio::DataInputStream" --><!-- doxytag: inherits="Gio::BufferedInputStream" -->
<p>An implementation of <a class="el" href="classGio_1_1BufferedInputStream.html" title="The buffered input stream implements FilterInputStream and provides for buffered reads.">BufferedInputStream</a> that allows for high-level data manipulation of arbitrary data (including binary operations).  <a href="classGio_1_1DataInputStream.html#details">More...</a></p>

<p><code>#include &lt;giomm/datainputstream.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gio::DataInputStream:</div>
<div class="dyncontent">
<div class="center"><img src="classGio_1_1DataInputStream__inherit__graph.png" border="0" usemap="#Gio_1_1DataInputStream_inherit__map" alt="Inheritance graph"/></div>
<map name="Gio_1_1DataInputStream_inherit__map" id="Gio_1_1DataInputStream_inherit__map">
<area shape="rect" id="node2" href="classGio_1_1BufferedInputStream.html" title="The buffered input stream implements FilterInputStream and provides for buffered reads." alt="" coords="5,392,189,421"/><area shape="rect" id="node4" href="classGio_1_1FilterInputStream.html" title="Filter Input Stream." alt="" coords="17,315,177,344"/><area shape="rect" id="node6" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input." alt="" coords="32,237,163,267"/><area shape="rect" id="node8" href="classGlib_1_1Object.html" title="Glib::Object" alt="" coords="51,160,144,189"/><area shape="rect" id="node10" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="35,83,160,112"/><area shape="rect" id="node12" href="../../../libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="40,5,155,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGio_1_1DataInputStream-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#ae97b466761df6cccb9b4232e8dece6d5">~DataInputStream</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GDataInputStream*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#ad788764326462190e900785f50a50740">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#ad788764326462190e900785f50a50740"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GDataInputStream*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a5d8f01998854eac791a3089acef051c0">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a5d8f01998854eac791a3089acef051c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GDataInputStream*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a8252806b8ac5548c51a0418162ddb6ab">gobj_copy</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. <a href="#a8252806b8ac5548c51a0418162ddb6ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a032c20df06b83828d3cb5e81f6b8f561">set_byte_order</a> (<a class="el" href="group__giommEnums.html#ga87dea9b56fed9c0bca0f8426fb57781e">DataStreamByteOrder</a> order)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the byte order for the given <em>stream</em>. <a href="#a032c20df06b83828d3cb5e81f6b8f561"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga87dea9b56fed9c0bca0f8426fb57781e">DataStreamByteOrder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a3be4cc7ce927af027630cdeea0914004">get_byte_order</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the byte order for the data input stream. <a href="#a3be4cc7ce927af027630cdeea0914004"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#afbc8ad1476fd82e808234a661bfe4cd3">set_newline_type</a> (<a class="el" href="group__giommEnums.html#ga2de111fe308aff763fb98a39bc507267">DataStreamNewlineType</a> <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01612.html#ga2c2933c16c723af4d77eb939438617ca">type</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the newline type for the <em>stream</em>. <a href="#afbc8ad1476fd82e808234a661bfe4cd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga2de111fe308aff763fb98a39bc507267">DataStreamNewlineType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#afe528b7ecf9401b7bf91f0c67e34de9f">get_newline_type</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current newline type for the <em>stream</em>. <a href="#afe528b7ecf9401b7bf91f0c67e34de9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guchar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#aca226b5c2d1248dd079d835dd089570d">read_byte</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an unsigned 8-bit/1-byte value from <em>stream</em>. <a href="#aca226b5c2d1248dd079d835dd089570d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guchar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#af4d01aa4e791d403b79db406befcc28e">read_byte</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#af4d01aa4e791d403b79db406befcc28e" title="non-cancellable version of read_byte()">read_byte()</a> <a href="#af4d01aa4e791d403b79db406befcc28e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a9fd357f931715d83c69b7010ff86af80">read_int16</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit/2-byte value from <em>stream</em>. <a href="#a9fd357f931715d83c69b7010ff86af80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a2407fa551610510cfdcda3b2d8adabdc">read_int16</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#a2407fa551610510cfdcda3b2d8adabdc" title="non-cancellable version of read_int16()">read_int16()</a> <a href="#a2407fa551610510cfdcda3b2d8adabdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a9ac667e423ec3c3d997fc2a4683956d3">read_uint16</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an unsigned 16-bit/2-byte value from <em>stream</em>. <a href="#a9ac667e423ec3c3d997fc2a4683956d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a4e99722aa033a78ac2f4dc593b36d197">read_uint16</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#a4e99722aa033a78ac2f4dc593b36d197" title="non-cancellable version of read_uint16()">read_uint16()</a> <a href="#a4e99722aa033a78ac2f4dc593b36d197"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a6280a6c0c6cc1803dc3df8dc29910bcd">read_int32</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a signed 32-bit/4-byte value from <em>stream</em>. <a href="#a6280a6c0c6cc1803dc3df8dc29910bcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#adbbe894fae2ba5d071c3f50895af9067">read_int32</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#adbbe894fae2ba5d071c3f50895af9067" title="non-cancellable version of read_int32()">read_int32()</a> <a href="#adbbe894fae2ba5d071c3f50895af9067"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#ae7d36dbd67425b923fe335ec5a3f4124">read_uint32</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an unsigned 32-bit/4-byte value from <em>stream</em>. <a href="#ae7d36dbd67425b923fe335ec5a3f4124"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a587856139c73d6c2df1ad2c5560cffec">read_uint32</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#a587856139c73d6c2df1ad2c5560cffec" title="non-cancellable version of read_uint32()">read_uint32()</a> <a href="#a587856139c73d6c2df1ad2c5560cffec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a5d9599527bcd651841fd4f73082d26e0">read_int64</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit/8-byte value from <em>stream</em>. <a href="#a5d9599527bcd651841fd4f73082d26e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a6ccd4123a211d1d89c17bb6e4a4aae35">read_int64</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#a6ccd4123a211d1d89c17bb6e4a4aae35" title="non-cancellable version of read_int64()">read_int64()</a> <a href="#a6ccd4123a211d1d89c17bb6e4a4aae35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a2e486863876f833e910286300c7e17a4">read_uint64</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an unsigned 64-bit/8-byte value from <em>stream</em>. <a href="#a2e486863876f833e910286300c7e17a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">guint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a9c7ed7807b2a8370f879a820dd0c7989">read_uint64</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#a9c7ed7807b2a8370f879a820dd0c7989" title="non-cancellable version of read_uint64()">read_uint64()</a> <a href="#a9c7ed7807b2a8370f879a820dd0c7989"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a4e1ac2a250c7acd60417454379d580a7">read_line</a> (<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; line, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a line from the data input stream. <a href="#a4e1ac2a250c7acd60417454379d580a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a5186689410fe626e35688190b65ec0c5">read_line</a> (<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; line)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#a4e1ac2a250c7acd60417454379d580a7" title="Reads a line from the data input stream.">read_line()</a>. <a href="#a5186689410fe626e35688190b65ec0c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#ac779efdf33abb470832715abeb47f3ef">read_line_utf8</a> (<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; line, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, gsize&amp; length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a UTF-8 encoded line from the data input stream. <a href="#ac779efdf33abb470832715abeb47f3ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#ad48b87d450f26683d167c74c7c224ceb">read_line_utf8</a> (<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; line, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1DataInputStream.html#ac779efdf33abb470832715abeb47f3ef" title="Reads a UTF-8 encoded line from the data input stream.">read_line_utf8()</a> convenience overload. <a href="#ad48b87d450f26683d167c74c7c224ceb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#aa1ba4df39f51b81c6e105c71d5941493">read_line_utf8</a> (<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; line, gsize&amp; length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1DataInputStream.html#ac779efdf33abb470832715abeb47f3ef" title="Reads a UTF-8 encoded line from the data input stream.">read_line_utf8()</a> convenience overload. <a href="#aa1ba4df39f51b81c6e105c71d5941493"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a8cdccad3a356c1bc34bc9ec967b710b0">read_line_utf8</a> (<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; line)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1DataInputStream.html#ac779efdf33abb470832715abeb47f3ef" title="Reads a UTF-8 encoded line from the data input stream.">read_line_utf8()</a> convenience overload. <a href="#a8cdccad3a356c1bc34bc9ec967b710b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#aad31c733d13f737f893326b3b7f1ff0d">read_line_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The asynchronous version of <a class="el" href="classGio_1_1DataInputStream.html#a058c5367f9be4e4e36d5fb9de2201815" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_until()</a>. <a href="#aad31c733d13f737f893326b3b7f1ff0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a538562b9bf3a80138ba9918b2249f834">read_line_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish an asynchronous call started by <a class="el" href="classGio_1_1DataInputStream.html#aad31c733d13f737f893326b3b7f1ff0d" title="The asynchronous version of read_until().">read_line_async()</a>. <a href="#a538562b9bf3a80138ba9918b2249f834"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a5dade4189842c81b4dc3fc43a8b79af3">read_line_finish_utf8</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; data, gsize&amp; length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish an asynchronous call started by g_data_input_stream_read_line_async(). <a href="#a5dade4189842c81b4dc3fc43a8b79af3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a79e503ebe50065088e7daaa306da9cc3">read_line_finish_utf8</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1DataInputStream.html#a5dade4189842c81b4dc3fc43a8b79af3" title="Finish an asynchronous call started by g_data_input_stream_read_line_async().">read_line_finish_utf8()</a> convenience overload. <a href="#a79e503ebe50065088e7daaa306da9cc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a058c5367f9be4e4e36d5fb9de2201815">read_until</a> (<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; data, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; stop_chars, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string from the data input stream, up to the first occurrence of any of the stop characters. <a href="#a058c5367f9be4e4e36d5fb9de2201815"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#aa7d2a04bf5a4628df0530ec40d4c33cf">read_until</a> (<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; data, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; stop_chars)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#a058c5367f9be4e4e36d5fb9de2201815" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_until()</a>. <a href="#aa7d2a04bf5a4628df0530ec40d4c33cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a708cba487c68c8c927fe8ae6277b6123">read_until_async</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; stop_chars, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The asynchronous version of <a class="el" href="classGio_1_1DataInputStream.html#a058c5367f9be4e4e36d5fb9de2201815" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_until()</a>. <a href="#a708cba487c68c8c927fe8ae6277b6123"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#aa851cb398896f39bea56868b46bd480d">read_until_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish an asynchronous call started by <a class="el" href="classGio_1_1DataInputStream.html#a708cba487c68c8c927fe8ae6277b6123" title="The asynchronous version of read_until().">read_until_async()</a>. <a href="#aa851cb398896f39bea56868b46bd480d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#ae1ecebe6229884c4510e5b42eabe4874">read_upto</a> (<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; data, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; stop_chars, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string from the data input stream, up to the first occurrence of any of the stop characters. <a href="#ae1ecebe6229884c4510e5b42eabe4874"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#afe582f97c8438b1517f16e805e332d1f">read_upto</a> (<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; data, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; stop_chars)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#ae1ecebe6229884c4510e5b42eabe4874" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_upto()</a>. <a href="#afe582f97c8438b1517f16e805e332d1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a76d195879b8aa04c22a5c69dc82c0f46">read_upto_async</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; stop_chars, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The asynchronous version of <a class="el" href="classGio_1_1DataInputStream.html#ae1ecebe6229884c4510e5b42eabe4874" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_upto()</a>. <a href="#a76d195879b8aa04c22a5c69dc82c0f46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#ad0b61e9b6225bea6af433ae28dbdbea8">read_upto_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish an asynchronous call started by <a class="el" href="classGio_1_1DataInputStream.html#a76d195879b8aa04c22a5c69dc82c0f46" title="The asynchronous version of read_upto().">read_upto_async()</a>. <a href="#ad0b61e9b6225bea6af433ae28dbdbea8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a><br class="typebreak"/>
&lt; <a class="el" href="group__giommEnums.html#ga87dea9b56fed9c0bca0f8426fb57781e">DataStreamByteOrder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a53ffda2bedfb47315afc50d9ec64ba3b">property_byte_order</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The byte order. <a href="#a53ffda2bedfb47315afc50d9ec64ba3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="group__giommEnums.html#ga87dea9b56fed9c0bca0f8426fb57781e">DataStreamByteOrder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a0311a24a36a555cf9e471fbe7aa11050">property_byte_order</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The byte order. <a href="#a0311a24a36a555cf9e471fbe7aa11050"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a><br class="typebreak"/>
&lt; <a class="el" href="group__giommEnums.html#ga2de111fe308aff763fb98a39bc507267">DataStreamNewlineType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#adf55222b27ecf5db6a604d4e111431f8">property_newline_type</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The accepted types of line ending. <a href="#adf55222b27ecf5db6a604d4e111431f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="group__giommEnums.html#ga2de111fe308aff763fb98a39bc507267">DataStreamNewlineType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#aec1a1d826fb927eccc4c9f5b444e33af">property_newline_type</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The accepted types of line ending. <a href="#aec1a1d826fb927eccc4c9f5b444e33af"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1DataInputStream.html">DataInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a5ecca0b3f4fdc5962c3c63e4e6706e4e">create</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InputStream.html">InputStream</a> &gt;&amp; base_stream)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input.">InputStream</a> from the given base_stream, with a buffer set to the default size (4 kilobytes). <a href="#a5ecca0b3f4fdc5962c3c63e4e6706e4e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a65e68eef09e6aa1d9e52d446a171fba3">DataInputStream</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InputStream.html">InputStream</a> &gt;&amp; base_stream)</td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1DataInputStream.html">Gio::DataInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1DataInputStream.html#a88853a1864df25dc8dda900a6ad52266">wrap</a> (GDataInputStream* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#a88853a1864df25dc8dda900a6ad52266"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>An implementation of <a class="el" href="classGio_1_1BufferedInputStream.html" title="The buffered input stream implements FilterInputStream and provides for buffered reads.">BufferedInputStream</a> that allows for high-level data manipulation of arbitrary data (including binary operations). </p>
<dl class="since_2_16"><dt><b><a class="el" href="since_2_16.html#_since_2_16000020">Since glibmm 2.16:</a></b></dt><dd></dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae97b466761df6cccb9b4232e8dece6d5"></a><!-- doxytag: member="Gio::DataInputStream::~DataInputStream" ref="ae97b466761df6cccb9b4232e8dece6d5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGio_1_1DataInputStream.html#ae97b466761df6cccb9b4232e8dece6d5">Gio::DataInputStream::~DataInputStream</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a65e68eef09e6aa1d9e52d446a171fba3"></a><!-- doxytag: member="Gio::DataInputStream::DataInputStream" ref="a65e68eef09e6aa1d9e52d446a171fba3" args="(const Glib::RefPtr&lt; InputStream &gt; &amp;base_stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1DataInputStream.html#a65e68eef09e6aa1d9e52d446a171fba3">Gio::DataInputStream::DataInputStream</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InputStream.html">InputStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>base_stream</em></td><td>)</td>
          <td><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5ecca0b3f4fdc5962c3c63e4e6706e4e"></a><!-- doxytag: member="Gio::DataInputStream::create" ref="a5ecca0b3f4fdc5962c3c63e4e6706e4e" args="(const Glib::RefPtr&lt; InputStream &gt; &amp;base_stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1DataInputStream.html">DataInputStream</a>&gt; <a class="el" href="classGio_1_1DataInputStream.html#a5ecca0b3f4fdc5962c3c63e4e6706e4e">Gio::DataInputStream::create</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InputStream.html">InputStream</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>base_stream</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input.">InputStream</a> from the given base_stream, with a buffer set to the default size (4 kilobytes). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">base_stream</td><td>An <a class="el" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input.">InputStream</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an <a class="el" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input.">InputStream</a> for the given base_stream. </dd></dl>

<p>Reimplemented from <a class="el" href="classGio_1_1BufferedInputStream.html#afc33c31f5c437df14d385d3aa9d1a37b">Gio::BufferedInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a3be4cc7ce927af027630cdeea0914004"></a><!-- doxytag: member="Gio::DataInputStream::get_byte_order" ref="a3be4cc7ce927af027630cdeea0914004" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga87dea9b56fed9c0bca0f8426fb57781e">DataStreamByteOrder</a> <a class="el" href="classGio_1_1DataInputStream.html#a3be4cc7ce927af027630cdeea0914004">Gio::DataInputStream::get_byte_order</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the byte order for the data input stream. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <em>stream's</em> current DataStreamByteOrder. </dd></dl>

</div>
</div>
<a class="anchor" id="afe528b7ecf9401b7bf91f0c67e34de9f"></a><!-- doxytag: member="Gio::DataInputStream::get_newline_type" ref="afe528b7ecf9401b7bf91f0c67e34de9f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga2de111fe308aff763fb98a39bc507267">DataStreamNewlineType</a> <a class="el" href="classGio_1_1DataInputStream.html#afe528b7ecf9401b7bf91f0c67e34de9f">Gio::DataInputStream::get_newline_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current newline type for the <em>stream</em>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>DataStreamNewlineType for the given <em>stream</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad788764326462190e900785f50a50740"></a><!-- doxytag: member="Gio::DataInputStream::gobj" ref="ad788764326462190e900785f50a50740" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GDataInputStream* <a class="el" href="classGio_1_1DataInputStream.html#ad788764326462190e900785f50a50740">Gio::DataInputStream::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGio_1_1BufferedInputStream.html#aa9d0c1e643650b9a45831865f06e21be">Gio::BufferedInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a5d8f01998854eac791a3089acef051c0"></a><!-- doxytag: member="Gio::DataInputStream::gobj" ref="a5d8f01998854eac791a3089acef051c0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GDataInputStream* <a class="el" href="classGio_1_1DataInputStream.html#ad788764326462190e900785f50a50740">Gio::DataInputStream::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGio_1_1BufferedInputStream.html#ad6b09565f69b4c1cf1f0ca05ee53709e">Gio::BufferedInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a8252806b8ac5548c51a0418162ddb6ab"></a><!-- doxytag: member="Gio::DataInputStream::gobj_copy" ref="a8252806b8ac5548c51a0418162ddb6ab" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GDataInputStream* <a class="el" href="classGio_1_1DataInputStream.html#a8252806b8ac5548c51a0418162ddb6ab">Gio::DataInputStream::gobj_copy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

<p>Reimplemented from <a class="el" href="classGio_1_1BufferedInputStream.html#a47dc5f78b1faed25cdaaafe42b526d6d">Gio::BufferedInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a53ffda2bedfb47315afc50d9ec64ba3b"></a><!-- doxytag: member="Gio::DataInputStream::property_byte_order" ref="a53ffda2bedfb47315afc50d9ec64ba3b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; <a class="el" href="group__giommEnums.html#ga87dea9b56fed9c0bca0f8426fb57781e">DataStreamByteOrder</a> &gt; <a class="el" href="classGio_1_1DataInputStream.html#a53ffda2bedfb47315afc50d9ec64ba3b">Gio::DataInputStream::property_byte_order</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The byte order. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a0311a24a36a555cf9e471fbe7aa11050"></a><!-- doxytag: member="Gio::DataInputStream::property_byte_order" ref="a0311a24a36a555cf9e471fbe7aa11050" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="group__giommEnums.html#ga87dea9b56fed9c0bca0f8426fb57781e">DataStreamByteOrder</a> &gt; <a class="el" href="classGio_1_1DataInputStream.html#a53ffda2bedfb47315afc50d9ec64ba3b">Gio::DataInputStream::property_byte_order</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The byte order. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="adf55222b27ecf5db6a604d4e111431f8"></a><!-- doxytag: member="Gio::DataInputStream::property_newline_type" ref="adf55222b27ecf5db6a604d4e111431f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; <a class="el" href="group__giommEnums.html#ga2de111fe308aff763fb98a39bc507267">DataStreamNewlineType</a> &gt; <a class="el" href="classGio_1_1DataInputStream.html#adf55222b27ecf5db6a604d4e111431f8">Gio::DataInputStream::property_newline_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The accepted types of line ending. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="aec1a1d826fb927eccc4c9f5b444e33af"></a><!-- doxytag: member="Gio::DataInputStream::property_newline_type" ref="aec1a1d826fb927eccc4c9f5b444e33af" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="group__giommEnums.html#ga2de111fe308aff763fb98a39bc507267">DataStreamNewlineType</a> &gt; <a class="el" href="classGio_1_1DataInputStream.html#adf55222b27ecf5db6a604d4e111431f8">Gio::DataInputStream::property_newline_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The accepted types of line ending. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PropertyProxy that allows you to get or set the property of the value, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="aca226b5c2d1248dd079d835dd089570d"></a><!-- doxytag: member="Gio::DataInputStream::read_byte" ref="aca226b5c2d1248dd079d835dd089570d" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guchar <a class="el" href="classGio_1_1DataInputStream.html#aca226b5c2d1248dd079d835dd089570d">Gio::DataInputStream::read_byte</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads an unsigned 8-bit/1-byte value from <em>stream</em>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An unsigned 8-bit/1-byte value read from the <em>stream</em> or %0 if an error occurred. </dd></dl>

<p>Reimplemented from <a class="el" href="classGio_1_1BufferedInputStream.html#a85477f09b58dfb83e5a1ef62f119457a">Gio::BufferedInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="af4d01aa4e791d403b79db406befcc28e"></a><!-- doxytag: member="Gio::DataInputStream::read_byte" ref="af4d01aa4e791d403b79db406befcc28e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guchar <a class="el" href="classGio_1_1DataInputStream.html#aca226b5c2d1248dd079d835dd089570d">Gio::DataInputStream::read_byte</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#af4d01aa4e791d403b79db406befcc28e" title="non-cancellable version of read_byte()">read_byte()</a> </p>

<p>Reimplemented from <a class="el" href="classGio_1_1BufferedInputStream.html#a8741ffb62c82425f54bc5e005c2a238f">Gio::BufferedInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a9fd357f931715d83c69b7010ff86af80"></a><!-- doxytag: member="Gio::DataInputStream::read_int16" ref="a9fd357f931715d83c69b7010ff86af80" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint16 <a class="el" href="classGio_1_1DataInputStream.html#a9fd357f931715d83c69b7010ff86af80">Gio::DataInputStream::read_int16</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a 16-bit/2-byte value from <em>stream</em>. </p>
<p>In order to get the correct byte order for this read operation, see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order(). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A signed 16-bit/2-byte value read from <em>stream</em> or %0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a2407fa551610510cfdcda3b2d8adabdc"></a><!-- doxytag: member="Gio::DataInputStream::read_int16" ref="a2407fa551610510cfdcda3b2d8adabdc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint16 <a class="el" href="classGio_1_1DataInputStream.html#a9fd357f931715d83c69b7010ff86af80">Gio::DataInputStream::read_int16</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#a2407fa551610510cfdcda3b2d8adabdc" title="non-cancellable version of read_int16()">read_int16()</a> </p>

</div>
</div>
<a class="anchor" id="a6280a6c0c6cc1803dc3df8dc29910bcd"></a><!-- doxytag: member="Gio::DataInputStream::read_int32" ref="a6280a6c0c6cc1803dc3df8dc29910bcd" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint32 <a class="el" href="classGio_1_1DataInputStream.html#a6280a6c0c6cc1803dc3df8dc29910bcd">Gio::DataInputStream::read_int32</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a signed 32-bit/4-byte value from <em>stream</em>. </p>
<p>In order to get the correct byte order for this read operation, see Glib::data_stream_get_byte_order() and Glib::data_stream_set_byte_order().</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A signed 32-bit/4-byte value read from the <em>stream</em> or %0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="adbbe894fae2ba5d071c3f50895af9067"></a><!-- doxytag: member="Gio::DataInputStream::read_int32" ref="adbbe894fae2ba5d071c3f50895af9067" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint32 <a class="el" href="classGio_1_1DataInputStream.html#a6280a6c0c6cc1803dc3df8dc29910bcd">Gio::DataInputStream::read_int32</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#adbbe894fae2ba5d071c3f50895af9067" title="non-cancellable version of read_int32()">read_int32()</a> </p>

</div>
</div>
<a class="anchor" id="a5d9599527bcd651841fd4f73082d26e0"></a><!-- doxytag: member="Gio::DataInputStream::read_int64" ref="a5d9599527bcd651841fd4f73082d26e0" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint64 <a class="el" href="classGio_1_1DataInputStream.html#a5d9599527bcd651841fd4f73082d26e0">Gio::DataInputStream::read_int64</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a 64-bit/8-byte value from <em>stream</em>. </p>
<p>In order to get the correct byte order for this read operation, see Glib::data_stream_get_byte_order() and Glib::data_stream_set_byte_order().</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A signed 64-bit/8-byte value read from <em>stream</em> or %0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ccd4123a211d1d89c17bb6e4a4aae35"></a><!-- doxytag: member="Gio::DataInputStream::read_int64" ref="a6ccd4123a211d1d89c17bb6e4a4aae35" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint64 <a class="el" href="classGio_1_1DataInputStream.html#a5d9599527bcd651841fd4f73082d26e0">Gio::DataInputStream::read_int64</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#a6ccd4123a211d1d89c17bb6e4a4aae35" title="non-cancellable version of read_int64()">read_int64()</a> </p>

</div>
</div>
<a class="anchor" id="a4e1ac2a250c7acd60417454379d580a7"></a><!-- doxytag: member="Gio::DataInputStream::read_line" ref="a4e1ac2a250c7acd60417454379d580a7" args="(std::string &amp;line, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DataInputStream.html#a4e1ac2a250c7acd60417454379d580a7">Gio::DataInputStream::read_line</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a line from the data input stream. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A string to fill with the read data (without the newlines). </td></tr>
    <tr><td class="paramname">cancellable</td><td>A cancellable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the read succeeded without error. </dd></dl>

</div>
</div>
<a class="anchor" id="a5186689410fe626e35688190b65ec0c5"></a><!-- doxytag: member="Gio::DataInputStream::read_line" ref="a5186689410fe626e35688190b65ec0c5" args="(std::string &amp;line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DataInputStream.html#a4e1ac2a250c7acd60417454379d580a7">Gio::DataInputStream::read_line</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#a4e1ac2a250c7acd60417454379d580a7" title="Reads a line from the data input stream.">read_line()</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A string to fill with the read data (without the newlines). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the read succeeded without error. </dd></dl>

</div>
</div>
<a class="anchor" id="aad31c733d13f737f893326b3b7f1ff0d"></a><!-- doxytag: member="Gio::DataInputStream::read_line_async" ref="aad31c733d13f737f893326b3b7f1ff0d" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DataInputStream.html#aad31c733d13f737f893326b3b7f1ff0d">Gio::DataInputStream::read_line_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The asynchronous version of <a class="el" href="classGio_1_1DataInputStream.html#a058c5367f9be4e4e36d5fb9de2201815" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_until()</a>. </p>
<p>It is an error to have two outstanding calls to this function.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>The slot to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A cancellable object. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the read succeeded without error. </dd></dl>

</div>
</div>
<a class="anchor" id="a538562b9bf3a80138ba9918b2249f834"></a><!-- doxytag: member="Gio::DataInputStream::read_line_finish" ref="a538562b9bf3a80138ba9918b2249f834" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, std::string &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DataInputStream.html#a538562b9bf3a80138ba9918b2249f834">Gio::DataInputStream::read_line_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish an asynchronous call started by <a class="el" href="classGio_1_1DataInputStream.html#aad31c733d13f737f893326b3b7f1ff0d" title="The asynchronous version of read_until().">read_line_async()</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> that was provided to the callback slot. </td></tr>
    <tr><td class="paramname">data</td><td>A string to fill with the read data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the read succeeded without error. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dade4189842c81b4dc3fc43a8b79af3"></a><!-- doxytag: member="Gio::DataInputStream::read_line_finish_utf8" ref="a5dade4189842c81b4dc3fc43a8b79af3" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, std::string &amp;data, gsize &amp;length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DataInputStream.html#a5dade4189842c81b4dc3fc43a8b79af3">Gio::DataInputStream::read_line_finish_utf8</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish an asynchronous call started by g_data_input_stream_read_line_async(). </p>
<dl class="since_2_30"><dt><b><a class="el" href="since_2_30.html#_since_2_30000005">Since glibmm 2.30:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> that was provided to the callback. </td></tr>
    <tr><td class="paramname">length</td><td>A #gsize to get the length of the data read in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string with the line that was read in (without the newlines). Set <em>length</em> to a #gsize to get the length of the read line. On an error, it will return <code>0</code> and <em>error</em> will be set. For UTF-8 conversion errors, the set error domain is CONVERT_ERROR. If there's no content to read, it will still return <code>0</code>, but <em>error</em> won't be set. </dd></dl>

</div>
</div>
<a class="anchor" id="a79e503ebe50065088e7daaa306da9cc3"></a><!-- doxytag: member="Gio::DataInputStream::read_line_finish_utf8" ref="a79e503ebe50065088e7daaa306da9cc3" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, std::string &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DataInputStream.html#a5dade4189842c81b4dc3fc43a8b79af3">Gio::DataInputStream::read_line_finish_utf8</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="classGio_1_1DataInputStream.html#a5dade4189842c81b4dc3fc43a8b79af3" title="Finish an asynchronous call started by g_data_input_stream_read_line_async().">read_line_finish_utf8()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="ac779efdf33abb470832715abeb47f3ef"></a><!-- doxytag: member="Gio::DataInputStream::read_line_utf8" ref="ac779efdf33abb470832715abeb47f3ef" args="(std::string &amp;line, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, gsize &amp;length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DataInputStream.html#ac779efdf33abb470832715abeb47f3ef">Gio::DataInputStream::read_line_utf8</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a UTF-8 encoded line from the data input stream. </p>
<p>If <em>cancellable</em> is not <code>0</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error IO_ERROR_CANCELLED will be returned.</p>
<dl class="since_2_30"><dt><b><a class="el" href="since_2_30.html#_since_2_30000004">Since glibmm 2.30:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>A #gsize to get the length of the data read in. </td></tr>
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A NUL terminated UTF-8 string with the line that was read in (without the newlines). Set <em>length</em> to a #gsize to get the length of the read line. On an error, it will return <code>0</code> and <em>error</em> will be set. For UTF-8 conversion errors, the set error domain is CONVERT_ERROR. If there's no content to read, it will still return <code>0</code>, but <em>error</em> won't be set. </dd></dl>

</div>
</div>
<a class="anchor" id="ad48b87d450f26683d167c74c7c224ceb"></a><!-- doxytag: member="Gio::DataInputStream::read_line_utf8" ref="ad48b87d450f26683d167c74c7c224ceb" args="(std::string &amp;line, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DataInputStream.html#ac779efdf33abb470832715abeb47f3ef">Gio::DataInputStream::read_line_utf8</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="classGio_1_1DataInputStream.html#ac779efdf33abb470832715abeb47f3ef" title="Reads a UTF-8 encoded line from the data input stream.">read_line_utf8()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="aa1ba4df39f51b81c6e105c71d5941493"></a><!-- doxytag: member="Gio::DataInputStream::read_line_utf8" ref="aa1ba4df39f51b81c6e105c71d5941493" args="(std::string &amp;line, gsize &amp;length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DataInputStream.html#ac779efdf33abb470832715abeb47f3ef">Gio::DataInputStream::read_line_utf8</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="classGio_1_1DataInputStream.html#ac779efdf33abb470832715abeb47f3ef" title="Reads a UTF-8 encoded line from the data input stream.">read_line_utf8()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a8cdccad3a356c1bc34bc9ec967b710b0"></a><!-- doxytag: member="Gio::DataInputStream::read_line_utf8" ref="a8cdccad3a356c1bc34bc9ec967b710b0" args="(std::string &amp;line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DataInputStream.html#ac779efdf33abb470832715abeb47f3ef">Gio::DataInputStream::read_line_utf8</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="classGio_1_1DataInputStream.html#ac779efdf33abb470832715abeb47f3ef" title="Reads a UTF-8 encoded line from the data input stream.">read_line_utf8()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a9ac667e423ec3c3d997fc2a4683956d3"></a><!-- doxytag: member="Gio::DataInputStream::read_uint16" ref="a9ac667e423ec3c3d997fc2a4683956d3" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint16 <a class="el" href="classGio_1_1DataInputStream.html#a9ac667e423ec3c3d997fc2a4683956d3">Gio::DataInputStream::read_uint16</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads an unsigned 16-bit/2-byte value from <em>stream</em>. </p>
<p>In order to get the correct byte order for this read operation, see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order(). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An unsigned 16-bit/2-byte value read from the <em>stream</em> or %0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e99722aa033a78ac2f4dc593b36d197"></a><!-- doxytag: member="Gio::DataInputStream::read_uint16" ref="a4e99722aa033a78ac2f4dc593b36d197" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint16 <a class="el" href="classGio_1_1DataInputStream.html#a9ac667e423ec3c3d997fc2a4683956d3">Gio::DataInputStream::read_uint16</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#a4e99722aa033a78ac2f4dc593b36d197" title="non-cancellable version of read_uint16()">read_uint16()</a> </p>

</div>
</div>
<a class="anchor" id="ae7d36dbd67425b923fe335ec5a3f4124"></a><!-- doxytag: member="Gio::DataInputStream::read_uint32" ref="ae7d36dbd67425b923fe335ec5a3f4124" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint32 <a class="el" href="classGio_1_1DataInputStream.html#ae7d36dbd67425b923fe335ec5a3f4124">Gio::DataInputStream::read_uint32</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads an unsigned 32-bit/4-byte value from <em>stream</em>. </p>
<p>In order to get the correct byte order for this read operation, see Glib::data_stream_get_byte_order() and Glib::data_stream_set_byte_order().</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An unsigned 32-bit/4-byte value read from the <em>stream</em> or %0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a587856139c73d6c2df1ad2c5560cffec"></a><!-- doxytag: member="Gio::DataInputStream::read_uint32" ref="a587856139c73d6c2df1ad2c5560cffec" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint32 <a class="el" href="classGio_1_1DataInputStream.html#ae7d36dbd67425b923fe335ec5a3f4124">Gio::DataInputStream::read_uint32</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#a587856139c73d6c2df1ad2c5560cffec" title="non-cancellable version of read_uint32()">read_uint32()</a> </p>

</div>
</div>
<a class="anchor" id="a2e486863876f833e910286300c7e17a4"></a><!-- doxytag: member="Gio::DataInputStream::read_uint64" ref="a2e486863876f833e910286300c7e17a4" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint64 <a class="el" href="classGio_1_1DataInputStream.html#a2e486863876f833e910286300c7e17a4">Gio::DataInputStream::read_uint64</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads an unsigned 64-bit/8-byte value from <em>stream</em>. </p>
<p>In order to get the correct byte order for this read operation, see Glib::data_stream_get_byte_order().</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An unsigned 64-bit/8-byte read from <em>stream</em> or %0 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c7ed7807b2a8370f879a820dd0c7989"></a><!-- doxytag: member="Gio::DataInputStream::read_uint64" ref="a9c7ed7807b2a8370f879a820dd0c7989" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint64 <a class="el" href="classGio_1_1DataInputStream.html#a2e486863876f833e910286300c7e17a4">Gio::DataInputStream::read_uint64</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#a9c7ed7807b2a8370f879a820dd0c7989" title="non-cancellable version of read_uint64()">read_uint64()</a> </p>

</div>
</div>
<a class="anchor" id="a058c5367f9be4e4e36d5fb9de2201815"></a><!-- doxytag: member="Gio::DataInputStream::read_until" ref="a058c5367f9be4e4e36d5fb9de2201815" args="(std::string &amp;data, const std::string &amp;stop_chars, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DataInputStream.html#a058c5367f9be4e4e36d5fb9de2201815">Gio::DataInputStream::read_until</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>stop_chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a string from the data input stream, up to the first occurrence of any of the stop characters. </p>
<p>Note that, in contrast to <a class="el" href="classGio_1_1DataInputStream.html#a708cba487c68c8c927fe8ae6277b6123" title="The asynchronous version of read_until().">read_until_async()</a>, this function consumes the stop character that it finds.</p>
<p>Don't use this function in new code. Its functionality is inconsistent with <a class="el" href="classGio_1_1DataInputStream.html#a708cba487c68c8c927fe8ae6277b6123" title="The asynchronous version of read_until().">read_until_async()</a>. Both functions will be marked as deprecated in a future release. Use <a class="el" href="classGio_1_1DataInputStream.html#ae1ecebe6229884c4510e5b42eabe4874" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_upto()</a> instead, but note that that method does not consume the stop character.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A string to fill with the read data. </td></tr>
    <tr><td class="paramname">stop_chars</td><td>Characters to terminate the read. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A cancellable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the read succeeded without error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7d2a04bf5a4628df0530ec40d4c33cf"></a><!-- doxytag: member="Gio::DataInputStream::read_until" ref="aa7d2a04bf5a4628df0530ec40d4c33cf" args="(std::string &amp;data, const std::string &amp;stop_chars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DataInputStream.html#a058c5367f9be4e4e36d5fb9de2201815">Gio::DataInputStream::read_until</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>stop_chars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#a058c5367f9be4e4e36d5fb9de2201815" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_until()</a>. </p>
<p>Note that, in contrast to <a class="el" href="classGio_1_1DataInputStream.html#a708cba487c68c8c927fe8ae6277b6123" title="The asynchronous version of read_until().">read_until_async()</a>, this function consumes the stop character that it finds.</p>
<p>Don't use this function in new code. Its functionality is inconsistent with <a class="el" href="classGio_1_1DataInputStream.html#a708cba487c68c8c927fe8ae6277b6123" title="The asynchronous version of read_until().">read_until_async()</a>. Both functions will be marked as deprecated in a future release. Use <a class="el" href="classGio_1_1DataInputStream.html#ae1ecebe6229884c4510e5b42eabe4874" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_upto()</a> instead, but note that that method does not consume the stop character.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_chars</td><td>Characters to terminate the read. </td></tr>
    <tr><td class="paramname">data</td><td>A string to fill with the read data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the read succeeded without error. </dd></dl>

</div>
</div>
<a class="anchor" id="a708cba487c68c8c927fe8ae6277b6123"></a><!-- doxytag: member="Gio::DataInputStream::read_until_async" ref="a708cba487c68c8c927fe8ae6277b6123" args="(const std::string &amp;stop_chars, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DataInputStream.html#a708cba487c68c8c927fe8ae6277b6123">Gio::DataInputStream::read_until_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>stop_chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The asynchronous version of <a class="el" href="classGio_1_1DataInputStream.html#a058c5367f9be4e4e36d5fb9de2201815" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_until()</a>. </p>
<p>It is an error to have two outstanding calls to this function.</p>
<p>Note that, in contrast to ead_until(), this function does not consume the stop character that it finds. You must read it for yourself.</p>
<p>Don't use this function in new code. Its functionality is inconsistent with <a class="el" href="classGio_1_1DataInputStream.html#a058c5367f9be4e4e36d5fb9de2201815" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_until()</a>. Both functions will be marked as deprecated in a future release. Use <a class="el" href="classGio_1_1DataInputStream.html#a76d195879b8aa04c22a5c69dc82c0f46" title="The asynchronous version of read_upto().">read_upto_async()</a> instead.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_chars</td><td>Characters to terminate the read. </td></tr>
    <tr><td class="paramname">slot</td><td>The slot to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A cancellable object. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the read succeeded without error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa851cb398896f39bea56868b46bd480d"></a><!-- doxytag: member="Gio::DataInputStream::read_until_finish" ref="aa851cb398896f39bea56868b46bd480d" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, std::string &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DataInputStream.html#aa851cb398896f39bea56868b46bd480d">Gio::DataInputStream::read_until_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish an asynchronous call started by <a class="el" href="classGio_1_1DataInputStream.html#a708cba487c68c8c927fe8ae6277b6123" title="The asynchronous version of read_until().">read_until_async()</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> that was provided to the callback slot. </td></tr>
    <tr><td class="paramname">data</td><td>A string to fill with the read data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the read succeeded without error. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1ecebe6229884c4510e5b42eabe4874"></a><!-- doxytag: member="Gio::DataInputStream::read_upto" ref="ae1ecebe6229884c4510e5b42eabe4874" args="(std::string &amp;data, const std::string &amp;stop_chars, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DataInputStream.html#ae1ecebe6229884c4510e5b42eabe4874">Gio::DataInputStream::read_upto</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>stop_chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a string from the data input stream, up to the first occurrence of any of the stop characters. </p>
<p>In contrast to <a class="el" href="classGio_1_1DataInputStream.html#a058c5367f9be4e4e36d5fb9de2201815" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_until()</a>, this method does &lt;emphasis&gt;not&lt;/emphasis&gt; consume the stop character. You have to use <a class="el" href="classGio_1_1DataInputStream.html#af4d01aa4e791d403b79db406befcc28e" title="non-cancellable version of read_byte()">read_byte()</a> to get it before calling <a class="el" href="classGio_1_1DataInputStream.html#ae1ecebe6229884c4510e5b42eabe4874" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_upto()</a> again.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A string to fill with the read data. </td></tr>
    <tr><td class="paramname">stop_chars</td><td>Characters to terminate the read. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A cancellable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the read succeeded without error. </dd></dl>

</div>
</div>
<a class="anchor" id="afe582f97c8438b1517f16e805e332d1f"></a><!-- doxytag: member="Gio::DataInputStream::read_upto" ref="afe582f97c8438b1517f16e805e332d1f" args="(std::string &amp;data, const std::string &amp;stop_chars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DataInputStream.html#ae1ecebe6229884c4510e5b42eabe4874">Gio::DataInputStream::read_upto</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>stop_chars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A non-cancellable version of <a class="el" href="classGio_1_1DataInputStream.html#ae1ecebe6229884c4510e5b42eabe4874" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_upto()</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_chars</td><td>Characters to terminate the read. </td></tr>
    <tr><td class="paramname">data</td><td>A string to fill with the read data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the read succeeded without error. </dd></dl>

</div>
</div>
<a class="anchor" id="a76d195879b8aa04c22a5c69dc82c0f46"></a><!-- doxytag: member="Gio::DataInputStream::read_upto_async" ref="a76d195879b8aa04c22a5c69dc82c0f46" args="(const std::string &amp;stop_chars, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DataInputStream.html#a76d195879b8aa04c22a5c69dc82c0f46">Gio::DataInputStream::read_upto_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>stop_chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The asynchronous version of <a class="el" href="classGio_1_1DataInputStream.html#ae1ecebe6229884c4510e5b42eabe4874" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_upto()</a>. </p>
<p>It is an error to have two outstanding calls to this function.</p>
<p>In contrast to <a class="el" href="classGio_1_1DataInputStream.html#a058c5367f9be4e4e36d5fb9de2201815" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_until()</a>, this method does &lt;emphasis&gt;not&lt;/emphasis&gt; consume the stop character. You have to use <a class="el" href="classGio_1_1DataInputStream.html#af4d01aa4e791d403b79db406befcc28e" title="non-cancellable version of read_byte()">read_byte()</a> to get it before calling <a class="el" href="classGio_1_1DataInputStream.html#ae1ecebe6229884c4510e5b42eabe4874" title="Reads a string from the data input stream, up to the first occurrence of any of the stop characters...">read_upto()</a> again.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_chars</td><td>Characters to terminate the read. </td></tr>
    <tr><td class="paramname">slot</td><td>The slot to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A cancellable object. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the read succeeded without error. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0b61e9b6225bea6af433ae28dbdbea8"></a><!-- doxytag: member="Gio::DataInputStream::read_upto_finish" ref="ad0b61e9b6225bea6af433ae28dbdbea8" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result, std::string &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGio_1_1DataInputStream.html#ad0b61e9b6225bea6af433ae28dbdbea8">Gio::DataInputStream::read_upto_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01639.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish an asynchronous call started by <a class="el" href="classGio_1_1DataInputStream.html#a76d195879b8aa04c22a5c69dc82c0f46" title="The asynchronous version of read_upto().">read_upto_async()</a>. </p>
<p>Note that this function does &lt;emphasis&gt;not&lt;/emphasis&gt; consume the stop character. You have to use <a class="el" href="classGio_1_1DataInputStream.html#af4d01aa4e791d403b79db406befcc28e" title="non-cancellable version of read_byte()">read_byte()</a> to get it before calling <a class="el" href="classGio_1_1DataInputStream.html#a76d195879b8aa04c22a5c69dc82c0f46" title="The asynchronous version of read_upto().">read_upto_async()</a> again.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> that was provided to the callback slot. </td></tr>
    <tr><td class="paramname">data</td><td>A string to fill with the read data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the read succeeded without error. </dd></dl>

</div>
</div>
<a class="anchor" id="a032c20df06b83828d3cb5e81f6b8f561"></a><!-- doxytag: member="Gio::DataInputStream::set_byte_order" ref="a032c20df06b83828d3cb5e81f6b8f561" args="(DataStreamByteOrder order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DataInputStream.html#a032c20df06b83828d3cb5e81f6b8f561">Gio::DataInputStream::set_byte_order</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga87dea9b56fed9c0bca0f8426fb57781e">DataStreamByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function sets the byte order for the given <em>stream</em>. </p>
<p>All subsequent reads from the <em>stream</em> will be read in the given <em>order</em>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>A DataStreamByteOrder to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbc8ad1476fd82e808234a661bfe4cd3"></a><!-- doxytag: member="Gio::DataInputStream::set_newline_type" ref="afbc8ad1476fd82e808234a661bfe4cd3" args="(DataStreamNewlineType type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1DataInputStream.html#afbc8ad1476fd82e808234a661bfe4cd3">Gio::DataInputStream::set_newline_type</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2de111fe308aff763fb98a39bc507267">DataStreamNewlineType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the newline type for the <em>stream</em>. </p>
<p>Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read chunk ends in "CR" we must read an additional byte to know if this is "CR" or "CR LF", and this might block if there is no more data available. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of new line return as DataStreamNewlineType. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a88853a1864df25dc8dda900a6ad52266"></a><!-- doxytag: member="Gio::DataInputStream::wrap" ref="a88853a1864df25dc8dda900a6ad52266" args="(GDataInputStream *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1DataInputStream.html">Gio::DataInputStream</a> &gt; <a class="el" href="classGio_1_1DataInputStream.html#a88853a1864df25dc8dda900a6ad52266">wrap</a> </td>
          <td>(</td>
          <td class="paramtype">GDataInputStream *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 10 2012 14:20:37 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
