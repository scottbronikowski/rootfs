<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>glibmm: Gio::Resolver Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="/home/murrayc/checkouts/gnome30/glibmm/docs/doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.32.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceGio.html">Gio</a> </li>
      <li class="navelem"><a class="el" href="classGio_1_1Resolver.html">Resolver</a> </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> </div>
  <div class="headertitle">
<div class="title">Gio::Resolver Class Reference<div class="ingroups"><a class="el" href="group__NetworkIO.html">Portable Network I/O Functionality</a></div></div> </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Gio::Resolver" --><!-- doxytag: inherits="Glib::Object" -->
<p>Asynchronous and cancellable DNS resolver.  <a href="classGio_1_1Resolver.html#details">More...</a></p>

<p><code>#include &lt;giomm/resolver.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gio::Resolver:</div>
<div class="dyncontent">
<div class="center"><img src="classGio_1_1Resolver__inherit__graph.png" border="0" usemap="#Gio_1_1Resolver_inherit__map" alt="Inheritance graph"/></div>
<map name="Gio_1_1Resolver_inherit__map" id="Gio_1_1Resolver_inherit__map">
<area shape="rect" id="node2" href="classGlib_1_1Object.html" title="Glib::Object" alt="" coords="21,160,115,189"/><area shape="rect" id="node4" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="5,83,131,112"/><area shape="rect" id="node6" href="../../../libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="11,5,125,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGio_1_1Resolver-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a91fb01b808b2e2d315d9ffc149f1f71e">~Resolver</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GResolver*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a4d323772493d0cf739816c80f08398d2">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a4d323772493d0cf739816c80f08398d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GResolver*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a77d572cc0c4a48c47ec06e9a5f2d02a9">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a77d572cc0c4a48c47ec06e9a5f2d02a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GResolver*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#ae1cf170f1700985b286238d5f1dcbab2">gobj_copy</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. <a href="#ae1cf170f1700985b286238d5f1dcbab2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ListHandle.html">Glib::ListHandle</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#aea1576fa2684d9bca58a589098a8371e">lookup_by_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; hostname, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously resolves <em>hostname</em> to determine its associated IP address(es). <a href="#aea1576fa2684d9bca58a589098a8371e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ListHandle.html">Glib::ListHandle</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a4aaf18d0bcc67d6d139d993b140a8b14">lookup_by_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; hostname)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously resolves hostname to determine its associated IP address(es). <a href="#a4aaf18d0bcc67d6d139d993b140a8b14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a0130482bb442e3a006e06d57665c2318">lookup_by_name_async</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; hostname, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins asynchronously resolving hostname to determine its associated IP address(es), and eventually calls <em>slot</em>, which must call <a class="el" href="classGio_1_1Resolver.html#afaf6f9f003fd213ebecb893d60f14380" title="Retrieves the result of a call to g_resolver_lookup_by_name_async().">lookup_by_name_finish()</a> to get the result. <a href="#a0130482bb442e3a006e06d57665c2318"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#ae38a0fc714443839c0bb3a0e40dcd082">lookup_by_name_async</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; hostname, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins asynchronously resolving hostname to determine its associated IP address(es), and eventually calls <em>slot</em>, which must call <a class="el" href="classGio_1_1Resolver.html#afaf6f9f003fd213ebecb893d60f14380" title="Retrieves the result of a call to g_resolver_lookup_by_name_async().">lookup_by_name_finish()</a> to get the result. <a href="#ae38a0fc714443839c0bb3a0e40dcd082"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ListHandle.html">Glib::ListHandle</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#afaf6f9f003fd213ebecb893d60f14380">lookup_by_name_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the result of a call to g_resolver_lookup_by_name_async(). <a href="#afaf6f9f003fd213ebecb893d60f14380"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#abb5740225148191d2e93d7a6b12caf23">lookup_by_address</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; address, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously reverse-resolves <em>address</em> to determine its associated hostname. <a href="#abb5740225148191d2e93d7a6b12caf23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a81f793a31c8ddaa2bf26361721c3fd1c">lookup_by_address</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously reverse-resolves an address to determine its associated hostname. <a href="#a81f793a31c8ddaa2bf26361721c3fd1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a3bfd36d312e60b748df35089d5126b4f">lookup_by_address_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; address, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins asynchronously reverse-resolving an address to determine its associated hostname, and eventually calls callback, which must call <a class="el" href="classGio_1_1Resolver.html#ae127e4682bfb20ef0b292e7b98460762" title="Retrieves the result of a previous call to g_resolver_lookup_by_address_async().">lookup_by_address_finish()</a> to get the final result. <a href="#a3bfd36d312e60b748df35089d5126b4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a91d05a43f8083af54826fcb3303e0eba">lookup_by_address_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; address, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins asynchronously reverse-resolving an address to determine its associated hostname, and eventually calls callback, which must call <a class="el" href="classGio_1_1Resolver.html#ae127e4682bfb20ef0b292e7b98460762" title="Retrieves the result of a previous call to g_resolver_lookup_by_address_async().">lookup_by_address_finish()</a> to get the final result. <a href="#a91d05a43f8083af54826fcb3303e0eba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#ae127e4682bfb20ef0b292e7b98460762">lookup_by_address_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the result of a previous call to g_resolver_lookup_by_address_async(). <a href="#ae127e4682bfb20ef0b292e7b98460762"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGio.html#a1b4ed5afd24e359d3ba6bde02c9e90be">ListHandle_SrvTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#aab5e246c4f14e55e079c8a280dd3de5b">lookup_service</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; service, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; protocol, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; domain, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously performs a DNS SRV lookup for the given <em>service</em> and <em>protocol</em> in the given <em>domain</em> and returns an array of <a class="el" href="classGio_1_1SrvTarget.html" title="DNS SRV record target.">SrvTarget</a>. <a href="#aab5e246c4f14e55e079c8a280dd3de5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGio.html#a1b4ed5afd24e359d3ba6bde02c9e90be">ListHandle_SrvTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a3b131a66a7a7bd3e89713384ff2f6be3">lookup_service</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; service, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; protocol, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; domain)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously performs a DNS SRV lookup for the given service and protocol in the given domain and returns an list of SrvTargets. <a href="#a3b131a66a7a7bd3e89713384ff2f6be3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a49d103c02f6e0e8ad5d4e7abb1967ef0">lookup_service_async</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; service, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; protocol, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; domain, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins asynchronously performing a DNS SRV lookup for the given service and protocol in the given domain, and eventually calls callback, which must call <a class="el" href="classGio_1_1Resolver.html#aae68cb39415c9286474d92c7aeba2e47" title="Retrieves the result of a previous call to g_resolver_lookup_service_async().">lookup_service_finish()</a> to get the final result. <a href="#a49d103c02f6e0e8ad5d4e7abb1967ef0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a58d46752ddd5305d811df4707c3ce4a7">lookup_service_async</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; service, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; protocol, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; domain, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins asynchronously performing a DNS SRV lookup for the given service and protocol in the given domain, and eventually calls callback, which must call <a class="el" href="classGio_1_1Resolver.html#aae68cb39415c9286474d92c7aeba2e47" title="Retrieves the result of a previous call to g_resolver_lookup_service_async().">lookup_service_finish()</a> to get the final result. <a href="#a58d46752ddd5305d811df4707c3ce4a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGio.html#a1b4ed5afd24e359d3ba6bde02c9e90be">ListHandle_SrvTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#aae68cb39415c9286474d92c7aeba2e47">lookup_service_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the result of a previous call to g_resolver_lookup_service_async(). <a href="#aae68cb39415c9286474d92c7aeba2e47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1SignalProxy0.html">Glib::SignalProxy0</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#a097abf4f88816a46fa2272430a1b5e3d">signal_reload</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Resolver.html">Resolver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#ac822ffe60ab0ce2acfdc85ccb908f6fc">get_default</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#afbb1fb4f9edb0e553dbb61ca2437601c">set_default</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Resolver.html">Resolver</a> &gt;&amp; resolver)</td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Resolver.html">Gio::Resolver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Resolver.html#aa710fc39dacfe0e34730487741d84fb9">wrap</a> (GResolver* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#aa710fc39dacfe0e34730487741d84fb9"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Asynchronous and cancellable DNS resolver. </p>
<p><a class="el" href="classGio_1_1Resolver.html" title="Asynchronous and cancellable DNS resolver.">Resolver</a> provides cancellable synchronous and asynchronous DNS resolution, for hostnames (<a class="el" href="classGio_1_1Resolver.html#abb5740225148191d2e93d7a6b12caf23" title="Synchronously reverse-resolves address to determine its associated hostname.">lookup_by_address()</a>, <a class="el" href="classGio_1_1Resolver.html#aea1576fa2684d9bca58a589098a8371e" title="Synchronously resolves hostname to determine its associated IP address(es).">lookup_by_name()</a> and their async variants) and SRV (service) records (<a class="el" href="classGio_1_1Resolver.html#aab5e246c4f14e55e079c8a280dd3de5b" title="Synchronously performs a DNS SRV lookup for the given service and protocol in the given domain and re...">lookup_service()</a>).</p>
<p><a class="el" href="classGio_1_1NetworkAddress.html" title="A SocketConnectable for resolving hostnames.">NetworkAddress</a> and <a class="el" href="classGio_1_1NetworkService.html" title="A GSocketConnectable for resolving SRV records.">NetworkService</a> provide wrappers around <a class="el" href="classGio_1_1Resolver.html" title="Asynchronous and cancellable DNS resolver.">Resolver</a> functionality that also implement <a class="el" href="classGio_1_1SocketConnectable.html" title="Interface for potential socket endpoints.">SocketConnectable</a>, making it easy to connect to a remote host/service.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000028">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a91fb01b808b2e2d315d9ffc149f1f71e"></a><!-- doxytag: member="Gio::Resolver::~Resolver" ref="a91fb01b808b2e2d315d9ffc149f1f71e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGio_1_1Resolver.html#a91fb01b808b2e2d315d9ffc149f1f71e">Gio::Resolver::~Resolver</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac822ffe60ab0ce2acfdc85ccb908f6fc"></a><!-- doxytag: member="Gio::Resolver::get_default" ref="ac822ffe60ab0ce2acfdc85ccb908f6fc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Resolver.html">Resolver</a>&gt; <a class="el" href="classGio_1_1Resolver.html#ac822ffe60ab0ce2acfdc85ccb908f6fc">Gio::Resolver::get_default</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d323772493d0cf739816c80f08398d2"></a><!-- doxytag: member="Gio::Resolver::gobj" ref="a4d323772493d0cf739816c80f08398d2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GResolver* <a class="el" href="classGio_1_1Resolver.html#a4d323772493d0cf739816c80f08398d2">Gio::Resolver::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#a4c6efc18be8cb9c56e58fc0bd20fafbe">Glib::ObjectBase</a>.</p>

</div>
</div>
<a class="anchor" id="a77d572cc0c4a48c47ec06e9a5f2d02a9"></a><!-- doxytag: member="Gio::Resolver::gobj" ref="a77d572cc0c4a48c47ec06e9a5f2d02a9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GResolver* <a class="el" href="classGio_1_1Resolver.html#a4d323772493d0cf739816c80f08398d2">Gio::Resolver::gobj</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#a778a94181132976bbfb0519793f3b32e">Glib::ObjectBase</a>.</p>

</div>
</div>
<a class="anchor" id="ae1cf170f1700985b286238d5f1dcbab2"></a><!-- doxytag: member="Gio::Resolver::gobj_copy" ref="ae1cf170f1700985b286238d5f1dcbab2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GResolver* <a class="el" href="classGio_1_1Resolver.html#ae1cf170f1700985b286238d5f1dcbab2">Gio::Resolver::gobj_copy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a class="anchor" id="abb5740225148191d2e93d7a6b12caf23"></a><!-- doxytag: member="Gio::Resolver::lookup_by_address" ref="abb5740225148191d2e93d7a6b12caf23" args="(const Glib::RefPtr&lt; InetAddress &gt; &amp;address, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> <a class="el" href="classGio_1_1Resolver.html#abb5740225148191d2e93d7a6b12caf23">Gio::Resolver::lookup_by_address</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously reverse-resolves <em>address</em> to determine its associated hostname. </p>
<p>If the DNS resolution fails, <em>error</em> (if non-<code>0</code>) will be set to a value from <a class="el" href="classGio_1_1ResolverError.html">ResolverError</a>.</p>
<p>If <em>cancellable</em> is non-<code>0</code>, it can be used to cancel the operation, in which case <em>error</em> (if non-<code>0</code>) will be set to IO_ERROR_CANCELLED.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000079">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address to reverse-resolve. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A hostname (either ASCII-only, or in ASCII-encoded form), or <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a81f793a31c8ddaa2bf26361721c3fd1c"></a><!-- doxytag: member="Gio::Resolver::lookup_by_address" ref="a81f793a31c8ddaa2bf26361721c3fd1c" args="(const Glib::RefPtr&lt; InetAddress &gt; &amp;address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> <a class="el" href="classGio_1_1Resolver.html#abb5740225148191d2e93d7a6b12caf23">Gio::Resolver::lookup_by_address</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously reverse-resolves an address to determine its associated hostname. </p>
<p>If the DNS resolution fails then a <a class="el" href="classGio_1_1ResolverError.html">ResolverError</a> exception will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address to reverse-resolve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A hostname (either ASCII-only, or in ASCII-encoded form), or an empty string on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bfd36d312e60b748df35089d5126b4f"></a><!-- doxytag: member="Gio::Resolver::lookup_by_address_async" ref="a3bfd36d312e60b748df35089d5126b4f" args="(const Glib::RefPtr&lt; InetAddress &gt; &amp;address, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Resolver.html#a3bfd36d312e60b748df35089d5126b4f">Gio::Resolver::lookup_by_address_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begins asynchronously reverse-resolving an address to determine its associated hostname, and eventually calls callback, which must call <a class="el" href="classGio_1_1Resolver.html#ae127e4682bfb20ef0b292e7b98460762" title="Retrieves the result of a previous call to g_resolver_lookup_by_address_async().">lookup_by_address_finish()</a> to get the final result. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address to reverse-resolve. </td></tr>
    <tr><td class="paramname">hostname</td><td>hostname The hostname to look up. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot to call after the resolution completes. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91d05a43f8083af54826fcb3303e0eba"></a><!-- doxytag: member="Gio::Resolver::lookup_by_address_async" ref="a91d05a43f8083af54826fcb3303e0eba" args="(const Glib::RefPtr&lt; InetAddress &gt; &amp;address, const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Resolver.html#a3bfd36d312e60b748df35089d5126b4f">Gio::Resolver::lookup_by_address_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begins asynchronously reverse-resolving an address to determine its associated hostname, and eventually calls callback, which must call <a class="el" href="classGio_1_1Resolver.html#ae127e4682bfb20ef0b292e7b98460762" title="Retrieves the result of a previous call to g_resolver_lookup_by_address_async().">lookup_by_address_finish()</a> to get the final result. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address to reverse-resolve. </td></tr>
    <tr><td class="paramname">hostname</td><td>hostname The hostname to look up. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot to call after the resolution completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae127e4682bfb20ef0b292e7b98460762"></a><!-- doxytag: member="Gio::Resolver::lookup_by_address_finish" ref="ae127e4682bfb20ef0b292e7b98460762" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> <a class="el" href="classGio_1_1Resolver.html#ae127e4682bfb20ef0b292e7b98460762">Gio::Resolver::lookup_by_address_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the result of a previous call to g_resolver_lookup_by_address_async(). </p>
<p>If the DNS resolution failed, <em>error</em> (if non-<code>0</code>) will be set to a value from <a class="el" href="classGio_1_1ResolverError.html">ResolverError</a>. If the operation was cancelled, <em>error</em> will be set to IO_ERROR_CANCELLED.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000080">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The result passed to your AsyncReadyCallback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A hostname (either ASCII-only, or in ASCII-encoded form), or <code>0</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="aea1576fa2684d9bca58a589098a8371e"></a><!-- doxytag: member="Gio::Resolver::lookup_by_name" ref="aea1576fa2684d9bca58a589098a8371e" args="(const Glib::ustring &amp;hostname, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ListHandle.html">Glib::ListHandle</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1InetAddress.html">InetAddress</a>&gt; &gt; <a class="el" href="classGio_1_1Resolver.html#aea1576fa2684d9bca58a589098a8371e">Gio::Resolver::lookup_by_name</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously resolves <em>hostname</em> to determine its associated IP address(es). </p>
<p><em>hostname</em> may be an ASCII-only or UTF-8 hostname, or the textual form of an IP address (in which case this just becomes a wrapper around g_inet_address_new_from_string()).</p>
<p>On success, g_resolver_lookup_by_name() will return a List of <a class="el" href="classGio_1_1InetAddress.html" title="An IPv4/IPv6 address.">InetAddress</a>, sorted in order of preference and guaranteed to not contain duplicates. That is, if using the result to connect to <em>hostname</em>, you should attempt to connect to the first address first, then the second if the first fails, etc. If you are using the result to listen on a socket, it is appropriate to add each result using e.g. g_socket_listener_add_address().</p>
<p>If the DNS resolution fails, <em>error</em> (if non-<code>0</code>) will be set to a value from <a class="el" href="classGio_1_1ResolverError.html">ResolverError</a>.</p>
<p>If <em>cancellable</em> is non-<code>0</code>, it can be used to cancel the operation, in which case <em>error</em> (if non-<code>0</code>) will be set to IO_ERROR_CANCELLED.</p>
<p>If you are planning to connect to a socket on the resolved IP address, it may be easier to create a <a class="el" href="classGio_1_1NetworkAddress.html" title="A SocketConnectable for resolving hostnames.">NetworkAddress</a> and use its <a class="el" href="classGio_1_1SocketConnectable.html" title="Interface for potential socket endpoints.">SocketConnectable</a> interface.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000077">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>The hostname to look up. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A List of <a class="el" href="classGio_1_1InetAddress.html" title="An IPv4/IPv6 address.">InetAddress</a>, or <code>0</code> on error. You must unref each of the addresses and free the list when you are done with it. (You can use g_resolver_free_addresses() to do this.). </dd></dl>

</div>
</div>
<a class="anchor" id="a4aaf18d0bcc67d6d139d993b140a8b14"></a><!-- doxytag: member="Gio::Resolver::lookup_by_name" ref="a4aaf18d0bcc67d6d139d993b140a8b14" args="(const Glib::ustring &amp;hostname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ListHandle.html">Glib::ListHandle</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1InetAddress.html">InetAddress</a>&gt; &gt; <a class="el" href="classGio_1_1Resolver.html#aea1576fa2684d9bca58a589098a8371e">Gio::Resolver::lookup_by_name</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>hostname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously resolves hostname to determine its associated IP address(es). </p>
<p><em>hostname</em> may be an ASCII-only or UTF-8 hostname, or the textual form of an IP address (in which case this just becomes a wrapper around <a class="el" href="classGio_1_1InetAddress.html" title="An IPv4/IPv6 address.">InetAddress</a>:create_from_string()).</p>
<p>On success, this will return a list of <a class="el" href="classGio_1_1InetAddress.html" title="An IPv4/IPv6 address.">InetAddress</a>, sorted in order of preference. (That is, you should attempt to connect to the first address first, then the second if the first fails, etc.)</p>
<p>If the DNS resolution fails, a <a class="el" href="classGio_1_1ResolverError.html">ResolverError</a> exception will be thrown.</p>
<p>If you are planning to connect to a socket on the resolved IP address, it may be easier to create a <a class="el" href="classGio_1_1NetworkAddress.html" title="A SocketConnectable for resolving hostnames.">NetworkAddress</a> and use its <a class="el" href="classGio_1_1SocketConnectable.html" title="Interface for potential socket endpoints.">SocketConnectable</a> base class.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>hostname The hostname to look up. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0130482bb442e3a006e06d57665c2318"></a><!-- doxytag: member="Gio::Resolver::lookup_by_name_async" ref="a0130482bb442e3a006e06d57665c2318" args="(const Glib::ustring &amp;hostname, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Resolver.html#a0130482bb442e3a006e06d57665c2318">Gio::Resolver::lookup_by_name_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begins asynchronously resolving hostname to determine its associated IP address(es), and eventually calls <em>slot</em>, which must call <a class="el" href="classGio_1_1Resolver.html#afaf6f9f003fd213ebecb893d60f14380" title="Retrieves the result of a call to g_resolver_lookup_by_name_async().">lookup_by_name_finish()</a> to get the result. </p>
<p>See <a class="el" href="classGio_1_1Resolver.html#aea1576fa2684d9bca58a589098a8371e" title="Synchronously resolves hostname to determine its associated IP address(es).">lookup_by_name()</a> for more details.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>hostname The hostname to look up. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot to call after the resolution completes. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae38a0fc714443839c0bb3a0e40dcd082"></a><!-- doxytag: member="Gio::Resolver::lookup_by_name_async" ref="ae38a0fc714443839c0bb3a0e40dcd082" args="(const Glib::ustring &amp;hostname, const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Resolver.html#a0130482bb442e3a006e06d57665c2318">Gio::Resolver::lookup_by_name_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begins asynchronously resolving hostname to determine its associated IP address(es), and eventually calls <em>slot</em>, which must call <a class="el" href="classGio_1_1Resolver.html#afaf6f9f003fd213ebecb893d60f14380" title="Retrieves the result of a call to g_resolver_lookup_by_name_async().">lookup_by_name_finish()</a> to get the result. </p>
<p>See <a class="el" href="classGio_1_1Resolver.html#aea1576fa2684d9bca58a589098a8371e" title="Synchronously resolves hostname to determine its associated IP address(es).">lookup_by_name()</a> for more details.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>hostname The hostname to look up. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot to call after the resolution completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afaf6f9f003fd213ebecb893d60f14380"></a><!-- doxytag: member="Gio::Resolver::lookup_by_name_finish" ref="afaf6f9f003fd213ebecb893d60f14380" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ListHandle.html">Glib::ListHandle</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1InetAddress.html">InetAddress</a>&gt; &gt; <a class="el" href="classGio_1_1Resolver.html#afaf6f9f003fd213ebecb893d60f14380">Gio::Resolver::lookup_by_name_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the result of a call to g_resolver_lookup_by_name_async(). </p>
<p>If the DNS resolution failed, <em>error</em> (if non-<code>0</code>) will be set to a value from <a class="el" href="classGio_1_1ResolverError.html">ResolverError</a>. If the operation was cancelled, <em>error</em> will be set to IO_ERROR_CANCELLED.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000078">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The result passed to your AsyncReadyCallback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A List of <a class="el" href="classGio_1_1InetAddress.html" title="An IPv4/IPv6 address.">InetAddress</a>, or <code>0</code> on error. See g_resolver_lookup_by_name() for more details. </dd></dl>

</div>
</div>
<a class="anchor" id="aab5e246c4f14e55e079c8a280dd3de5b"></a><!-- doxytag: member="Gio::Resolver::lookup_service" ref="aab5e246c4f14e55e079c8a280dd3de5b" args="(const Glib::ustring &amp;service, const Glib::ustring &amp;protocol, const Glib::ustring &amp;domain, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGio.html#a1b4ed5afd24e359d3ba6bde02c9e90be">ListHandle_SrvTarget</a> <a class="el" href="classGio_1_1Resolver.html#aab5e246c4f14e55e079c8a280dd3de5b">Gio::Resolver::lookup_service</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously performs a DNS SRV lookup for the given <em>service</em> and <em>protocol</em> in the given <em>domain</em> and returns an array of <a class="el" href="classGio_1_1SrvTarget.html" title="DNS SRV record target.">SrvTarget</a>. </p>
<p><em>domain</em> may be an ASCII-only or UTF-8 hostname. Note also that the <em>service</em> and <em>protocol</em> arguments <em>do not</em> include the leading underscore that appears in the actual DNS entry.</p>
<p>On success, g_resolver_lookup_service() will return a List of <a class="el" href="classGio_1_1SrvTarget.html" title="DNS SRV record target.">SrvTarget</a>, sorted in order of preference. (That is, you should attempt to connect to the first target first, then the second if the first fails, etc.)</p>
<p>If the DNS resolution fails, <em>error</em> (if non-<code>0</code>) will be set to a value from <a class="el" href="classGio_1_1ResolverError.html">ResolverError</a>.</p>
<p>If <em>cancellable</em> is non-<code>0</code>, it can be used to cancel the operation, in which case <em>error</em> (if non-<code>0</code>) will be set to IO_ERROR_CANCELLED.</p>
<p>If you are planning to connect to the service, it is usually easier to create a <a class="el" href="classGio_1_1NetworkService.html" title="A GSocketConnectable for resolving SRV records.">NetworkService</a> and use its <a class="el" href="classGio_1_1SocketConnectable.html" title="Interface for potential socket endpoints.">SocketConnectable</a> interface.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000081">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td>The service type to look up (eg, "ldap"). </td></tr>
    <tr><td class="paramname">protocol</td><td>The networking protocol to use for <em>service</em> (eg, "tcp"). </td></tr>
    <tr><td class="paramname">domain</td><td>The DNS domain to look up the service in. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A List of <a class="el" href="classGio_1_1SrvTarget.html" title="DNS SRV record target.">SrvTarget</a>, or <code>0</code> on error. You must free each of the targets and the list when you are done with it. (You can use g_resolver_free_targets() to do this.). </dd></dl>

</div>
</div>
<a class="anchor" id="a3b131a66a7a7bd3e89713384ff2f6be3"></a><!-- doxytag: member="Gio::Resolver::lookup_service" ref="a3b131a66a7a7bd3e89713384ff2f6be3" args="(const Glib::ustring &amp;service, const Glib::ustring &amp;protocol, const Glib::ustring &amp;domain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGio.html#a1b4ed5afd24e359d3ba6bde02c9e90be">ListHandle_SrvTarget</a> <a class="el" href="classGio_1_1Resolver.html#aab5e246c4f14e55e079c8a280dd3de5b">Gio::Resolver::lookup_service</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronously performs a DNS SRV lookup for the given service and protocol in the given domain and returns an list of SrvTargets. </p>
<p><em>domain</em> may be an ASCII-only or UTF-8 hostname. Note also that the service and protocol arguments do not include the leading underscore that appears in the actual DNS entry.</p>
<p>On success, this will return a list of SrvTargets, sorted in order of preference. (That is, you should attempt to connect to the first target first, then the second if the first fails, etc.)</p>
<p>If the DNS resolution fails a <a class="el" href="classGio_1_1ResolverError.html">ResolverError</a> exception will be thrown.</p>
<p>If you are planning to connect to the service, it is usually easier to create a <a class="el" href="classGio_1_1NetworkService.html" title="A GSocketConnectable for resolving SRV records.">NetworkService</a> and use its <a class="el" href="classGio_1_1SocketConnectable.html" title="Interface for potential socket endpoints.">SocketConnectable</a> base class interface. \</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td>The service type to look up (eg, "ldap"). </td></tr>
    <tr><td class="paramname">protocol</td><td>The networking protocol to use for service (eg, "tcp") </td></tr>
    <tr><td class="paramname">domain</td><td>The DNS domain to look up the service in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49d103c02f6e0e8ad5d4e7abb1967ef0"></a><!-- doxytag: member="Gio::Resolver::lookup_service_async" ref="a49d103c02f6e0e8ad5d4e7abb1967ef0" args="(const Glib::ustring &amp;service, const Glib::ustring &amp;protocol, const Glib::ustring &amp;domain, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Resolver.html#a49d103c02f6e0e8ad5d4e7abb1967ef0">Gio::Resolver::lookup_service_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begins asynchronously performing a DNS SRV lookup for the given service and protocol in the given domain, and eventually calls callback, which must call <a class="el" href="classGio_1_1Resolver.html#aae68cb39415c9286474d92c7aeba2e47" title="Retrieves the result of a previous call to g_resolver_lookup_service_async().">lookup_service_finish()</a> to get the final result. </p>
<p>See glookup_service() for more details.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td>The service type to look up (eg, "ldap"). </td></tr>
    <tr><td class="paramname">protocol</td><td>The networking protocol to use for service (eg, "tcp") </td></tr>
    <tr><td class="paramname">domain</td><td>The DNS domain to look up the service in. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot to call after the resolution completes. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object which can be used to cancel the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58d46752ddd5305d811df4707c3ce4a7"></a><!-- doxytag: member="Gio::Resolver::lookup_service_async" ref="a58d46752ddd5305d811df4707c3ce4a7" args="(const Glib::ustring &amp;service, const Glib::ustring &amp;protocol, const Glib::ustring &amp;domain, const SlotAsyncReady &amp;slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGio_1_1Resolver.html#a49d103c02f6e0e8ad5d4e7abb1967ef0">Gio::Resolver::lookup_service_async</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begins asynchronously performing a DNS SRV lookup for the given service and protocol in the given domain, and eventually calls callback, which must call <a class="el" href="classGio_1_1Resolver.html#aae68cb39415c9286474d92c7aeba2e47" title="Retrieves the result of a previous call to g_resolver_lookup_service_async().">lookup_service_finish()</a> to get the final result. </p>
<p>See glookup_service() for more details.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td>The service type to look up (eg, "ldap"). </td></tr>
    <tr><td class="paramname">protocol</td><td>The networking protocol to use for service (eg, "tcp") </td></tr>
    <tr><td class="paramname">domain</td><td>The DNS domain to look up the service in. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot to call after the resolution completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae68cb39415c9286474d92c7aeba2e47"></a><!-- doxytag: member="Gio::Resolver::lookup_service_finish" ref="aae68cb39415c9286474d92c7aeba2e47" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGio.html#a1b4ed5afd24e359d3ba6bde02c9e90be">ListHandle_SrvTarget</a> <a class="el" href="classGio_1_1Resolver.html#aae68cb39415c9286474d92c7aeba2e47">Gio::Resolver::lookup_service_finish</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the result of a previous call to g_resolver_lookup_service_async(). </p>
<p>If the DNS resolution failed, <em>error</em> (if non-<code>0</code>) will be set to a value from <a class="el" href="classGio_1_1ResolverError.html">ResolverError</a>. If the operation was cancelled, <em>error</em> will be set to IO_ERROR_CANCELLED.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000082">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The result passed to your AsyncReadyCallback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A List of <a class="el" href="classGio_1_1SrvTarget.html" title="DNS SRV record target.">SrvTarget</a>, or <code>0</code> on error. See g_resolver_lookup_service() for more details. </dd></dl>

</div>
</div>
<a class="anchor" id="afbb1fb4f9edb0e553dbb61ca2437601c"></a><!-- doxytag: member="Gio::Resolver::set_default" ref="afbb1fb4f9edb0e553dbb61ca2437601c" args="(const Glib::RefPtr&lt; Resolver &gt; &amp;resolver)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classGio_1_1Resolver.html#afbb1fb4f9edb0e553dbb61ca2437601c">Gio::Resolver::set_default</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Resolver.html">Resolver</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>resolver</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a097abf4f88816a46fa2272430a1b5e3d"></a><!-- doxytag: member="Gio::Resolver::signal_reload" ref="a097abf4f88816a46fa2272430a1b5e3d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1SignalProxy0.html">Glib::SignalProxy0</a>&lt; void &gt; <a class="el" href="classGio_1_1Resolver.html#a097abf4f88816a46fa2272430a1b5e3d">Gio::Resolver::signal_reload</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Slot Prototype:</b></dt><dd><code>void on_my_reload()</code></dd></dl>
<p>Emitted when the resolver notices that the system resolver configuration has changed. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="aa710fc39dacfe0e34730487741d84fb9"></a><!-- doxytag: member="Gio::Resolver::wrap" ref="aa710fc39dacfe0e34730487741d84fb9" args="(GResolver *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Resolver.html">Gio::Resolver</a> &gt; <a class="el" href="classGio_1_1Resolver.html#aa710fc39dacfe0e34730487741d84fb9">wrap</a> </td>
          <td>(</td>
          <td class="paramtype">GResolver *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 10 2012 14:20:38 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
