<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>X Session Management Library</title><link rel="stylesheet" type="text/css" href="xorg.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /></head><body><div class="book" title="X Session Management Library"><div class="titlepage"><div><div><h1 class="title"><a id="smlibms"></a>X Session Management Library</h1></div><div><h2 class="subtitle">X Consortium Standard</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Ralph</span> <span class="surname">Mor</span></h3></div></div></div><div><p class="releaseinfo">X Version 11, Release 6.4</p></div><div><p class="releaseinfo">Version 1.0</p></div><div><p class="copyright">Copyright © 1993, 1994 X Consortium</p></div><div><div class="legalnotice" title="Legal Notice"><a id="idp16933664"></a><p>
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
“Software”), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of the Software,
and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:
     </p><p>
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
     </p><p>
THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
AND NONINFRINGEMENT.  IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     </p><p>
Except as contained in this notice, the name of the X Consortium shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from the X Consortium.
     </p><p>
X Window System is a trademark of The Open Group.
     </p></div></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="chapter"><a href="#overview_of_session_management">1. Overview of Session Management</a></span></dt><dt><span class="chapter"><a href="#the_session_management_library">2. The Session Management Library</a></span></dt><dt><span class="chapter"><a href="#understanding_smlibs_dependence_on_ice">3. Understanding SMlib's Dependence on ICE</a></span></dt><dt><span class="chapter"><a href="#header_files_and_library_name">4. Header Files and Library Name</a></span></dt><dt><span class="chapter"><a href="#session_management_client">5. Session Management Client (<acronym class="acronym">Smc</acronym>) Functions</a></span></dt><dd><dl><dt><span class="sect1"><a href="#connecting_to_the_session_manager">Connecting to the Session Manager</a></span></dt><dd><dl><dt><span class="sect2"><a href="#the_save_yourself_callback">The Save Yourself Callback</a></span></dt><dt><span class="sect2"><a href="#the_die_callback">The Die Callback</a></span></dt><dt><span class="sect2"><a href="#the_save_complete_callback">The Save Complete Callback</a></span></dt><dt><span class="sect2"><a href="#the_shutdown_cancelled_callback">The Shutdown Cancelled Callback</a></span></dt></dl></dd><dt><span class="sect1"><a href="#closing_the_connection">Closing the Connection</a></span></dt><dt><span class="sect1"><a href="#modifying_callbacks">Modifying Callbacks</a></span></dt><dt><span class="sect1"><a href="#setting_deleting_and_retrieving_session_management_properties">Setting, Deleting, and Retrieving Session Management Properties</a></span></dt><dt><span class="sect1"><a href="#interacting_with_the_user">Interacting With the User</a></span></dt><dt><span class="sect1"><a href="#requesting_a_save_yourself">Requesting a Save Yourself</a></span></dt><dt><span class="sect1"><a href="#requesting_a_save_yourself_phase_2">Requesting a Save Yourself Phase 2</a></span></dt><dt><span class="sect1"><a href="#completing_a_save_yourself">Completing a Save Yourself</a></span></dt><dt><span class="sect1"><a href="#using_smc_informational_functions">Using Smc Informational Functions</a></span></dt><dt><span class="sect1"><a href="#error_handling">Error Handling</a></span></dt></dl></dd><dt><span class="chapter"><a href="#session_management_server">6. Session Management Server (<acronym class="acronym">Sms</acronym>) Functions</a></span></dt><dd><dl><dt><span class="sect1"><a href="#initializing_the_library">Initializing the Library</a></span></dt><dd><dl><dt><span class="sect2"><a href="#the_register_client_callback">The Register Client Callback</a></span></dt><dt><span class="sect2"><a href="#the_interact_request_callback">The Interact Request Callback</a></span></dt><dt><span class="sect2"><a href="#the_interact_done_callback">The Interact Done Callback</a></span></dt><dt><span class="sect2"><a href="#the_save_yourself_request_callback">The Save Yourself Request Callback</a></span></dt><dt><span class="sect2"><a href="#the_save_yourself_phase_2_request_callback">The Save Yourself Phase 2 Request Callback</a></span></dt><dt><span class="sect2"><a href="#the_save_yourself_done_callback">The Save Yourself Done Callback</a></span></dt><dt><span class="sect2"><a href="#the_connection_closed_callback">The Connection Closed Callback</a></span></dt><dt><span class="sect2"><a href="#the_set_properties_callback">The Set Properties Callback</a></span></dt><dt><span class="sect2"><a href="#the_delete_properties_callback">The Delete Properties Callback</a></span></dt><dt><span class="sect2"><a href="#the_get_properties_callback">The Get Properties Callback</a></span></dt></dl></dd><dt><span class="sect1"><a href="#registering_the_client">Registering the Client</a></span></dt><dt><span class="sect1"><a href="#sending_a_save_yourself_message">Sending a Save Yourself Message</a></span></dt><dt><span class="sect1"><a href="#sending_a_save_yourself_phase_2_message">Sending a Save Yourself Phase 2 Message</a></span></dt><dt><span class="sect1"><a href="#sending_an_interact_message">Sending an Interact Message</a></span></dt><dt><span class="sect1"><a href="#sending_a_save_complete_message">Sending a Save Complete Message</a></span></dt><dt><span class="sect1"><a href="#sending_a_die_message">Sending a Die Message</a></span></dt><dt><span class="sect1"><a href="#cancelling_a_shutdown">Cancelling a Shutdown</a></span></dt><dt><span class="sect1"><a href="#returning_properties">Returning Properties</a></span></dt><dt><span class="sect1"><a href="#pinging_a_client">Pinging a Client</a></span></dt><dt><span class="sect1"><a href="#cleaning_up_after_a_client_disconnects">Cleaning Up After a Client Disconnects</a></span></dt><dt><span class="sect1"><a href="#using_sms_informational_functions">Using Sms Informational Functions</a></span></dt><dt><span class="sect1"><a href="#error_handling2">Error Handling</a></span></dt></dl></dd><dt><span class="chapter"><a href="#session_management_properties">7. Session Management Properties</a></span></dt><dt><span class="chapter"><a href="#freeing_data">8. Freeing Data</a></span></dt><dt><span class="chapter"><a href="#authentication_of_clients">9. Authentication of Clients</a></span></dt><dt><span class="chapter"><a href="#working_in_a_multithreaded_environment">10. Working in a Multi-Threaded Environment</a></span></dt><dt><span class="chapter"><a href="#acknowledgements">11. Acknowledgements</a></span></dt></dl></div><div class="chapter" title="Chapter 1. Overview of Session Management"><div class="titlepage"><div><div><h2 class="title"><a id="overview_of_session_management"></a>Chapter 1. Overview of Session Management</h2></div></div></div><div class="abstract" title="Abstract"><div class="titlepage"></div><p>
The purpose of the X Session Management Protocol (<acronym class="acronym">XSMP</acronym>)
is to provide a uniform mechanism for users to save and restore their
sessions.  A <em class="firstterm">session</em> is a group of clients,
each of which has a particular state.  The session is controlled by a
network service called the <em class="firstterm">session manager</em>.
The session manager issues commands to its clients on behalf of the
user.  These commands may cause clients to save their state or to
terminate.  It is expected that the client will save its state in such
a way that the client can be restarted at a later time and resume its
operation as if it had never been terminated.  A client's state might
include information about the file currently being edited, the current
position of the insertion point within the file, or the start of an
uncommitted transaction.  The means by which clients are restarted is
unspecified by this protocol.
    </p><p>
For purposes of this protocol, a <em class="firstterm">client</em> of the
session manager is defined as a connection to the session manager.  A
client is typically, though not necessarily, a process running an
application program connected to an X display.  However, a client may
be connected to more than one X display or not be connected to any X
displays at all.
    </p></div></div><div class="chapter" title="Chapter 2. The Session Management Library"><div class="titlepage"><div><div><h2 class="title"><a id="the_session_management_library"></a>Chapter 2. The Session Management Library</h2></div></div></div><div class="abstract" title="Abstract"><div class="titlepage"></div><p>
The Session Management Library (<abbr class="abbrev">SMlib</abbr>) is a low-level
"C" language interface to XSMP.  It is expected that higher level
toolkits, such as Xt, will hide many of the details of session
management from clients.  Higher level toolkits might also be developed
for session managers to use, but no such effort is currently under way.
    </p></div><p>
    SMlib has two parts to it:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="bullet"><li class="listitem" style="list-style-type: disc"><p>One set of functions for clients that want to be part of a session</p></li><li class="listitem" style="list-style-type: disc"><p>One set of functions for session managers to call</p></li></ul></div><p>
  </p><p>
Some applications will use both sets of functions and act as
<em class="firstterm">nested session managers</em>.  That is, they will be
both a session manager and a client of another session.  An example is
a mail program that could start a text editor for editing the text of
a mail message.  The mail program is part of a regular session and, at
the same time, is also acting as a session manager to the editor.
  </p><p>
Clients initialize by connecting to the session manager and obtaining
a <em class="firstterm">client-ID</em> that uniquely identifies them in
the session.  The session manager maintains a list of properties for
each client in the session.  These properties describe the client's
environment and, most importantly, describe how the client can be
restarted (via an <span class="property">SmRestartCommand</span>). Clients are
expected to save their state in such a way as to allow multiple
instantiations of themselves to be managed independently.  For
example, clients may use their client-ID as part of a filename in
which to store the state for a particular instantiation.  The
client-ID should be saved as part of the <span class="property">SmRestartCommand</span>
so that the client will retain the same ID after it is restarted.
  </p><p>
Once the client initializes itself with the session manager, it must
be ready to respond to messages from the session manager.  For
example, it might be asked to save its state or to terminate.  In the
case of a shutdown, the session manager might give each client a
chance to interact with the user and cancel the shutdown.
  </p></div><div class="chapter" title="Chapter 3. Understanding SMlib's Dependence on ICE"><div class="titlepage"><div><div><h2 class="title"><a id="understanding_smlibs_dependence_on_ice"></a>Chapter 3. Understanding SMlib's Dependence on ICE</h2></div></div></div><p>
The X Session Management Protocol is layered on top of the
Inter-Client Exchange (<acronym class="acronym">ICE</acronym>) Protocol.  The ICE
protocol is designed to multiplex several protocols over a single
connection.  As a result, working with SMlib requires a little
knowledge of how the ICE library works.
  </p><p>
The ICE library utilizes callbacks to process messages.  When a client
detects that there is data to read on an ICE connection, it should
call the <code class="function">IceProcessMessages</code> function.
<code class="function">IceProcessMessages</code> will read the message header
and look at the major opcode in order to determine which protocol the
message was intended for.  The appropriate protocol library will then
be triggered to unpack the message and hand it off to the client via a
callback.
  </p><p>
The main point to be aware of is that an application using SMlib must
have some code that detects when there is data to read on an ICE
connection.  This can be done via a <code class="function">select</code> call
on the file descriptor for the ICE connection, but more
typically, <code class="function">XtAppAddInput</code> will be used to register
a callback that will invoke <code class="function">IceProcessMessages</code>
each time there is data to read on the ICE connection.
  </p><p>
To further complicate things, knowing which file descriptors to
call <code class="function">select</code> on requires an understanding of how
ICE connections are created.  On the client side, a call must be made
to <code class="function">SmcOpenConnection</code> in order to open a connection
with a session manager.  <code class="function">SmcOpenConnection</code> will
internally makea call into <code class="function">IceOpenConnection</code>
which will, in turn, determine if an ICE connection already exists
between the client and session manager.  Most likely, a connection
will not already exist and a new ICE connection will be created.  The
main point to be aware of is that, on the client side, it is not
obvious when ICE connections get created or destroyed, because
connections are shared when possible.  To deal with this, the ICE
library lets the application register watch procedures that will be
invoked each time an ICE connection is opened or closed.  These watch
procedures could be used to add or remove ICE file descriptors from
the list of descriptors to call <code class="function">select</code> on.
  </p><p>
On the session manager side, things work a bit differently.  The
session manager has complete control over the creation of ICE
connections.  The session manager has to first
call <code class="function">IceListenForConnections</code> in order to start
listening for connections from clients.  Once a connection attempt is
detected, <code class="function">IceAcceptConnection</code> must be called, and
the session manager can simply add the new ICE file descriptor to the
list of descriptors to call <code class="function">select</code> on.

  </p><p>
For further information on the library functions related to ICE connections,
see the “<span class="citetitle">Inter-Client Exchange Library</span>”
standard.
  </p></div><div class="chapter" title="Chapter 4. Header Files and Library Name"><div class="titlepage"><div><div><h2 class="title"><a id="header_files_and_library_name"></a>Chapter 4. Header Files and Library Name</h2></div></div></div><p>
Applications (both session managers and clients) should include the
header file &lt;<code class="filename">X11/SM/SMlib.h</code>&gt;.
This header file defines all of the SMlib data structures and function
prototypes.  <code class="filename">SMlib.h</code> includes the
header file &lt;<code class="filename">X11/SM/SM.h</code>&gt;,
which defines all of the SMlib constants.
  </p><p>
Because SMlib is dependent on ICE, applications should link against
SMlib and ICElib by using
<span class="quote">“<span class="quote"><code class="option">-lSM</code> <code class="option">-lICE</code></span>”</span>.
  </p></div><div class="chapter" title="Chapter 5. Session Management Client (Smc) Functions"><div class="titlepage"><div><div><h2 class="title"><a id="session_management_client"></a>Chapter 5. Session Management Client (<acronym class="acronym">Smc</acronym>) Functions</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="sect1"><a href="#connecting_to_the_session_manager">Connecting to the Session Manager</a></span></dt><dd><dl><dt><span class="sect2"><a href="#the_save_yourself_callback">The Save Yourself Callback</a></span></dt><dt><span class="sect2"><a href="#the_die_callback">The Die Callback</a></span></dt><dt><span class="sect2"><a href="#the_save_complete_callback">The Save Complete Callback</a></span></dt><dt><span class="sect2"><a href="#the_shutdown_cancelled_callback">The Shutdown Cancelled Callback</a></span></dt></dl></dd><dt><span class="sect1"><a href="#closing_the_connection">Closing the Connection</a></span></dt><dt><span class="sect1"><a href="#modifying_callbacks">Modifying Callbacks</a></span></dt><dt><span class="sect1"><a href="#setting_deleting_and_retrieving_session_management_properties">Setting, Deleting, and Retrieving Session Management Properties</a></span></dt><dt><span class="sect1"><a href="#interacting_with_the_user">Interacting With the User</a></span></dt><dt><span class="sect1"><a href="#requesting_a_save_yourself">Requesting a Save Yourself</a></span></dt><dt><span class="sect1"><a href="#requesting_a_save_yourself_phase_2">Requesting a Save Yourself Phase 2</a></span></dt><dt><span class="sect1"><a href="#completing_a_save_yourself">Completing a Save Yourself</a></span></dt><dt><span class="sect1"><a href="#using_smc_informational_functions">Using Smc Informational Functions</a></span></dt><dt><span class="sect1"><a href="#error_handling">Error Handling</a></span></dt></dl></div><p>
    This section discusses how Session Management clients:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="bullet"><li class="listitem" style="list-style-type: disc"><p>Connect to the Session Manager</p></li><li class="listitem" style="list-style-type: disc"><p>Close the connection</p></li><li class="listitem" style="list-style-type: disc"><p>Modify callbacks</p></li><li class="listitem" style="list-style-type: disc"><p>Set, delete, and retrieve Session Manager properties</p></li><li class="listitem" style="list-style-type: disc"><p>Interact with the user</p></li><li class="listitem" style="list-style-type: disc"><p>Request a “Save Yourself”</p></li><li class="listitem" style="list-style-type: disc"><p>Request a “Save Yourself Phase 2”</p></li><li class="listitem" style="list-style-type: disc"><p>Complete a “Save Yourself”</p></li><li class="listitem" style="list-style-type: disc"><p>Use Smc informational functions</p></li><li class="listitem" style="list-style-type: disc"><p>Handle Errors</p></li></ul></div><p>
  </p><div class="sect1" title="Connecting to the Session Manager"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="connecting_to_the_session_manager"></a>Connecting to the Session Manager</h2></div></div></div><p>
To open a connection with a session manager,
use <code class="function">SmcOpenConnection</code>
    </p><div class="funcsynopsis"><p><code class="funcdef">SmcConn <strong>fsfuncSmcOpenConnection</strong>(</code>char *<var class="pdparam">network_ids_list</var>, SmPointer <var class="pdparam">context</var>, int <var class="pdparam">xsmp_major_rev</var>, int <var class="pdparam">xsmp_minor_rev</var>, unsigned long <var class="pdparam">mask</var>, SmcCallbacks *<var class="pdparam">callbacks</var>, char *<var class="pdparam">previous_id</var>, char **<var class="pdparam">client_id_ret</var>, int <var class="pdparam">error_length</var>, char *<var class="pdparam">error_string_ret</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>network_ids_list</code></em></span></p></td><td><p>Specifies the network ID(s) of the session manager.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>context</code></em></span></p></td><td><p>
A pointer to an opaque object or <code class="constant">NULL</code>.  Used to determine
if an ICE connection can be shared
(see <a class="link" href="#context_sharing">below</a>).
     </p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>xsmp_major_rev</code></em></span></p></td><td><p>
The highest major version of the XSMP the application supports.
	</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>xsmp_minor_rev</code></em></span></p></td><td><p>
The highest minor version of the XSMP the application supports (for
the specified <em class="parameter"><code>xsmp_major_rev</code></em>).
	</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>mask</code></em></span></p></td><td><p>A mask indicating which callbacks to register.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>callbacks</code></em></span></p></td><td><p>
The callbacks to register.  These callbacks are used to respond to
messages from the session manager.
	</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>previous_id</code></em></span></p></td><td><p>The client ID from the previous session.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>client_id_ret</code></em></span></p></td><td><p>The client ID for the current session is returned.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>error_length</code></em></span></p></td><td><p>Length of the <em class="parameter"><code>error_string_ret</code></em> argument passed in.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>error_string_ret</code></em></span></p></td><td><p>
Returns a null-terminated error message, if any.
The <em class="parameter"><code>error_string_ret</code></em> argument points to user supplied
memory.  No more than <em class="parameter"><code>error_length</code></em> bytes are used.
	</p></td></tr></tbody></table></div><p>
The <em class="parameter"><code>network_ids_list</code></em> argument is a
null-terminated string containing a list of network IDs for the session
manager, separated by commas. If <em class="parameter"><code>network_ids_list</code></em>
is <code class="constant">NULL</code>, the value of
the <code class="envar">SESSION_MANAGER</code> environment variable will be used.
Each network ID has the following format:

</p><div class="informaltable"><table border="0"><colgroup><col align="center" class="c1" /><col align="center" class="c2" /><col align="center" class="c3" /></colgroup><tbody><tr><td align="left"> </td><td align="left"><code class="literal">tcp/</code><em class="parameter"><code>&lt;hostname&gt;</code></em><code class="literal">:</code><em class="parameter"><code>&lt;portnumber&gt;</code></em></td><td align="left">or</td></tr><tr><td align="left"> </td><td align="left"><code class="literal">decnet/</code><em class="parameter"><code>&lt;hostname&gt;</code></em><code class="literal">::</code><em class="parameter"><code>&lt;objname&gt;</code></em></td><td align="left">or</td></tr><tr><td align="left"> </td><td align="left"><code class="literal">local/</code><em class="parameter"><code>&lt;hostname&gt;</code></em><code class="literal">:</code><em class="parameter"><code>&lt;path&gt;</code></em></td><td align="left"> </td></tr></tbody></table></div><p>
    </p><p>
An attempt will be made to use the first network ID.  If that fails,
an attempt will be made using the second network ID, and so on.
    </p><p>
After the connection is established, <code class="function">SmcOpenConnection</code>
registers the client with the session manager.  If the client is being
restarted from a previous session, <em class="parameter"><code>previous_id</code></em>
should contain a null terminated string representing the client ID from the
previous session.  If the client is first joining the session,
<em class="parameter"><code>previous_id</code></em> should be set to <code class="constant">NULL</code>.
If <em class="parameter"><code>previous_id</code></em> is specified but is determined
to be invalid by the session manager, SMlib will re-register the
client with <em class="parameter"><code>previous_id</code></em> set to <code class="constant">NULL</code>.
    </p><p>
If <code class="function">SmcOpenConnection</code> succeeds, it returns an
opaque connection pointer of type <code class="function">SmcConn</code> and the
<em class="parameter"><code>client_id_ret</code></em> argument contains the client ID to be
used for this session.  The <em class="parameter"><code>client_id_ret</code></em> should be
freed with a call to <code class="function">free</code> when no longer needed.  On
failure, <code class="function">SmcOpenConnection</code> returns
<code class="constant">NULL</code>, and the reason for failure is returned in
<em class="parameter"><code>error_string_ret</code></em>.
    </p><p>
Note that SMlib uses the ICE protocol to establish a connection with
the session manager.  If an ICE connection already exists between the
client and session manager, it might be possible for the same ICE
connection to be used for session management.
    </p><p><a id="context_sharing"></a>
The context argument indicates how willing the client is to share the
ICE connection with other protocols.  If context is <code class="constant">NULL</code>,
then the caller is always willing to share the connection.  If context is not
<code class="constant">NULL</code>, then the caller is not willing to use a previously
opened ICE connection that has a different non-<code class="constant">NULL</code>
context associated with it.
    </p><p>
As previously discussed
(<a class="link" href="#understanding_smlibs_dependence_on_ice" title="Chapter 3. Understanding SMlib's Dependence on ICE">section 3,
“Understanding SMlib's Dependence on ICE”</a>), the
client will have to keep track of when ICE connections are created or
destroyed (using <code class="function">IceAddConnectionWatch</code>
and <code class="function">IceRemoveConnectionWatch</code> and will have to
call <code class="function">IceProcessMessages</code> each time
a <code class="function">select</code> shows that there is data to read on an
ICE connection.  For further information, see the
“<span class="citetitle">Inter-Client Exchange Library</span>”
standard.
    </p><p>
The callbacks argument contains a set of callbacks used to respond to
session manager events.  The mask argument specifies which callbacks
are set.  All of the callbacks specified in this version of SMlib are
mandatory.  The mask argument is necessary in order to maintain
backwards compatibility in future versions of the library.
    </p><p>
The following values may be ORed together to obtain a
<em class="parameter"><code>mask</code></em> value:

      </p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="constant">SmcSaveYourselfProcMask</code></td></tr><tr><td><code class="constant">SmcDieProcMask</code></td></tr><tr><td><code class="constant">SmcSaveCompleteProcMask</code></td></tr><tr><td><code class="constant">SmcShutdownCancelledProcMask</code></td></tr></table><p>
    </p><p>
For each callback, the client can register a pointer to client data.
When SMlib invokes the callback, it will pass the client data pointer.
    </p><pre class="synopsis">
typedef struct {

	struct {
		SmcSaveYourselfProc callback;
		SmPointer client_data;
	} save_yourself;

	struct {
		SmcDieProc callback;
		SmPointer client_data;
	} die;

	struct {
		SmcSaveCompleteProc callback;
		SmPointer client_data;
	} save_complete;

	struct {
		SmcShutdownCancelledProc callback;
		SmPointer client_data;
	} shutdown_cancelled;

} SmcCallbacks;
</pre><div class="sect2" title="The Save Yourself Callback"><div class="titlepage"><div><div><h3 class="title"><a id="the_save_yourself_callback"></a>The Save Yourself Callback</h3></div></div></div><p>
The Save Yourself callback is of type <code class="function">SmcSaveYourselfProc</code>
      </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSaveYourselfProc</strong>)(</code>SmcConn <var class="pdparam">smc_conn</var>, SmcConn <var class="pdparam">client_data</var>, int <var class="pdparam">save_type</var>, Bool <var class="pdparam">shutdown</var>, int <var class="pdparam">interact_style</var>, Bool <var class="pdparam">fast</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>client_data</code></em></span></p></td><td><p>Client data specified when the callback was registered.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>save_type</code></em></span></p></td><td><p>Specifies the type of information that should be saved.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>shut_down</code></em></span></p></td><td><p>Specifies if a shutdown is taking place.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>interact_style</code></em></span></p></td><td><p>The type of interaction allowed with the user.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>fast</code></em></span></p></td><td><p>if <span class="symbol">True</span>, then client should save its state as quickly as possible.</p></td></tr></tbody></table></div><p>
The session manager sends a “Save Yourself” message to a
client either to checkpoint it or just before termination so that it
can save its state.  The client responds with zero or more calls
to <code class="function">SmcSetProperties</code> to update the properties
indicating how to restart the client.  When all the properties have
been set, the client calls <code class="function">SmcSaveYourselfDone</code>
      </p><p>
If <em class="parameter"><code>interact_style</code></em> is
<code class="constant">SmInteractStyleNone</code> the
client must not interact with the user while saving state.
If <em class="parameter"><code>interact_style</code></em> is
<code class="constant">SmInteractStyleErrors</code> the
client may interact with the user only if an error condition arises.
If <em class="parameter"><code>interact_style</code></em> is
<code class="constant">SmInteractStyleAny</code> then the
client may interact with the user for any purpose.  Because only one
client can interact with the user at a time, the client must
call <code class="function">SmcInteractRequest</code> and wait for an
“Interact” message from the session manager.  When the
client is done interacting with the user, it
calls <code class="function">SmcInteractDone</code> The client may only
call <code class="function">SmcInteractRequest</code> after it receives a
“Save Yourself” message and before it
calls <code class="function">SmcSaveYourselfDone</code>
      </p><p>
If <em class="parameter"><code>save_type</code></em> is <code class="constant">SmSaveLocal</code> the
client must update the properties to reflect its current state.  Specifically,
it should save enough information to restore the state as seen by the
user of this client.  It should not affect the state as seen by other users.
If <em class="parameter"><code>save_type</code></em> is <code class="constant">SmSaveGlobal</code>
the user wants the client to commit all of its data to permanent, globally
accessible storage.
If <em class="parameter"><code>save_type</code></em> is <code class="constant">SmSaveBoth</code>
the client should do both of these (it should first commit the data to
permanent storage before updating its properties).
      </p><p>
Some examples are as follows:

        </p><div class="itemizedlist"><ul class="itemizedlist" type="bullet"><li class="listitem" style="list-style-type: disc"><p>
If a word processor were sent a “Save Yourself” with a
type of <code class="constant">SmSaveLocal</code> it could create a temporary
file that included the current contents of the file, the location of
the cursor, and other aspects of the current editing session.  It
would then update its <span class="property">SmRestartCommand</span> property with
enough information to find this temporary file.
	  </p></li><li class="listitem" style="list-style-type: disc"><p>
If a word processor were sent a “Save Yourself” with a
type of <code class="constant">SmSaveGlobal</code> it would simply save the
currently edited file.
	  </p></li><li class="listitem" style="list-style-type: disc"><p>
If a word processor were sent a “Save Yourself” with a
type of <code class="constant">SmSaveBoth</code> it would first save the
currently edited file.  It would then create a temporary file with
information such as the current position of the cursor and what file
is being edited.  Finally, it would update its
<span class="property">SmRestartCommand</span> property with enough information
to find the temporary file.
	  </p></li></ul></div><p>
      </p><p>
The <em class="parameter"><code>shutdown</code></em> argument specifies whether the
system is being shut down.
The interaction is different depending on whether or not shutdown is
set.  If not shutting down, the client should save its state and wait
for a “Save Complete” message.  If shutting down, the
client must save state and then prevent interaction until it receives
either a “Die” or a “Shutdown Cancelled.”
      </p><p>
The <em class="parameter"><code>fast</code></em> argument specifies that the client
should save its state as quickly as possible.  For example, if the
session manager knows that power is about to fail, it would
set <em class="parameter"><code>fast</code></em> to <code class="constant">True</code>.
      </p></div><div class="sect2" title="The Die Callback"><div class="titlepage"><div><div><h3 class="title"><a id="the_die_callback"></a>The Die Callback</h3></div></div></div><p>
The Die callback is of type <code class="function">SmcDieProc</code>
      </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSmcDieProc</strong>)(</code>SmcConn <var class="pdparam">smc_conn</var>, SmcConn <var class="pdparam">client_data</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>client_data</code></em></span></p></td><td><p>Client data specified when the callback was registered.</p></td></tr></tbody></table></div><p>
The session manager sends a “Die” message to a client when
it wants it to die.  The client should respond by calling
<code class="function">SmcCloseConnection</code>.  A session manager that
behaves properly will send a “Save Yourself” message
before the “Die” message.
      </p></div><div class="sect2" title="The Save Complete Callback"><div class="titlepage"><div><div><h3 class="title"><a id="the_save_complete_callback"></a>The Save Complete Callback</h3></div></div></div><p>
The Save Complete callback is of type <code class="function">SmcSaveCompleteProc</code>
      </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSmcSaveCompleteProc</strong>)(</code>SmcConn <var class="pdparam">smc_conn</var>, SmPointer <var class="pdparam">client_data</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>client_data</code></em></span></p></td><td><p>Client data specified when the callback was registered.</p></td></tr></tbody></table></div></div><div class="sect2" title="The Shutdown Cancelled Callback"><div class="titlepage"><div><div><h3 class="title"><a id="the_shutdown_cancelled_callback"></a>The Shutdown Cancelled Callback</h3></div></div></div><p>
The Shutdown Cancelled callback is of type
<code class="function">SmcShutdownCancelledProc</code>
      </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSmcShutdownCancelledProc</strong>)(</code>SmcConn <var class="pdparam">smc_conn</var>, SmPointer <var class="pdparam">client_data</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>client_data</code></em></span></p></td><td><p>Client data specified when the callback was registered.</p></td></tr></tbody></table></div><p>
The session manager sends a “Shutdown Cancelled” message
when the user cancelled the shutdown during an interaction
(see <a class="link" href="#interacting_with_the_user" title="Interacting With the User">section 5.5,
“Interacting With the User”</a>).  The client can now
continue as if the shutdown had never happened.  If the client has not
called <code class="function">SmcSaveYourselfDone</code> yet, it can either
abort the save and then call <code class="function">SmcSaveYourselfDone</code>
with the success argument set to <code class="constant">False</code> or it can
continue with the save and then call <code class="function">SmcSaveYourselfDone</code>
with the <em class="parameter"><code>success</code></em> argument set to reflect the outcome
of the save.
      </p></div></div><div class="sect1" title="Closing the Connection"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="closing_the_connection"></a>Closing the Connection</h2></div></div></div><p>
To close a connection with a session manager,
use <code class="function">SmcCloseConnection</code>
    </p><div class="funcsynopsis"><p><code class="funcdef">SmcCloseStatus <strong>fsfuncSmcCloseConnection</strong>(</code>SmcConn <var class="pdparam">smc_conn</var>, int <var class="pdparam">count</var>, char **<var class="pdparam">reason_msgs</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>count</code></em></span></p></td><td><p>The number of reasons for closing the connection.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>reason_msgs</code></em></span></p></td><td><p>The reasons for closing the connection.</p></td></tr></tbody></table></div><p>
The <em class="parameter"><code>reason_msgs</code></em> argument will most likely be
<code class="constant">NULL</code> if resignation is expected by the client.
Otherwise, it contains a list of null-terminated Compound Text strings
representing the reason for termination.  The session manager should
display these reason messages to the user.
    </p><p>
Note that SMlib used the ICE protocol to establish a connection with
the session manager, and various protocols other than session
management may be active on the ICE connection.
When <code class="function">SmcCloseConnection</code> is called, the ICE
connection will be closed only if all protocols have been shutdown on
the connection.  Check the ICElib standard
for <code class="function">IceAddConnectionWatch</code>
and <code class="function">IceRemoveConnectionWatch</code> to learn how to set
up a callback to be invoked each time an ICE connection is opened or
closed.  Typically this callback adds/removes the ICE file descriptor
from the list of active descriptors to call <code class="function">select</code> on
(or calls <code class="function">XtAppAddInput</code> or
<code class="function">XtRemoveInput</code>).
    </p><p>
<code class="function">SmcCloseConnection</code> returns one of the following values:

      </p><div class="itemizedlist"><ul class="itemizedlist" type="bullet"><li class="listitem" style="list-style-type: disc"><p>
<code class="constant">SmcClosedNow</code> - the ICE connection was closed at
this time, the watch procedures were invoked, and the connection was freed.
	</p></li><li class="listitem" style="list-style-type: disc"><p>
<code class="constant">SmcClosedASAP</code> - an IO error had occurred on the
connection, but <code class="function">SmcCloseConnection</code> is being
called within a nested <code class="function">IceProcessMessages</code> The
watch procedures have been invoked at this time, but the connection
will be freed as soon as possible (when the nesting level reaches zero
and <code class="function">IceProcessMessages</code> returns a status
of <code class="function">IceProcessMessagesConnectionClosed</code>
	</p></li><li class="listitem" style="list-style-type: disc"><p>
<code class="constant">SmcConnectionInUse</code> - the connection was not closed at
this time, because it is being used by other active protocols.
	</p></li></ul></div><p>
    </p></div><div class="sect1" title="Modifying Callbacks"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="modifying_callbacks"></a>Modifying Callbacks</h2></div></div></div><p>
To modify callbacks set up in <code class="function">SmcOpenConnection</code>
use <code class="function">SmcModifyCallbacks</code>
    </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncSmcModifyCallbacks</strong>(</code>SmcConn <var class="pdparam">smc_conn</var>, unsigned long <var class="pdparam">mask</var>, SmcCallbacks *<var class="pdparam">callbacks</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>mask</code></em></span></p></td><td><p>A mask indicating which callbacks to modify.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>callbacks</code></em></span></p></td><td><p>The new callbacks.</p></td></tr></tbody></table></div><p>
When specifying a value for the <em class="parameter"><code>mask</code></em> argument,
the following values may be ORed together:

      </p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="constant">SmcSaveYourselfProcMask</code></td></tr><tr><td><code class="constant">SmcDieProcMask</code></td></tr><tr><td><code class="constant">SmcSaveCompleteProcMask</code></td></tr><tr><td><code class="constant">SmcShutdownCancelledProcMask</code></td></tr></table><p>
    </p></div><div class="sect1" title="Setting, Deleting, and Retrieving Session Management Properties"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="setting_deleting_and_retrieving_session_management_properties"></a>Setting, Deleting, and Retrieving Session Management Properties</h2></div></div></div><p>
To set session management properties for this client,
use <code class="function">SmcSetProperties</code>
    </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncSmcSetProperties</strong>(</code>SmcConn <var class="pdparam">smc_conn</var>, int <var class="pdparam">num_props</var>, SmProp **<var class="pdparam">props</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>num_props</code></em></span></p></td><td><p>The number of properties.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>props</code></em></span></p></td><td><p>The list of properties to set.</p></td></tr></tbody></table></div><p>
The properties are specified as an array of property pointers.
Previously set property values may be over-written using
the <code class="function">SmcSetProperties</code> function.  Note that the
session manager is not expected to restore property values when the
session is restarted.  Because of this, clients should not try to use
the session manager as a database for storing application specific state.
    </p><p>
For a description of session management properties and
the <span class="structname">SmProp</span> structure,
see <a class="link" href="#session_management_properties" title="Chapter 7. Session Management Properties">section 7,
“Session Management Properties.”</a>
    </p><p>
To delete properties previously set by the client,
use <code class="function">SmcDeleteProperties</code>
    </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncSmcDeleteProperties</strong>(</code>SmcConn <var class="pdparam">smc_conn</var>, int <var class="pdparam">num_props</var>, char **<var class="pdparam">prop_names</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>num_props</code></em></span></p></td><td><p>The number of properties.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>prop_names</code></em></span></p></td><td><p>The list of properties to set.</p></td></tr></tbody></table></div><p>
To get properties previously stored by the client,
use <code class="function">SmcGetProperties</code>
    </p><div class="funcsynopsis"><p><code class="funcdef">Status <strong>fsfuncSmcGetProperties</strong>(</code>SmcConn <var class="pdparam">smc_conn</var>, SmcPropReplyProc <var class="pdparam">prop_reply_proc</var>, SmPointer <var class="pdparam">client_data</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>prop_reply_proc</code></em></span></p></td><td><p>The callback to be invoked when the properties reply comes back.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>client_data</code></em></span></p></td><td><p>This pointer to client data will be passed to the <code class="function">SmcPropReplyProc</code> callback.</p></td></tr></tbody></table></div><p>
The return value of <code class="function">SmcGetProperties</code> is zero for
failure and a positive value for success.
    </p><p>
Note that the library does not block until the properties reply comes
back.  Rather, a callback of type <code class="function">SmcPropReplyProc</code>
is invoked when the data is ready.
    </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSmcPropReplyProc</strong>)(</code>SmcConn <var class="pdparam">smc_conn</var>, SmPointer <var class="pdparam">client_data</var>, int <var class="pdparam">num_props</var>, SmProp **<var class="pdparam">props</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>client_data</code></em></span></p></td><td><p>This pointer to client data will be passed to the <code class="function">SmcPropReplyProc</code> callback.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>num_props</code></em></span></p></td><td><p>The number of properties returned.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>props</code></em></span></p></td><td><p>The list of properties returned.</p></td></tr></tbody></table></div><p>
To free each property, use <code class="function">SmFreeProperty</code>
(see <a class="link" href="#freeing_data" title="Chapter 8. Freeing Data">section 8, “Freeing
Data”</a>).  To free the actual array of pointers,
use <code class="function">free</code>
    </p></div><div class="sect1" title="Interacting With the User"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="interacting_with_the_user"></a>Interacting With the User</h2></div></div></div><p>
After receiving a “Save Yourself” message with an
<em class="parameter"><code>interact_style</code></em> of
<code class="constant">SmInteractStyleErrors</code>
or <code class="constant">SmInteractStyleAny</code> the client may choose to
interact with the user.  Because only one client can interact with the
user at a time, the client must call <code class="function">SmcInteractRequest</code>
and wait for an “Interact” message from the session manager.
    </p><div class="funcsynopsis"><p><code class="funcdef">Status <strong>fsfuncSmcInteractRequest</strong>(</code>SmcConn <var class="pdparam">smc_conn</var>, int <var class="pdparam">dialog_type</var>, SmcInteractProc <var class="pdparam">interact_proc</var>, SmPointer <var class="pdparam">client_data</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>dialog_type</code></em></span></p></td><td><p>The type of dialog the client wishes to present to the user.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>interact_proc</code></em></span></p></td><td><p>The callback to be invoked when the “Interact” message arrives from the session manager.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>client_data</code></em></span></p></td><td><p>
This pointer to client data will be passed to
the <code class="function">SmcInteractProc</code> callback when the
“Interact” message arrives.
    </p></td></tr></tbody></table></div><p>
The return value of <code class="function">SmcInteractRequest</code> is zero
for failure and a positive value for success.
    </p><p>
The <em class="parameter"><code>dialog_type</code></em> argument specifies
either <code class="constant">SmDialogError</code> indicating that the client
wants to start an error dialog, or <code class="constant">SmDialogNormal</code>
meaning that the client wishes to start a nonerror dialog.
    </p><p>
Note that if a shutdown is in progress, the user may have the option
of cancelling the shutdown.  If the shutdown is cancelled, the clients
that have not interacted yet with the user will receive a
“Shutdown Cancelled” message instead of the
“Interact” message.
    </p><p>
The <code class="function">SmcInteractProc</code> callback will be invoked when
the “Interact” message arrives from the session manager.
    </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSmcInteractProc</strong>)(</code>SmcConn <var class="pdparam">smc_conn</var>, SmPointer <var class="pdparam">client_data</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>client_data</code></em></span></p></td><td><p>Client data specified when the callback was registered.</p></td></tr></tbody></table></div><p>
After interacting with the user (in response to an “Interact”
message), you should call <code class="function">SmcInteractDone</code>
    </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncSmcInteractDone</strong>(</code>SmcConn <var class="pdparam">smc_conn</var>, Bool <var class="pdparam">cancel_shutdown</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>cancel_shutdown</code></em></span></p></td><td><p>If <code class="constant">True</code>, indicates that the user requests that the entire shutdown be cancelled.</p></td></tr></tbody></table></div><p>
The <em class="parameter"><code>cancel_shutdown</code></em> argument may only be
<code class="constant">True</code> if the corresponding “Save Yourself”
specified <code class="constant">True</code> for shutdown
and <code class="constant">SmInteractStyleErrors</code>
or <code class="constant">SmInteractStyleAny</code> for
the <em class="parameter"><code>interact_style</code></em>.
    </p></div><div class="sect1" title="Requesting a Save Yourself"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="requesting_a_save_yourself"></a>Requesting a Save Yourself</h2></div></div></div><p>
To request a checkpoint from the session manager,
use <code class="function">SmcRequestSaveYourself</code>
    </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncSmcRequestSaveYourself</strong>(</code>SmcConn <var class="pdparam">smc_conn</var>, int <var class="pdparam">save_type</var>, Bool <var class="pdparam">shutdown</var>, int <var class="pdparam">interact_style</var>, Bool <var class="pdparam">fast</var>, Bool <var class="pdparam">global</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>save_type</code></em></span></p></td><td><p>Specifies the type of information that should be saved.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>shutdown</code></em></span></p></td><td><p>Specifies if a shutdown is taking place.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>interact_style</code></em></span></p></td><td><p>The type of interaction allowed with the user.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>fast</code></em></span></p></td><td><p>If <code class="constant">True</code> the client should save its state as quickly as possible.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>global</code></em></span></p></td><td><p>Controls who gets the “Save Yourself.”</p></td></tr></tbody></table></div><p>
The <em class="parameter"><code>save_type</code></em>, <em class="parameter"><code>shutdown</code></em>,
<em class="parameter"><code>interact_style</code></em>, and <em class="parameter"><code>fast</code></em>
arguments are discussed in more detail in
<a class="link" href="#the_save_yourself_callback" title="The Save Yourself Callback">section 5.1.1,
“The Save Yourself Callback.”</a>
    </p><p>
If <em class="parameter"><code>global</code></em> is set to <code class="constant">True</code> then
the resulting “Save Yourself” should be sent to all clients in the
session.  For example, a vendor of a Uninterruptible Power Supply
(<acronym class="acronym">UPS</acronym>) might include a Session Management client
that would monitor the status of the UPS and generate a fast shutdown
if the power is about to be lost.
    </p><p>
If global is set to <code class="constant">False</code> then the “Save
Yourself” should only be sent to the client that requested it.
    </p></div><div class="sect1" title="Requesting a Save Yourself Phase 2"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="requesting_a_save_yourself_phase_2"></a>Requesting a Save Yourself Phase 2</h2></div></div></div><p>
In response to a “Save Yourself”, the client may request to be
informed when all the other clients are quiescent so that it can save their
state.  To do so, use <code class="function">SmcRequestSaveYourselfPhase2</code>
    </p><div class="funcsynopsis"><p><code class="funcdef">Status <strong>fsfuncSmcRequestSaveYourselfPhase2</strong>(</code>SmcConn <var class="pdparam">smc_conn</var>, SmcSaveYourselfPhase2Proc <var class="pdparam">save_yourself_phase2_proc</var>, SmPointer <var class="pdparam">client_data</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>save_type_phase2_proc</code></em></span></p></td><td><p>The callback to be invoked when the “Save Yourself Phase 2” message arrives from the session manager.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>client_data</code></em></span></p></td><td><p>This pointer to client data will be passed to the <code class="function">SmcSaveYourselfPhase2Proc</code> callback when the “Save Yourself Phase 2” message arrives.</p></td></tr></tbody></table></div><p>
The return value of <code class="function">SmcRequestSaveYourselfPhase2</code>
is zero for failure and a positive value for success.
    </p><p>
This request is needed by clients that manage other clients (for
example, window managers, workspace managers, and so on).  The manager
must make sure that all of the clients that are being managed are in
an idle state so that their state can be saved.
    </p></div><div class="sect1" title="Completing a Save Yourself"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="completing_a_save_yourself"></a>Completing a Save Yourself</h2></div></div></div><p>
After saving state in response to a “Save Yourself”
message, you should call <code class="function">SmcSaveYourselfDone</code>
    </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncSmcSaveYourselfDone</strong>(</code>SmcConn <var class="pdparam">smc_conn</var>, Bool <var class="pdparam">success</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>success</code></em></span></p></td><td><p>If <code class="constant">True</code> the “Save Yourself” operation was completed successfully.</p></td></tr></tbody></table></div><p>
Before calling <code class="function">SmcSaveYourselfDone</code> the client
must have set each required property at least once since the client
registered with the session manager.
    </p></div><div class="sect1" title="Using Smc Informational Functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="using_smc_informational_functions"></a>Using Smc Informational Functions</h2></div></div></div><div class="funcsynopsis"><p><code class="funcdef">int <strong>fsfuncSmcProtocolVersion</strong>(</code>SmcConn <var class="pdparam">smc_conn</var><code>)</code>;</p></div><p>
<code class="function">SmcProtocolVersion</code> returns the major version of
the session management protocol associated with this session.
    </p><div class="funcsynopsis"><p><code class="funcdef">int <strong>fsfuncSmcProtocolRevision</strong>(</code>SmcConn <var class="pdparam">smc_conn</var><code>)</code>;</p></div><p>
<code class="function">SmcProtocolRevision</code> returns the minor version of
the session management protocol associated with this session.
    </p><div class="funcsynopsis"><p><code class="funcdef">char *<strong>fsfuncSmcVendor</strong>(</code>SmcConn <var class="pdparam">smc_conn</var><code>)</code>;</p></div><p>
<code class="function">SmcVendor</code> returns a string that provides some
identification of the owner of the session manager.  The string should
be freed with a call to <code class="function">free</code>
    </p><div class="funcsynopsis"><p><code class="funcdef">char *<strong>fsfuncSmcRelease</strong>(</code>SmcConn <var class="pdparam">smc_conn</var><code>)</code>;</p></div><p>
<code class="function">SmcRelease</code> returns a string that provides the
release number of the session manager.  The string should be freed
with a call to <code class="function">free</code>
    </p><div class="funcsynopsis"><p><code class="funcdef">char *<strong>fsfuncSmcClientID</strong>(</code>SmcConn <var class="pdparam">smc_conn</var><code>)</code>;</p></div><p>
<code class="function">SmcClientID</code> returns a null-terminated string for
the client ID associated with this connection.  This information was
also returned in <code class="function">SmcOpenConnection</code> (it is
provided here for convenience).  Call <code class="function">free</code> on
this pointer when the client ID is no longer needed.
    </p><div class="funcsynopsis"><p><code class="funcdef">IceConn <strong>fsfuncSmcGetIceConnection</strong>(</code>SmcConn <var class="pdparam">smc_conn</var><code>)</code>;</p></div><p>
<code class="function">SmcGetIceConnection</code> returns the ICE connection
object associated with this session management connection object.  The
ICE connection object can be used to get some additional information
about the connection.  Some of the more useful functions which can be
used on the IceConn are <code class="function">IceConnectionNumber</code>,
<code class="function">IceConnectionString</code>,
<code class="function">IceLastSentSequenceNumber</code>,
<code class="function">IceLastReceivedSequenceNumber</code>,
and <code class="function">IcePing</code>. For further information, see
the “<span class="citetitle">Inter-Client Exchange Library</span>”
standard.
    </p></div><div class="sect1" title="Error Handling"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="error_handling"></a>Error Handling</h2></div></div></div><p>
If the client receives an unexpected protocol error from the session
manager, an error handler is invoked by SMlib.  A default error
handler exists that simply prints the error message
to <code class="varname">stderr</code> and exits if the severity of the error
is fatal.  The client can change this error handler by calling
the <code class="function">SmcSetErrorHandler</code> function.
    </p><div class="funcsynopsis"><p><code class="funcdef">SmcErrorHandler <strong>fsfuncSmcSetErrorHandler</strong>(</code>SmcErrorHandler <var class="pdparam">handler</var><code>)</code>;</p></div><p>
The error handler.  You should pass <code class="constant">NULL</code> to
restore the default handler.
    </p><p>
<code class="function">SmcSetErrorHandler</code> returns the previous error handler.
    </p><p>
The <code class="function">SmcErrorHandler</code> has the following type:
    </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSmcErrorHandler</strong>)(</code>SmcConn <var class="pdparam">smc_conn</var>, Bool <var class="pdparam">swap</var>, int <var class="pdparam">offending_minor_opcode</var>, unsigned long <var class="pdparam">offending_sequence_num</var>, int <var class="pdparam">error_class</var>, int <var class="pdparam">severity</var>, IcePointer <var class="pdparam">values</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>smc_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>swap</code></em></span></p></td><td><p>A flag that indicates if the specified values need byte swapping.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>offending_minor_opcode</code></em></span></p></td><td><p>The minor opcode of the offending message.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>offending_sequence_num</code></em></span></p></td><td><p>The sequence number of the offending message.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>error_class</code></em></span></p></td><td><p>The error class of the offending message.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>severity</code></em></span></p></td><td><p><code class="constant">IceCanContinue</code>,
	 <code class="constant">IceFatalToProtocol</code>, or
	 <code class="constant">IceFatalToConnection</code>
     </p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>values</code></em></span></p></td><td><p>Any additional error values specific to the minor opcode and class.</p></td></tr></tbody></table></div><p>
Note that this error handler is invoked for protocol related errors.
To install an error handler to be invoked when an IO error occurs, use
<code class="function">IceSetIOErrorHandler</code> For further information, see
the “<span class="citetitle">Inter-Client Exchange Library</span>”
standard.
    </p></div></div><div class="chapter" title="Chapter 6. Session Management Server (Sms) Functions"><div class="titlepage"><div><div><h2 class="title"><a id="session_management_server"></a>Chapter 6. Session Management Server (<acronym class="acronym">Sms</acronym>) Functions</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="sect1"><a href="#initializing_the_library">Initializing the Library</a></span></dt><dd><dl><dt><span class="sect2"><a href="#the_register_client_callback">The Register Client Callback</a></span></dt><dt><span class="sect2"><a href="#the_interact_request_callback">The Interact Request Callback</a></span></dt><dt><span class="sect2"><a href="#the_interact_done_callback">The Interact Done Callback</a></span></dt><dt><span class="sect2"><a href="#the_save_yourself_request_callback">The Save Yourself Request Callback</a></span></dt><dt><span class="sect2"><a href="#the_save_yourself_phase_2_request_callback">The Save Yourself Phase 2 Request Callback</a></span></dt><dt><span class="sect2"><a href="#the_save_yourself_done_callback">The Save Yourself Done Callback</a></span></dt><dt><span class="sect2"><a href="#the_connection_closed_callback">The Connection Closed Callback</a></span></dt><dt><span class="sect2"><a href="#the_set_properties_callback">The Set Properties Callback</a></span></dt><dt><span class="sect2"><a href="#the_delete_properties_callback">The Delete Properties Callback</a></span></dt><dt><span class="sect2"><a href="#the_get_properties_callback">The Get Properties Callback</a></span></dt></dl></dd><dt><span class="sect1"><a href="#registering_the_client">Registering the Client</a></span></dt><dt><span class="sect1"><a href="#sending_a_save_yourself_message">Sending a Save Yourself Message</a></span></dt><dt><span class="sect1"><a href="#sending_a_save_yourself_phase_2_message">Sending a Save Yourself Phase 2 Message</a></span></dt><dt><span class="sect1"><a href="#sending_an_interact_message">Sending an Interact Message</a></span></dt><dt><span class="sect1"><a href="#sending_a_save_complete_message">Sending a Save Complete Message</a></span></dt><dt><span class="sect1"><a href="#sending_a_die_message">Sending a Die Message</a></span></dt><dt><span class="sect1"><a href="#cancelling_a_shutdown">Cancelling a Shutdown</a></span></dt><dt><span class="sect1"><a href="#returning_properties">Returning Properties</a></span></dt><dt><span class="sect1"><a href="#pinging_a_client">Pinging a Client</a></span></dt><dt><span class="sect1"><a href="#cleaning_up_after_a_client_disconnects">Cleaning Up After a Client Disconnects</a></span></dt><dt><span class="sect1"><a href="#using_sms_informational_functions">Using Sms Informational Functions</a></span></dt><dt><span class="sect1"><a href="#error_handling2">Error Handling</a></span></dt></dl></div><p>
This section discusses how Session Management servers:

    </p><div class="itemizedlist"><ul class="itemizedlist" type="bullet"><li class="listitem" style="list-style-type: disc"><p>Initialize the library</p></li><li class="listitem" style="list-style-type: disc"><p>Register the client</p></li><li class="listitem" style="list-style-type: disc"><p>Send a “Save Yourself” message</p></li><li class="listitem" style="list-style-type: disc"><p>Send a “Save Yourself Phase 2” message</p></li><li class="listitem" style="list-style-type: disc"><p>Send an “Interact” message</p></li><li class="listitem" style="list-style-type: disc"><p>Send a “Save Complete” message</p></li><li class="listitem" style="list-style-type: disc"><p>Send a “Die” message</p></li><li class="listitem" style="list-style-type: disc"><p>Cancel a shutdown</p></li><li class="listitem" style="list-style-type: disc"><p>Return properties</p></li><li class="listitem" style="list-style-type: disc"><p>Ping a client</p></li><li class="listitem" style="list-style-type: disc"><p>Clean up after a client disconnects</p></li><li class="listitem" style="list-style-type: disc"><p>Use Sms informational functions</p></li><li class="listitem" style="list-style-type: disc"><p>Handle errors</p></li></ul></div><p>
  </p><div class="sect1" title="Initializing the Library"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="initializing_the_library"></a>Initializing the Library</h2></div></div></div><p>
<code class="function">SmsInitialize</code> is the first SMlib function that
should be called by a session manager.  It provides information about
the session manager and registers a callback that will be invoked each
time a new client connects to the session manager.
    </p><div class="funcsynopsis"><p><code class="funcdef">Status <strong>fsfuncSmsInitialize</strong>(</code>char *<var class="pdparam">vendor</var>, char *<var class="pdparam">release</var>, SmsNewClientProc <var class="pdparam">new_client_proc</var>, SmPointer <var class="pdparam">manager_data</var>, IceHostBasedAuthProc <var class="pdparam">host_based_auth_proc</var>, int <var class="pdparam">error_length</var>, char *<var class="pdparam">error_string_ret</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>vendor</code></em></span></p></td><td><p>A string specifying the session manager vendor.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>release</code></em></span></p></td><td><p>A string specifying the session manager release number.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>new_client_proc</code></em></span></p></td><td><p>Callback to be invoked each time a new client connects to the session manager.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>manager_data</code></em></span></p></td><td><p>When the <code class="function">SmsNewClientProc</code> callback is invoked, this pointer to manager data will be passed.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>host_based_auth_proc</code></em></span></p></td><td><p>Host based authentication callback.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>error_length</code></em></span></p></td><td><p>Length of the <em class="parameter"><code>error_string_ret</code></em> argument passed in.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>error_string_ret</code></em></span></p></td><td><p>
Returns a null-terminated error message, if any.
The <em class="parameter"><code>error_string_ret</code></em> points to user supplied memory.
No more than <em class="parameter"><code>error_length</code></em> bytes are used.
    </p></td></tr></tbody></table></div><p>
After the <code class="function">SmsInitialize</code> function is called, the
session manager should call the <code class="function">IceListenForConnections</code>
function to listen for new connections.  Afterwards, each time a
client connects, the session manager should
call <code class="function">IceAcceptConnection</code>
    </p><p>
See <a class="link" href="#authentication_of_clients" title="Chapter 9. Authentication of Clients">section 9,
“Authentication of Clients,”</a> for more details on
authentication (including host based authentication).  Also see
the “<span class="citetitle">Inter-Client Exchange
Library</span>” standard for further details on listening for and
accepting ICE connections.
    </p><p>
Each time a new client connects to the session manager,
the <code class="function">SmsNewClientProc</code> callback is invoked.  The
session manager obtains a new opaque connection object that it should
use for all future interaction with the client.  At this time, the
session manager must also register a set of callbacks to respond to
the different messages that the client might send.
    </p><div class="funcsynopsis"><p><code class="funcdef">typedef Status (*<strong>fsfuncSmsNewClientProc</strong>)(</code>SmsConn <var class="pdparam">sms_conn</var>, SmPointer <var class="pdparam">manager_data</var>, unsigned long *<var class="pdparam">mask_ret</var>, SmsCallbacks *<var class="pdparam">callbacks_ret</var>, char **<var class="pdparam">failure_reason_ret</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>A new opaque connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>manager_data</code></em></span></p></td><td><p>Manager data specified when the callback was registered.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>mask_ret</code></em></span></p></td><td><p>On return, indicates which callbacks were set by the session manager.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>callbacks_ret</code></em></span></p></td><td><p>On return, contains the callbacks registered by the session manager.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>failure_reason_ret</code></em></span></p></td><td><p>Failure reason returned.</p></td></tr></tbody></table></div><p>
If a failure occurs, the <code class="function">SmsNewClientProc</code> should
return a zero status as well as allocate and return a failure reason
string in <em class="parameter"><code>failure_reason_ret</code></em>.
SMlib will be responsible for freeing this memory.
    </p><p>
The session manager must register a set of callbacks to respond to
client events.  The <em class="parameter"><code>mask_ret</code></em> argument specifies
which callbacks are set.  All of the callbacks specified in this version of
SMlib are mandatory.  The <em class="parameter"><code>mask_ret</code></em> argument is
necessary in order to maintain backwards compatibility in future versions
of the library.
    </p><p>
The following values may be ORed together to obtain a mask value:

      </p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="constant">SmsRegisterClientProcMask</code></td></tr><tr><td><code class="constant">SmsInteractRequestProcMask</code></td></tr><tr><td><code class="constant">SmsInteractDoneProcMask</code></td></tr><tr><td><code class="constant">SmsSaveYourselfRequestProcMask</code></td></tr><tr><td><code class="constant">SmsSaveYourselfP2RequestProcMask</code></td></tr><tr><td><code class="constant">SmsSaveYourselfDoneProcMask</code></td></tr><tr><td><code class="constant">SmsCloseConnectionProcMask</code></td></tr><tr><td><code class="constant">SmsSetPropertiesProcMask</code></td></tr><tr><td><code class="constant">SmsDeletePropertiesProcMask</code></td></tr><tr><td><code class="constant">SmsGetPropertiesProcMask</code></td></tr></table><p>
    </p><p>
For each callback, the session manager can register a pointer to
manager data specific to that callback.  This pointer will be passed
to the callback when it is invoked by SMlib.
    </p><pre class="synopsis">
typedef struct {
	struct {
		SmsRegisterClientProc callback;
		SmPointer manager_data;
	} register_client;

	struct {
		SmsInteractRequestProc callback;
		SmPointer manager_data;
	} interact_request;

	struct {
		SmsInteractDoneProc callback;
		SmPointer manager_data;
	} interact_done;

	struct {
		SmsSaveYourselfRequestProc callback;
		SmPointer manager_data;
	} save_yourself_request;

	struct {
		SmsSaveYourselfPhase2RequestProc callback;
		SmPointer manager_data;
	} save_yourself_phase2_request;

	struct {
		SmsSaveYourselfDoneProc callback;
		SmPointer manager_data;
	} save_yourself_done;

	struct {
		SmsCloseConnectionProc callback;
		SmPointer manager_data;
	} close_connection;

	struct {
		SmsSetPropertiesProc callback;
		SmPointer manager_data;
	} set_properties;

	struct {
		SmsDeletePropertiesProc callback;
		SmPointer manager_data;
	} delete_properties;

	struct {
		SmsGetPropertiesProc callback;
		SmPointer manager_data;
	} get_properties;

} SmsCallbacks;
</pre><div class="sect2" title="The Register Client Callback"><div class="titlepage"><div><div><h3 class="title"><a id="the_register_client_callback"></a>The Register Client Callback</h3></div></div></div><p>
The Register Client callback is the first callback that will be
invoked after the client connects to the session manager.  Its type
is <code class="function">SmsRegisterClientProc</code>
      </p><div class="funcsynopsis"><p><code class="funcdef">typedef Status (*<strong>fsfuncSmsRegisterClientProc</strong>)(</code>SmsConn <var class="pdparam">sms_conn</var>, SmPointer <var class="pdparam">manager_data</var>, char *<var class="pdparam">previous_id</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>manager_data</code></em></span></p></td><td><p>Manager data specified when the callback was registered.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>previous_id</code></em></span></p></td><td><p>The client ID from the previous session.</p></td></tr></tbody></table></div><p>
Before any further interaction takes place with the client, the client
must be registered with the session manager.
      </p><p>
If the client is being restarted from a previous session,
<em class="parameter"><code>previous_id</code></em> will contain a null-terminated string
representing the client ID from the previous session.
Call <code class="function">free</code> on the <em class="parameter"><code>previous_id</code></em>
pointer when it is no longer needed.  If the client is first joining the
session, <em class="parameter"><code>previous_id</code></em> will be <code class="constant">NULL</code>.
      </p><p>
If <em class="parameter"><code>previous_id</code></em> is invalid, the session manager should
not register the client at this time.  This callback should return a status
of zero, which will cause an error message to be sent to the client.  The
client should re-register with previous_id set to <code class="constant">NULL</code>.
      </p><p>
Otherwise, the session manager should register the client with a unique
client ID by calling the <code class="function">SmsRegisterClientReply</code>
function (to be discussed shortly), and the
<code class="function">SmsRegisterClientProc</code> callback should return a
status of one.
      </p></div><div class="sect2" title="The Interact Request Callback"><div class="titlepage"><div><div><h3 class="title"><a id="the_interact_request_callback"></a>The Interact Request Callback</h3></div></div></div><p>
The Interact Request callback is of
type <code class="function">SmsInteractRequestProc</code>
      </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSmsInteractRequestProc</strong>)(</code>SmsConn <var class="pdparam">sms_conn</var>, SmPointer <var class="pdparam">manager_data</var>, int <var class="pdparam">dialog_type</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>manager_data</code></em></span></p></td><td><p>Manager data specified when the callback was registered.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>dialog_type</code></em></span></p></td><td><p>The type of dialog the client wishes to present to the user.</p></td></tr></tbody></table></div><p>
When a client receives a “Save Yourself” message with an
<em class="parameter"><code>interact_style</code></em> of
<code class="constant">SmInteractStyleErrors</code>
or <code class="constant">SmInteractStyleAny</code> the client may choose to
interact with the user.  Because only one client can interact with the
user at a time, the client must request to interact with the user.
The session manager should keep a queue of all clients wishing to
interact.  It should send an “Interact” message to one
client at a time and wait for an “Interact Done” message
before continuing with the next client.
      </p><p>
The <em class="parameter"><code>dialog_type</code></em> argument specifies
either <code class="constant">SmDialogError</code> indicating that the client
wants to start an error dialog, or <code class="constant">SmDialogNormal</code>
meaning that the client wishes to start a nonerror dialog.
      </p><p>
If a shutdown is in progress, the user may have the option of
cancelling the shutdown.  If the shutdown is cancelled (specified in
the “Interact Done” message), the session manager should
send a “Shutdown Cancelled” message to each client that
requested to interact.
      </p></div><div class="sect2" title="The Interact Done Callback"><div class="titlepage"><div><div><h3 class="title"><a id="the_interact_done_callback"></a>The Interact Done Callback</h3></div></div></div><p>
When the client is done interacting with the user,
the <code class="function">SmsInteractDoneProc</code> callback will be invoked.
      </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSmsInteractDoneProc</strong>)(</code>SmsConn <var class="pdparam">sms_conn</var>, SmPointer <var class="pdparam">manager_data</var>, Bool <var class="pdparam">cancel_shutdown</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>manager_data</code></em></span></p></td><td><p>Manager data specified when the callback was registered.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>cancel_shutdown</code></em></span></p></td><td><p>Specifies if the user requests that the entire shutdown be cancelled.</p></td></tr></tbody></table></div><p>
Note that the shutdown can be cancelled only if the corresponding
“Save Yourself” specified <code class="constant">True</code> for
shutdown and <code class="constant">SmInteractStyleErrors</code>
or <code class="constant">SmInteractStyleAny</code> for the
<em class="parameter"><code>interact_style</code></em>.
      </p></div><div class="sect2" title="The Save Yourself Request Callback"><div class="titlepage"><div><div><h3 class="title"><a id="the_save_yourself_request_callback"></a>The Save Yourself Request Callback</h3></div></div></div><p>
The Save Yourself Request callback is of
type <code class="function">SmsSaveYourselfRequestProc</code>
      </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSaveYourselfRequestProc</strong>)(</code>SmsConn <var class="pdparam">sms_conn</var>, SmPointer <var class="pdparam">manager_data</var>, int <var class="pdparam">save_type</var>, Bool <var class="pdparam">shutdown</var>, int <var class="pdparam">interact_style</var>, Bool <var class="pdparam">fast</var>, Bool <var class="pdparam">global</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>manager_data</code></em></span></p></td><td><p>Manager data specified when the callback was registered.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>save_type</code></em></span></p></td><td><p>Specifies the type of information that should be saved.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>shutdown</code></em></span></p></td><td><p>Specifies if a shutdown is taking place.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>interact_style</code></em></span></p></td><td><p>The type of interaction allowed with the user.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>fast</code></em></span></p></td><td><p>If <code class="constant">True</code> the client should save its state as quickly as possible.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>global</code></em></span></p></td><td><p>Controls who gets the “Save Yourself.”</p></td></tr></tbody></table></div><p>
The Save Yourself Request prompts the session manager to initiate a
checkpoint or shutdown.  For information on the
<em class="parameter"><code>save_type</code></em>, <em class="parameter"><code>shutdown</code></em>,
<em class="parameter"><code>interact_style</code></em>, and <em class="parameter"><code>fast</code></em>
arguments, see <a class="link" href="#sending_a_save_yourself_message" title="Sending a Save Yourself Message">section 6.3,
“Sending a Save Yourself Message.”</a>
      </p><p>
If <em class="parameter"><code>global</code></em> is set to <code class="constant">True</code> then the
resulting “Save Yourself” should be sent to all applications.
If <em class="parameter"><code>global</code></em> is set to <code class="constant">False</code> then the
“Save Yourself” should only be sent to the client that requested it.
      </p></div><div class="sect2" title="The Save Yourself Phase 2 Request Callback"><div class="titlepage"><div><div><h3 class="title"><a id="the_save_yourself_phase_2_request_callback"></a>The Save Yourself Phase 2 Request Callback</h3></div></div></div><p>
The Save Yourself Phase 2 Request callback is of
type <code class="function">SmsSaveYourselfPhase2RequestProc</code>
      </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSmsSaveYourselfPhase2RequestProc</strong>)(</code>SmsConn <var class="pdparam">sms_conn</var>, SmPointer <var class="pdparam">manager_data</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>manager_data</code></em></span></p></td><td><p>Manager data specified when the callback was registered.</p></td></tr></tbody></table></div><p>
This request is sent by clients that manage other clients (for
example, window managers, workspace managers, and so on).  Such
managers must make sure that all of the clients that are being managed
are in an idle state so that their state can be saved.
      </p></div><div class="sect2" title="The Save Yourself Done Callback"><div class="titlepage"><div><div><h3 class="title"><a id="the_save_yourself_done_callback"></a>The Save Yourself Done Callback</h3></div></div></div><p>
When the client is done saving its state in response to a
“Save Yourself” message,
the <code class="function">SmsSaveYourselfDoneProc</code> will be invoked.
      </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSaveYourselfDoneProc</strong>)(</code>SmsConn <var class="pdparam">sms_conn</var>, SmPointer <var class="pdparam">manager_data</var>, Bool <var class="pdparam">success</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>manager_data</code></em></span></p></td><td><p>Manager data specified when the callback was registered.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>success</code></em></span></p></td><td><p>If <code class="constant">True</code> the Save Yourself operation was completed successfully.</p></td></tr></tbody></table></div><p>
Before the “Save Yourself Done” was sent, the client must
have set each required property at least once since it registered with
the session manager.
      </p></div><div class="sect2" title="The Connection Closed Callback"><div class="titlepage"><div><div><h3 class="title"><a id="the_connection_closed_callback"></a>The Connection Closed Callback</h3></div></div></div><p>
If the client properly terminates (that is, it
calls <code class="function">SmcCloseConnection</code>,
the <code class="function">SmsCloseConnectionProc</code> callback is invoked.
      </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSmsCloseConnectionProc</strong>)(</code>SmsConn <var class="pdparam">sms_conn</var>, SmPointer <var class="pdparam">manager_data</var>, int <var class="pdparam">count</var>, char **<var class="pdparam">reason_msgs</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>manager_data</code></em></span></p></td><td><p>Manager data specified when the callback was registered.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>count</code></em></span></p></td><td><p>The number of reason messages.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>reason_msgs</code></em></span></p></td><td><p>The reasons for closing the connection.</p></td></tr></tbody></table></div><p>
The <em class="parameter"><code>reason_msgs</code></em> argument will most likely
be <code class="constant">NULL</code> and the <em class="parameter"><code>count</code></em>
argument zero (0) if resignation is expected by the user.  Otherwise,
it contains a list of null-terminated Compound Text strings
representing the reason for termination.  The session manager should
display these reason messages to the user.
      </p><p>
Call <code class="function">SmFreeReasons</code> to free the reason messages.
For further information, see
<a class="link" href="#freeing_data" title="Chapter 8. Freeing Data">section 8, “Freeing Data”</a>
      </p></div><div class="sect2" title="The Set Properties Callback"><div class="titlepage"><div><div><h3 class="title"><a id="the_set_properties_callback"></a>The Set Properties Callback</h3></div></div></div><p>
When the client sets session management properties,
the <code class="function">SmsSetPropertiesProc</code> callback will be invoked.
      </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSmsSetPropertiesProc</strong>)(</code>SmsConn <var class="pdparam">sms_conn</var>, SmPointer <var class="pdparam">manager_data</var>, int <var class="pdparam">num_props</var>, SmProp **<var class="pdparam">props</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>manager_data</code></em></span></p></td><td><p>Manager data specified when the callback was registered.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>num_props</code></em></span></p></td><td><p>The number of properties.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>props</code></em></span></p></td><td><p>The list of properties to set.</p></td></tr></tbody></table></div><p>
The properties are specified as an array of property pointers.  For a
description of session management properties and
the <span class="structname">SmProp</span> structure,
see <a class="link" href="#session_management_properties" title="Chapter 7. Session Management Properties">section 7,
“Session Management Properties.”</a>
      </p><p>
Previously set property values may be over-written.  Some properties
have predefined semantics.  The session manager is required to store
nonpredefined properties.
      </p><p>
To free each property, use <code class="function">SmFreeProperty</code>.
For further information, see <a class="link" href="#freeing_data" title="Chapter 8. Freeing Data">section 8,
“Freeing Data”</a> You should free the actual array of
pointers with a call to <code class="function">free</code>
      </p></div><div class="sect2" title="The Delete Properties Callback"><div class="titlepage"><div><div><h3 class="title"><a id="the_delete_properties_callback"></a>The Delete Properties Callback</h3></div></div></div><p>
When the client deletes session management properties,
the <code class="function">SmsDeletePropertiesProc</code> callback will be invoked.
      </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSmsDeletePropertiesProc</strong>)(</code>SmsConn <var class="pdparam">sms_conn</var>, SmPointer <var class="pdparam">manager_data</var>, int <var class="pdparam">num_props</var>, char **<var class="pdparam">prop_names</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>manager_data</code></em></span></p></td><td><p>Manager data specified when the callback was registered.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>num_props</code></em></span></p></td><td><p>The number of properties.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>prop_names</code></em></span></p></td><td><p>The list of properties to delete.</p></td></tr></tbody></table></div><p>
The properties are specified as an array of strings.  For a
description of session management properties and
the <span class="structname">SmProp</span> structure,
see <a class="link" href="#session_management_properties" title="Chapter 7. Session Management Properties">section 7,
“Session Management Properties.”</a>
      </p></div><div class="sect2" title="The Get Properties Callback"><div class="titlepage"><div><div><h3 class="title"><a id="the_get_properties_callback"></a>The Get Properties Callback</h3></div></div></div><p>
The <code class="function">SmsGetPropertiesProc</code> callback is invoked when
the client wants to retrieve properties it set.
      </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSmsGetPropertiesProc</strong>)(</code>SmsConn <var class="pdparam">sms_conn</var>, SmPointer <var class="pdparam">manager_data</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>manager_data</code></em></span></p></td><td><p>Manager data specified when the callback was registered.</p></td></tr></tbody></table></div><p>
The session manager should respond by
calling <code class="function">SmsReturnProperties</code>.
All of the properties set for this client should be returned.
      </p></div></div><div class="sect1" title="Registering the Client"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="registering_the_client"></a>Registering the Client</h2></div></div></div><p>
To register a client (in response to
a <code class="function">SmsRegisterClientProc</code> callback),
use <code class="function">SmsRegisterClientReply</code>.
    </p><div class="funcsynopsis"><p><code class="funcdef">Status <strong>fsfuncSmsRegisterClientReply</strong>(</code>SmsConn <var class="pdparam">sms_conn</var>, char *<var class="pdparam">client_id</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>client_id</code></em></span></p></td><td><p>A null-terminated string representing a unique client ID.</p></td></tr></tbody></table></div><p>
The return value of <code class="function">SmsRegisterClientReply</code> is
zero for failure and a positive value for success.  Failure will occur
if SMlib can not allocate memory to hold a copy of the client ID for
it's own internal needs.
    </p><p>
If a non-<code class="constant">NULL</code> <em class="parameter"><code>previous_id</code></em> was
specified when the client registered itself, <em class="parameter"><code>client_id</code></em>
should be identical to <em class="parameter"><code>previous_id</code></em>.
    </p><p>
Otherwise, <em class="parameter"><code>client_id</code></em> should be a unique ID freshly
generated by the session manager.  In addition, the session manager should
send a “Save Yourself” message with
<em class="parameter"><code>type</code></em> = <code class="constant">Local</code>,
<em class="parameter"><code>shutdown</code></em> = <code class="constant">False</code>,
<em class="parameter"><code>interact-style</code></em> = <code class="constant">None</code>,
and <em class="parameter"><code>fast</code></em> = <code class="constant">False</code>
immediately after registering the client.
    </p><p>
Note that once a client ID has been assigned to the client, the client
keeps this ID indefinitely.  If the client is terminated and
restarted, it will be reassigned the same ID.  It is desirable to be
able to pass client IDs around from machine to machine, from user to
user, and from session manager to session manager, while retaining the
identity of the client.  This, combined with the indefinite
persistence of client IDs, means that client IDs need to be globally
unique.
    </p><p>
You should call the <code class="function">SmsGenerateClientID</code> function
to generate a globally unique client ID.
    </p><div class="funcsynopsis"><p><code class="funcdef">char *<strong>fsfuncSmsGenerateClientID</strong>(</code>SmsConn <var class="pdparam">sms_conn</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr></tbody></table></div><p>
<code class="constant">NULL</code> will be returned if the ID could not be generated.
Otherwise, the return value of the function is the client ID.
It should be freed with a call to <code class="function">free</code> when
no longer needed.
    </p></div><div class="sect1" title="Sending a Save Yourself Message"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sending_a_save_yourself_message"></a>Sending a Save Yourself Message</h2></div></div></div><p>
To send a “Save Yourself” to a client,
use <code class="function">SmsSaveYourself</code>.
    </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncSmsSaveYourself</strong>(</code>SmsConn <var class="pdparam">sms_conn</var>, int <var class="pdparam">save_type</var>, Bool <var class="pdparam">shutdown</var>, int <var class="pdparam">interact_style</var>, Bool <var class="pdparam">fast</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>save_type</code></em></span></p></td><td><p>Specifies the type of information that should be saved.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>shutdown</code></em></span></p></td><td><p>Specifies if a shutdown is taking place.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>interact_style</code></em></span></p></td><td><p>The type of interaction allowed with the user.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>fast</code></em></span></p></td><td><p>If <code class="constant">True</code> the client should save its state as quickly as possible.</p></td></tr></tbody></table></div><p>
The session manager sends a “Save Yourself” message to a
client either to checkpoint it or just before termination so that it
can save its state.  The client responds with zero or more “Set
Properties” messages to update the properties indicating how to
restart the client.  When all the properties have been set, the client
sends a “Save Yourself Done” message.
    </p><p>
If <em class="parameter"><code>interact_style</code></em>
is <code class="constant">SmInteractStyleNone</code> the
client must not interact with the user while saving state.
If <em class="parameter"><code>interact_style</code></em>
is <code class="constant">SmInteractStyleErrors</code> the
client may interact with the user only if an error condition arises.
If <em class="parameter"><code>interact_style</code></em>
is <code class="constant">SmInteractStyleAny</code> then the
client may interact with the user for any purpose.  The client must
send an “Interact Request” message and wait for an
“Interact” message from the session manager before it can
interact with the user.  When the client is done interacting with the
user, it should send an “Interact Done” message.  The
“Interact Request” message can be sent any time after a
“Save Yourself” and before a “Save Yourself
Done.”
    </p><p>
If <em class="parameter"><code>save_type</code></em> is <code class="constant">SmSaveLocal</code>
the client must update the properties to reflect its current state.
Specifically, it should save enough information to restore the state as
seen by the user of this client.  It should not affect the state as seen
by other users.
If <em class="parameter"><code>save_type</code></em> is <code class="constant">SmSaveGlobal</code>
the user wants the client to commit all of its data to permanent, globally
accessible storage.
If <em class="parameter"><code>save_type</code></em> is <code class="constant">SmSaveBoth</code>
the client should do both of these (it should first commit the data to
permanent storage before updating its properties).
    </p><p>
The <em class="parameter"><code>shutdown</code></em> argument specifies whether the session
is being shut down.  The interaction is different depending on whether or not
shutdown is set.  If not shutting down, then the client can save and
resume normal operation.  If shutting down, the client must save and
then must prevent interaction until it receives either a
“Die” or a “Shutdown Cancelled,” because
anything the user does after the save will be lost.
    </p><p>
The <em class="parameter"><code>fast</code></em> argument specifies that the client should
save its state as quickly as possible.  For example, if the session manager
knows that power is about to fail, it should set <em class="parameter"><code>fast</code></em>
to <code class="constant">True</code>.
    </p></div><div class="sect1" title="Sending a Save Yourself Phase 2 Message"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sending_a_save_yourself_phase_2_message"></a>Sending a Save Yourself Phase 2 Message</h2></div></div></div><p>
In order to send a “Save Yourself Phase 2” message to a
client, use <code class="function">SmsSaveYourselfPhase2</code>
    </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncSmsSaveYourselfPhase2</strong>(</code>SmsConn <var class="pdparam">sms_conn</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr></tbody></table></div><p>
The session manager sends this message to a client that has previously
sent a “Save Yourself Phase 2 Request” message.  This
message informs the client that all other clients are in a fixed state
and this client can save state that is associated with other clients.
    </p></div><div class="sect1" title="Sending an Interact Message"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sending_an_interact_message"></a>Sending an Interact Message</h2></div></div></div><p>
To send an “Interact” message to a client,
use <code class="function">SmsInteract</code>.
    </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncSmsInteract</strong>(</code>SmsConn <var class="pdparam">sms_conn</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr></tbody></table></div><p>
The “Interact” message grants the client the privilege of
interacting with the user.  When the client is done interacting with
the user, it must send an “Interact Done” message to the
session manager.
    </p></div><div class="sect1" title="Sending a Save Complete Message"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sending_a_save_complete_message"></a>Sending a Save Complete Message</h2></div></div></div><p>
To send a “Save Complete” message to a client,
use <code class="function">SmsSaveComplete</code>.
    </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncSmsSaveComplete</strong>(</code>SmsConn <var class="pdparam">sms_conn</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr></tbody></table></div><p>
The session manager sends this message when it is done with a
checkpoint.  The client is then free to change its state.
    </p></div><div class="sect1" title="Sending a Die Message"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sending_a_die_message"></a>Sending a Die Message</h2></div></div></div><p>
To send a “Die” message to a client,
use <code class="function">SmsDie</code>.
    </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncSmsDie</strong>(</code>SmsConn <var class="pdparam">sms_conn</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr></tbody></table></div><p>
Before the session manager terminates, it should wait for a
“Connection Closed” message from each client that it sent
a “Die” message to, timing out appropriately.
    </p></div><div class="sect1" title="Cancelling a Shutdown"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="cancelling_a_shutdown"></a>Cancelling a Shutdown</h2></div></div></div><p>
To cancel a shutdown, use <code class="function">SmsShutdownCancelled</code>.
    </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncSmsShutdownCancelled</strong>(</code>SmsConn <var class="pdparam">sms_conn</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr></tbody></table></div><p>
The client can now continue as if the shutdown had never happened.  If
the client has not sent a “Save Yourself Done” message
yet, it can either abort the save and send a “Save Yourself
Done” with the success argument set to <code class="constant">False</code>
or it can continue with the save and send a “Save Yourself Done”
with the <em class="parameter"><code>success</code></em> argument set to reflect the outcome
of the save.
    </p></div><div class="sect1" title="Returning Properties"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="returning_properties"></a>Returning Properties</h2></div></div></div><p>
In response to a “Get Properties” message, the session
manager should call <code class="function">SmsReturnProperties</code>.
    </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncSmsReturnProperties</strong>(</code>SmsConn <var class="pdparam">sms_conn</var>, int <var class="pdparam">num_props</var>, SmProp **<var class="pdparam">props</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>num_props</code></em></span></p></td><td><p>The number of properties.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>props</code></em></span></p></td><td><p>The list of properties to return to the client.</p></td></tr></tbody></table></div><p>
The properties are returned as an array of property pointers.  For a
description of session management properties and
the <span class="structname">SmProp</span> structure,
see <a class="link" href="#session_management_properties" title="Chapter 7. Session Management Properties">section 7,
“Session Management Properties.”</a>
    </p></div><div class="sect1" title="Pinging a Client"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="pinging_a_client"></a>Pinging a Client</h2></div></div></div><p>
To check that a client is still alive, you should use
the <code class="function">IcePing</code> function provided by the ICE library.
To do so, the ICE connection must be obtained using
the <code class="function">SmsGetIceConnection</code>
(see <a class="link" href="#using_sms_informational_functions" title="Using Sms Informational Functions">section 6.12,
“Using Sms Informational Functions”</a>).
    </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncIcePing</strong>(</code>IceConn <var class="pdparam">ice_conn</var>, IcePingReplyProc <var class="pdparam">ping_reply_proc</var>, IcePointer <var class="pdparam">client_data</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>ice_conn</code></em></span></p></td><td><p>A valid ICE connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>ping_reply_proc</code></em></span></p></td><td><p>The callback to invoke when the Ping reply arrives.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>client_data</code></em></span></p></td><td><p>This pointer will be passed to the <code class="function">IcePingReplyProc</code> callback.</p></td></tr></tbody></table></div><p>
When the Ping reply is ready (if ever),
the <code class="function">IcePingReplyProc</code> callback will be invoked.  A
session manager should have some sort of timeout period, after which
it assumes the client has unexpectedly died.
    </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncIcePingReplyProc</strong>)(</code>IceConn <var class="pdparam">ice_conn</var>, IcePointer <var class="pdparam">client_data</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>ice_conn</code></em></span></p></td><td><p>A valid ICE connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>client_data</code></em></span></p></td><td><p>The client data specified in the call to <code class="function">IcePing</code></p></td></tr></tbody></table></div></div><div class="sect1" title="Cleaning Up After a Client Disconnects"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="cleaning_up_after_a_client_disconnects"></a>Cleaning Up After a Client Disconnects</h2></div></div></div><p>
When the session manager receives a “Connection Closed”
message or otherwise detects that the client aborted the connection,
it should call the <code class="function">SmsCleanUp</code> function in order
to free up the connection object.
    </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncSmsCleanUp</strong>(</code>SmsConn <var class="pdparam">sms_conn</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr></tbody></table></div></div><div class="sect1" title="Using Sms Informational Functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="using_sms_informational_functions"></a>Using Sms Informational Functions</h2></div></div></div><div class="funcsynopsis"><p><code class="funcdef">int <strong>fsfuncSmsProtocolVersion</strong>(</code>SmsConn <var class="pdparam">sms_conn</var><code>)</code>;</p></div><p>
<code class="function">SmsProtocolVersion</code> returns the major version of
the session management protocol associated with this session.
    </p><div class="funcsynopsis"><p><code class="funcdef">int <strong>fsfuncSmsProtocolRevision</strong>(</code>SmsConn <var class="pdparam">sms_conn</var><code>)</code>;</p></div><p>
<code class="function">SmsProtocolRevision</code> returns the minor version of
the session management protocol associated with this session.
    </p><div class="funcsynopsis"><p><code class="funcdef">char *<strong>fsfuncSmsClientID</strong>(</code>SmsConn <var class="pdparam">sms_conn</var><code>)</code>;</p></div><p>
<code class="function">SmsClientID</code> returns a null-terminated string for
the client ID associated with this connection.  You should
call <code class="function">free</code> on this pointer when the client ID is
no longer needed.
    </p><p>
To obtain the host name of a client,
use <code class="function">SmsClientHostName</code>.
This host name will be needed to restart the client.
    </p><div class="funcsynopsis"><p><code class="funcdef">char *<strong>fsfuncSmsClientHostName</strong>(</code>SmsConn <var class="pdparam">sms_conn</var><code>)</code>;</p></div><p>
The string returned is of the form
<em class="parameter"><code>protocol</code></em><code class="literal">/</code><em class="parameter"><code>hostname</code></em>,
where <em class="parameter"><code>protocol</code></em> is one of
{<code class="literal">tcp</code>, <code class="literal">decnet</code>, <code class="literal">local</code>}.
You should call <code class="function">free</code> on the string returned when
it is no longer needed.
    </p><div class="funcsynopsis"><p><code class="funcdef">IceConn <strong>fsfuncSmsGetIceConnection</strong>(</code>SmsConn <var class="pdparam">sms_conn</var><code>)</code>;</p></div><p>
<code class="function">SmsGetIceConnection</code> returns the ICE connection
object associated with this session management connection object.  The
ICE connection object can be used to get some additional information
about the connection.  Some of the more useful functions which can be
used on the IceConn are <code class="function">IceConnectionNumber</code>
and <code class="function">IceLastSequenceNumber</code>.
For further information, see the
“<span class="citetitle">Inter-Client Exchange Library</span>”
standard.
    </p></div><div class="sect1" title="Error Handling"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="error_handling2"></a>Error Handling</h2></div></div></div><p>
If the session manager receives an unexpected protocol error from a
client, an error handler is invoked by SMlib.  A default error handler
exists which simply prints the error message (it does not exit).  The
session manager can change this error handler by
calling <code class="function">SmsSetErrorHandler</code>.
    </p><div class="funcsynopsis"><p><code class="funcdef">SmsErrorHandler <strong>fsfuncSmsSetErrorHandler</strong>(</code>SmsErrorHandler <var class="pdparam">handler</var><code>)</code>;</p></div><p>
The error handler.  You should pass <code class="constant">NULL</code>
to restore the default handler.
    </p><p>
<code class="function">SmsSetErrorHandler</code> returns the previous error handler.
The <code class="function">SmsErrorHandler</code> has the following type:
    </p><div class="funcsynopsis"><p><code class="funcdef">typedef void (*<strong>fsfuncSmsErrorHandler</strong>)(</code>SmsConn <var class="pdparam">sms_conn</var>, Bool <var class="pdparam">swap</var>, int <var class="pdparam">offending_minor_opcode</var>, unsigned long <var class="pdparam">offending_sequence_num</var>, int <var class="pdparam">error_class</var>, int <var class="pdparam">severity</var>, IcePointer <var class="pdparam">values</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>sms_conn</code></em></span></p></td><td><p>The session management connection object.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>swap</code></em></span></p></td><td><p>A flag which indicates if the specified values need byte swapping.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>offending_minor_opcode</code></em></span></p></td><td><p>The minor opcode of the offending message.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>offending_sequence_num</code></em></span></p></td><td><p>The sequence number of the offending message.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>error_class</code></em></span></p></td><td><p>The error class of the offending message.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>severity</code></em></span></p></td><td><p>
	<code class="constant">IceCanContinue</code>,
	<code class="constant">IceFatalToProtocol</code>, or
	<code class="constant">IceFatalToConnection</code>
    </p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>values</code></em></span></p></td><td><p>Any additional error values specific to the minor opcode and class.</p></td></tr></tbody></table></div><p>
Note that this error handler is invoked for protocol related errors.
To install an error handler to be invoked when an IO error occurs,
use <code class="function">IceSetIOErrorHandler</code>.
For further information, see the
“<span class="citetitle">Inter-Client Exchange Library</span>”
standard.
    </p></div></div><div class="chapter" title="Chapter 7. Session Management Properties"><div class="titlepage"><div><div><h2 class="title"><a id="session_management_properties"></a>Chapter 7. Session Management Properties</h2></div></div></div><p>
Each property is defined by the <span class="structname">SmProp</span> structure:

</p><pre class="synopsis">
typedef struct {
	char *name;	/* name of property */
	char *type;	/* type of property */
	int num_vals;	/* number of values */
	SmPropValue *vals;	/* the list of values */
} SmProp;

typedef struct {
	int length;	/* the length of the value */
	SmPointer value;	/* the value */
} SmPropValue;
</pre><p>
  </p><p>
The X Session Management Protocol defines a list of predefined
properties, several of which are required to be set by the client.
The following table specifies the predefined properties and indicates
which ones are required.  Each property has a type associated with it.
  </p><p>
A type of <span class="type">SmCARD8</span> indicates that there is a single 1-byte value.
A type of <span class="type">SmARRAY8</span> indicates that there is a single array of bytes.
A type of <span class="type">SmLISTofARRAY8</span> indicates that there is a list of array of
bytes.
  </p><div class="informaltable"><table border="0"><colgroup><col align="center" class="c1" /><col align="center" class="c2" /><col align="center" class="c3" /><col align="center" class="c4" /></colgroup><thead><tr><th align="left">Name</th><th align="left">Type</th><th align="left"><acronym class="acronym">POSIX</acronym> Type</th><th align="center">Required</th></tr></thead><tbody><tr><td align="left"><span class="property">SmCloneCommand</span></td><td align="left">OS-specific</td><td align="left"><span class="type">SmLISTofARRAY8</span></td><td align="center">Yes</td></tr><tr><td align="left"><span class="property">SmCurrentDirectory</span></td><td align="left">OS-specific</td><td align="left"><span class="type">SmARRAY8</span></td><td align="center">No</td></tr><tr><td align="left"><span class="property">SmDiscardCommand</span></td><td align="left">OS-specific</td><td align="left"><span class="type">SmLISTofARRAY8</span></td><td align="center">No*</td></tr><tr><td align="left"><span class="property">SmEnvironment</span></td><td align="left">OS-specific</td><td align="left"><span class="type">SmLISTofARRAY8</span></td><td align="center">No</td></tr><tr><td align="left"><span class="property">SmProcessID</span></td><td align="left">OS-specific</td><td align="left"><span class="type">SmARRAY8</span></td><td align="center">No</td></tr><tr><td align="left"><span class="property">SmProgram</span></td><td align="left">OS-specific</td><td align="left"><span class="type">SmARRAY8</span></td><td align="center">Yes</td></tr><tr><td align="left"><span class="property">SmRestartCommand</span></td><td align="left">OS-specific</td><td align="left"><span class="type">SmLISTofARRAY8</span></td><td align="center">Yes</td></tr><tr><td align="left"><span class="property">SmResignCommand</span></td><td align="left">OS-specific</td><td align="left"><span class="type">SmLISTofARRAY8</span></td><td align="center">No</td></tr><tr><td align="left"><span class="property">SmRestartStyleHint</span></td><td align="left"><span class="type">SmCARD8</span></td><td align="left"><span class="type">SmCARD8</span></td><td align="center">No</td></tr><tr><td align="left"><span class="property">SmShutdownCommand</span></td><td align="left">OS-specific</td><td align="left"><span class="type">SmLISTofARRAY8</span></td><td align="center">No</td></tr><tr><td align="left"><span class="property">SmUserID</span></td><td align="left"><span class="type">SmARRAY8</span></td><td align="left"><span class="type">SmARRAY8</span></td><td align="center">Yes</td></tr></tbody></table></div><p>
* Required if any state is stored in an external repository (for
example, state file).
  </p><div class="itemizedlist"><ul class="itemizedlist" type="bullet"><li class="listitem" style="list-style-type: disc"><p><span class="property">SmCloneCommand</span></p><p>
This is like the <span class="property">SmRestartCommand</span>, except it restarts a
copy of the application.  The only difference is that the application does not
supply its client ID at register time.  On <acronym class="acronym">POSIX</acronym> systems,
this should be of type <span class="type">SmLISTofARRAY8</span>.
    </p></li><li class="listitem" style="list-style-type: disc"><p><span class="property">SmCurrentDirectory</span></p><p>
On <acronym class="acronym">POSIX</acronym>-based systems, this specifies the value of the
current directory that needs to be set up prior to starting the
<span class="property">SmProgram</span> and should of type <span class="type">SmARRAY8</span>.
    </p></li><li class="listitem" style="list-style-type: disc"><p><span class="property">SmDiscardCommand</span></p><p>
The discard command contains a command that when delivered to the host
that the client is running on (determined from the connection), will
cause it to discard any information about the current state.  If this
command is not specified, the Session Manager will assume that all of
the client's state is encoded in the <span class="property">SmRestartCommand</span>.
On <acronym class="acronym">POSIX</acronym> systems, the type should be
<span class="type">SmLISTofARRAY8</span>.
    </p></li><li class="listitem" style="list-style-type: disc"><p><span class="property">SmEnvironment</span></p><p>
On <acronym class="acronym">POSIX</acronym> based systems, this will be of type
<span class="type">SmLISTofARRAY8</span>, where the <span class="type">ARRAY8</span>s alternate between
environment variable name and environment variable value.
    </p></li><li class="listitem" style="list-style-type: disc"><p><span class="property">SmProcessID</span></p><p>
This specifies an OS-specific identifier for the process.
On <acronym class="acronym">POSIX</acronym> systems, this should contain the return value
of <code class="function">getpid</code> turned into a Latin-1 (decimal) string.
    </p></li><li class="listitem" style="list-style-type: disc"><p><span class="property">SmProgram</span></p><p>
This is the name of the program that is running.  On <acronym class="acronym">POSIX</acronym>
systems, this should be first parameter passed to <code class="function">execve</code>
and should be of type <span class="type">SmARRAY8</span>.
    </p></li><li class="listitem" style="list-style-type: disc"><p><span class="property">SmRestartCommand</span></p><p>
The restart command contains a command that, when delivered to the
host that the client is running on (determined from the connection),
will cause the client to restart in its current state.
On <acronym class="acronym">POSIX</acronym>-based systems, this is of
type <span class="type">SmLISTofARRAY8</span>, and each of the elements in
the array represents an element in the <code class="varname">argv</code>
array.  This restart command should ensure that the client restarts
with the specified client-ID.
    </p></li><li class="listitem" style="list-style-type: disc"><p><span class="property">SmResignCommand</span></p><p>
A client that sets the <span class="property">SmRestartStyleHint</span>
to <code class="constant">SmRestartAnyway</code> uses this property to specify a
command that undoes the effect of the client and removes any saved state.
As an example, consider a user that runs <span class="command"><strong>xmodmap</strong></span> which
registers with the Session Manager,
sets <span class="property">SmRestartStyleHint</span>
to <code class="constant">SmRestartAnyway</code>, and then
terminates.  To allow the Session Manager (at the user's request) to
undo this, <span class="command"><strong>xmodmap</strong></span> would register a
<span class="property">SmResignCommand</span> that undoes the effects of
the <span class="command"><strong>xmodmap</strong></span>.
    </p></li><li class="listitem" style="list-style-type: disc"><p><span class="property">SmRestartStyleHint</span></p><p>
If the <span class="property">SmRestartStyleHint</span> is present, it will contain the
style of restarting the client prefers.  If this style is not specified,
<code class="constant">SmRestartIfRunning</code> is assumed.
The possible values are as follows:

</p><div class="informaltable"><table border="0"><colgroup><col align="center" class="c1" /><col align="center" class="c2" /></colgroup><thead><tr><th align="left">Name</th><th align="right">Value</th></tr></thead><tbody><tr><td align="left"><code class="constant">SmRestartIfRunning</code></td><td align="right">0</td></tr><tr><td align="left"><code class="constant">SmRestartAnyway</code></td><td align="right">1</td></tr><tr><td align="left"><code class="constant">SmRestartImmediately</code></td><td align="right">2</td></tr><tr><td align="left"><code class="constant">SmRestartNever</code></td><td align="right">3</td></tr></tbody></table></div><p>
      </p><p>
The <code class="constant">SmRestartIfRunning</code> style is used in the usual case.
The client should be restarted in the next session if it was running at
the end of the current session.
      </p><p>
The <code class="constant">SmRestartAnyway</code> style is used to tell the Session
Manager that the application should be restarted in the next session even if
it exits before the current session is terminated.  It should be noted that
this is only a hint and the Session Manager will follow the policies
specified by its users in determining what applications to restart.
      </p><p>
A client that uses <code class="constant">SmRestartAnyway</code> should also set the
<span class="property">SmResignCommand</span> and <span class="property">SmShutdownCommand</span>
properties to commands that undo the state of the client after it exits.
      </p><p>
The SmRestartImmediately style is like SmRestartAnyway, but, in addition, the client is meant to run continuously.  If the client exits, the Session Manager should try to restart it in the current session.
      </p><p>
<code class="constant">SmRestartNever</code> style specifies that the client does not
wish to be restarted in the next session.
      </p></li><li class="listitem" style="list-style-type: disc"><p><span class="property">SmShutdownCommand</span></p><p>
This command is executed at shutdown time to clean up after a client
that is no longer running but retained its state by setting
<span class="property">SmRestartStyleHint</span> to
<code class="constant">SmRestartAnyway</code>.  The client must not remove any saved
state as the client is still part of the session.  As an
example, consider a client that turns on a camera at start up time.
This client then exits.  At session shutdown, the user wants the
camera turned off.  This client would set the
<span class="property">SmRestartStyleHint</span> to
<code class="constant">SmRestartAnyway</code> and would register
a <span class="property">SmShutdownCommand</span> that would turn off the camera.
    </p></li><li class="listitem" style="list-style-type: disc"><p><span class="property">SmUserID</span></p><p>
Specifies the user ID.  On <acronym class="acronym">POSIX</acronym>-based systems, this will
contain the user's name (the <em class="structfield"><code>pw_name</code></em> member of
<span class="structname">struct passwd</span>).
    </p></li></ul></div></div><div class="chapter" title="Chapter 8. Freeing Data"><div class="titlepage"><div><div><h2 class="title"><a id="freeing_data"></a>Chapter 8. Freeing Data</h2></div></div></div><p>
To free an individual property, use <code class="function">SmFreeProperty</code>
  </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncSmFreeProperty</strong>(</code>SmProp *<var class="pdparam">prop</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>prop</code></em></span></p></td><td><p>The property to free.</p></td></tr></tbody></table></div><p>
To free the reason strings from
the <code class="function">SmsCloseConnectionProc</code> callback,
use <code class="function">SmFreeReasons</code>
  </p><div class="funcsynopsis"><p><code class="funcdef">void <strong>fsfuncSmFreeReasons</strong>(</code>int <var class="pdparam">count</var>, char **<var class="pdparam">reasons</var><code>)</code>;</p></div><div class="variablelist"><table border="0"><col align="left" valign="top" /><tbody><tr><td><p><span class="term"><em class="parameter"><code>count</code></em></span></p></td><td><p>The number of reason strings.</p></td></tr><tr><td><p><span class="term"><em class="parameter"><code>reasons</code></em></span></p></td><td><p>The list of reason strings to free.</p></td></tr></tbody></table></div></div><div class="chapter" title="Chapter 9. Authentication of Clients"><div class="titlepage"><div><div><h2 class="title"><a id="authentication_of_clients"></a>Chapter 9. Authentication of Clients</h2></div></div></div><p>
As stated earlier, the session management protocol is layered on top
of ICE.  Authentication occurs at two levels in the ICE protocol:

</p><div class="itemizedlist"><ul class="itemizedlist" type="bullet"><li class="listitem" style="list-style-type: disc"><p>The first is when an ICE connection is opened.</p></li><li class="listitem" style="list-style-type: disc"><p>The second is when a Protocol Setup occurs on an ICE connection.</p></li></ul></div><p>
  </p><p>
The authentication methods that are available are
implementation-dependent (that is., dependent on the ICElib and SMlib
implementations in use).  For further information, see the
“<span class="citetitle">Inter-Client Exchange Library</span>”
standard.
  </p></div><div class="chapter" title="Chapter 10. Working in a Multi-Threaded Environment"><div class="titlepage"><div><div><h2 class="title"><a id="working_in_a_multithreaded_environment"></a>Chapter 10. Working in a Multi-Threaded Environment</h2></div></div></div><p>
To declare that multiple threads in an application will be using SMlib
(or any other library layered on top of ICElib), you should
call <code class="function">IceInitThreads</code>.
For further information, see the
“<span class="citetitle">Inter-Client Exchange Library</span>”
standard.
  </p></div><div class="chapter" title="Chapter 11. Acknowledgements"><div class="titlepage"><div><div><h2 class="title"><a id="acknowledgements"></a>Chapter 11. Acknowledgements</h2></div></div></div><p>
Thanks to the following people for their participation in the
X Session Management design: Jordan Brown, Ellis Cohen, Donna Converse,
Stephen Gildea, Vania Joloboff, Stuart Marks, Bob Scheifler, Ralph Swick,
and Mike Wexler.
  </p></div></div></body></html>
