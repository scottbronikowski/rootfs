<!doctype html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="manual.css" type="text/css" /></head>
<title>Chicken &raquo; Unit library</title>
<meta name="viewport" content="initial-scale=1" /></html>
<body>
<div id="body">
<div id="main">
<div id="toc">
<h2>TOC &raquo;</h2>
<ul>
<li><a href="#sec:Unit_library">Unit library</a>
<ul>
<li><a href="#sec:Arithmetic">Arithmetic</a>
<ul>
<li><a href="#sec:add1.2fsub1">add1/sub1</a></li>
<li><a href="#sec:Binary_integer_operations">Binary integer operations</a></li>
<li><a href="#sec:bit-set.3f">bit-set?</a></li>
<li><a href="#sec:Arithmetic_fixnum_operations">Arithmetic fixnum operations</a></li>
<li><a href="#sec:Fixnum_comparison_and_predicates">Fixnum comparison and predicates</a></li>
<li><a href="#sec:fixnum.3f">fixnum?</a></li>
<li><a href="#sec:Fixnum_limits">Fixnum limits</a></li>
<li><a href="#sec:Arithmetic_floating-point_operations">Arithmetic floating-point operations</a></li>
<li><a href="#sec:flonum.3f">flonum?</a></li>
<li><a href="#sec:Flonum_limits">Flonum limits</a></li>
<li><a href="#sec:finite.3f">finite?</a></li>
<li><a href="#sec:signum">signum</a></li></ul></li>
<li><a href="#sec:File_Input.2fOutput">File Input/Output</a>
<ul>
<li><a href="#sec:current-output-port">current-output-port</a></li>
<li><a href="#sec:current-error-port">current-error-port</a></li>
<li><a href="#sec:flush-output">flush-output</a></li>
<li><a href="#sec:port-closed.3f">port-closed?</a></li>
<li><a href="#sec:port-name">port-name</a></li>
<li><a href="#sec:port-position">port-position</a></li>
<li><a href="#sec:set-port-name.21">set-port-name!</a></li></ul></li>
<li><a href="#sec:Files">Files</a>
<ul>
<li><a href="#sec:delete-file">delete-file</a></li>
<li><a href="#sec:directory-exists.3f">directory-exists?</a></li>
<li><a href="#sec:file-exists.3f">file-exists?</a></li>
<li><a href="#sec:rename-file">rename-file</a></li></ul></li>
<li><a href="#sec:String_ports">String ports</a>
<ul>
<li><a href="#sec:get-output-string">get-output-string</a></li>
<li><a href="#sec:open-input-string">open-input-string</a></li>
<li><a href="#sec:open-output-string">open-output-string</a></li></ul></li>
<li><a href="#sec:Feature_identifiers">Feature identifiers</a>
<ul>
<li><a href="#sec:features">features</a></li>
<li><a href="#sec:feature.3f">feature?</a></li>
<li><a href="#sec:register-feature.21">register-feature!</a></li>
<li><a href="#sec:unregister-feature.21">unregister-feature!</a></li></ul></li>
<li><a href="#sec:Keywords">Keywords</a>
<ul>
<li><a href="#sec:get-keyword">get-keyword</a></li>
<li><a href="#sec:keyword.3f">keyword?</a></li>
<li><a href="#sec:keyword-.3estring">keyword-&gt;string</a></li>
<li><a href="#sec:string-.3ekeyword">string-&gt;keyword</a></li></ul></li>
<li><a href="#sec:Environment_information_and_system_interface">Environment information and system interface</a>
<ul>
<li><a href="#sec:argv">argv</a></li>
<li><a href="#sec:exit">exit</a></li>
<li><a href="#sec:build-platform">build-platform</a></li>
<li><a href="#sec:chicken-version">chicken-version</a></li>
<li><a href="#sec:errno">errno</a></li>
<li><a href="#sec:get-environment-variable">get-environment-variable</a></li>
<li><a href="#sec:machine-byte-order">machine-byte-order</a></li>
<li><a href="#sec:machine-type">machine-type</a></li>
<li><a href="#sec:on-exit">on-exit</a></li>
<li><a href="#sec:software-type">software-type</a></li>
<li><a href="#sec:software-version">software-version</a></li>
<li><a href="#sec:c-runtime">c-runtime</a></li>
<li><a href="#sec:system">system</a></li></ul></li>
<li><a href="#sec:Execution_time">Execution time</a>
<ul>
<li><a href="#sec:cpu-time">cpu-time</a></li>
<li><a href="#sec:current-milliseconds">current-milliseconds</a></li>
<li><a href="#sec:current-seconds">current-seconds</a></li>
<li><a href="#sec:current-gc-milliseconds">current-gc-milliseconds</a></li></ul></li>
<li><a href="#sec:Interrupts_and_error-handling">Interrupts and error-handling</a>
<ul>
<li><a href="#sec:enable-warnings">enable-warnings</a></li>
<li><a href="#sec:error">error</a></li>
<li><a href="#sec:get-call-chain">get-call-chain</a></li>
<li><a href="#sec:print-call-chain">print-call-chain</a></li>
<li><a href="#sec:print-error-message">print-error-message</a></li>
<li><a href="#sec:procedure-information">procedure-information</a></li>
<li><a href="#sec:reset">reset</a></li>
<li><a href="#sec:warning">warning</a></li></ul></li>
<li><a href="#sec:Garbage_collection">Garbage collection</a>
<ul>
<li><a href="#sec:gc">gc</a></li>
<li><a href="#sec:memory-statistics">memory-statistics</a></li>
<li><a href="#sec:set-finalizer.21">set-finalizer!</a></li>
<li><a href="#sec:set-gc-report.21">set-gc-report!</a></li></ul></li>
<li><a href="#sec:Other_predicates_and_comparison_operations">Other predicates and comparison operations</a>
<ul>
<li><a href="#sec:promise.3f">promise?</a></li>
<li><a href="#sec:equal.3d.3f">equal=?</a></li></ul></li>
<li><a href="#sec:String_utilities">String utilities</a>
<ul>
<li><a href="#sec:reverse-list-.3estring">reverse-list-&gt;string</a></li></ul></li>
<li><a href="#sec:Generating_uninterned_symbols">Generating uninterned symbols</a>
<ul>
<li><a href="#sec:gensym">gensym</a></li>
<li><a href="#sec:string-.3euninterned-symbol">string-&gt;uninterned-symbol</a></li>
<li><a href="#sec:symbol-append">symbol-append</a></li></ul></li>
<li><a href="#sec:Standard_Input.2fOutput">Standard Input/Output</a>
<ul>
<li><a href="#sec:port.3f">port?</a></li>
<li><a href="#sec:print">print</a></li>
<li><a href="#sec:print.2a">print*</a></li></ul></li>
<li><a href="#sec:User-defined_named_characters">User-defined named characters</a>
<ul>
<li><a href="#sec:char-name">char-name</a></li></ul></li>
<li><a href="#sec:Blobs">Blobs</a>
<ul>
<li><a href="#sec:make-blob">make-blob</a></li>
<li><a href="#sec:blob.3f">blob?</a></li>
<li><a href="#sec:blob-size">blob-size</a></li>
<li><a href="#sec:blob-.3estring">blob-&gt;string</a></li>
<li><a href="#sec:string-.3eblob">string-&gt;blob</a></li>
<li><a href="#sec:blob.3d.3f">blob=?</a></li></ul></li>
<li><a href="#sec:Vectors">Vectors</a>
<ul>
<li><a href="#sec:vector-copy.21">vector-copy!</a></li>
<li><a href="#sec:vector-resize">vector-resize</a></li></ul></li>
<li><a href="#sec:The_unspecified_value">The unspecified value</a>
<ul>
<li><a href="#sec:void">void</a></li></ul></li>
<li><a href="#sec:Continuations">Continuations</a>
<ul>
<li><a href="#sec:call.2fcc">call/cc</a></li>
<li><a href="#sec:continuation-capture">continuation-capture</a></li>
<li><a href="#sec:continuation.3f">continuation?</a></li>
<li><a href="#sec:continuation-graft">continuation-graft</a></li>
<li><a href="#sec:continuation-return">continuation-return</a></li></ul></li>
<li><a href="#sec:Setters">Setters</a>
<ul>
<li><a href="#sec:setter">setter</a></li>
<li><a href="#sec:getter-with-setter">getter-with-setter</a></li></ul></li>
<li><a href="#sec:Reader_extensions">Reader extensions</a>
<ul>
<li><a href="#sec:define-reader-ctor">define-reader-ctor</a></li>
<li><a href="#sec:set-read-syntax.21">set-read-syntax!</a></li>
<li><a href="#sec:set-sharp-read-syntax.21">set-sharp-read-syntax!</a></li>
<li><a href="#sec:set-parameterized-read-syntax.21">set-parameterized-read-syntax!</a></li>
<li><a href="#sec:copy-read-table">copy-read-table</a></li></ul></li>
<li><a href="#sec:Property_lists">Property lists</a>
<ul>
<li><a href="#sec:get">get</a></li>
<li><a href="#sec:put.21">put!</a></li>
<li><a href="#sec:remprop.21">remprop!</a></li>
<li><a href="#sec:symbol-plist">symbol-plist</a></li>
<li><a href="#sec:get-properties">get-properties</a></li></ul></li></ul></li></ul></div><h2 id="sec:Unit_library"><a href="#sec:Unit_library">Unit library</a></h2><p>This unit contains basic Scheme definitions. This unit is used by default, unless the program is compiled with the <tt>-explicit-use</tt> option.</p><h3 id="sec:Arithmetic"><a href="#sec:Arithmetic">Arithmetic</a></h3><h4 id="sec:add1.2fsub1"><a href="#sec:add1.2fsub1">add1/sub1</a></h4><dl class="defsig"><dt class="defsig" id="def:add1"><span class="sig"><tt>(add1 N)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:sub1"><span class="sig"><tt>(sub1 N)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Adds/subtracts 1 from <tt>N</tt>.</p></dd>
</dl>
<h4 id="sec:Binary_integer_operations"><a href="#sec:Binary_integer_operations">Binary integer operations</a></h4><dl class="defsig"><dt class="defsig" id="def:bitwise-and"><span class="sig"><tt>(bitwise-and N1 ...)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:bitwise-ior"><span class="sig"><tt>(bitwise-ior N1 ...)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:bitwise-xor"><span class="sig"><tt>(bitwise-xor N1 ...)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:bitwise-not"><span class="sig"><tt>(bitwise-not N)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:arithmetic-shift"><span class="sig"><tt>(arithmetic-shift N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Binary integer operations. <tt>arithmetic-shift</tt> shifts the argument <tt>N1</tt> by <tt>N2</tt> bits to the left. If <tt>N2</tt> is negative, then <tt>N1</tt> is shifted to the right. These operations only accept exact integers or inexact integers in word range (32 bit signed on 32-bit platforms, or 64 bit signed on 64-bit platforms).</p></dd>
</dl>
<h4 id="sec:bit-set.3f"><a href="#sec:bit-set.3f">bit-set?</a></h4><dl class="defsig"><dt class="defsig" id="def:bit-set.3f"><span class="sig"><tt>(bit-set? N INDEX)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns <tt>#t</tt> if the bit at the position <tt>INDEX</tt> in the integer <tt>N</tt> is set, or <tt>#f</tt> otherwise. The rightmost/least-significant bit is bit 0.</p></dd>
</dl>
<h4 id="sec:Arithmetic_fixnum_operations"><a href="#sec:Arithmetic_fixnum_operations">Arithmetic fixnum operations</a></h4><dl class="defsig"><dt class="defsig" id="def:fx.2b"><span class="sig"><tt>(fx+ N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fx-"><span class="sig"><tt>(fx- N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fx.2a"><span class="sig"><tt>(fx* N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fx.2f"><span class="sig"><tt>(fx/ N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fxmod"><span class="sig"><tt>(fxmod N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fxneg"><span class="sig"><tt>(fxneg N)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fxmin"><span class="sig"><tt>(fxmin N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fxmax"><span class="sig"><tt>(fxmax N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fxand"><span class="sig"><tt>(fxand N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fxior"><span class="sig"><tt>(fxior N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fxxor"><span class="sig"><tt>(fxxor N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fxnot"><span class="sig"><tt>(fxnot N)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fxshl"><span class="sig"><tt>(fxshl N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fxshr"><span class="sig"><tt>(fxshr N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p><tt>fx+</tt> and friends are arithmetic fixnum operations.  These procedures do not check their arguments, so non-fixnum parameters will result in incorrect results. <tt>fxneg</tt> negates its argument.</p><p>On division by zero, <tt>fx/</tt> and <tt>fxmod</tt> signal a condition of kind <tt>(exn arithmetic)</tt>.</p><p><tt>fxshl</tt> and <tt>fxshr</tt> perform arithmetic shift left and right, respectively.</p></dd>
</dl>
<h4 id="sec:Fixnum_comparison_and_predicates"><a href="#sec:Fixnum_comparison_and_predicates">Fixnum comparison and predicates</a></h4><dl class="defsig"><dt class="defsig" id="def:fxodd.3f"><span class="sig"><tt>(fxodd? N)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fxeven.3f"><span class="sig"><tt>(fxeven? N)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fx.3d"><span class="sig"><tt>(fx= N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fx.3e"><span class="sig"><tt>(fx&gt; N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fx.3c"><span class="sig"><tt>(fx&lt; N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fx.3e.3d"><span class="sig"><tt>(fx&gt;= N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fx.3c.3d"><span class="sig"><tt>(fx&lt;= N1 N2)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Comparison of fixnums and predicates on them.</p></dd>
</dl>
<h4 id="sec:fixnum.3f"><a href="#sec:fixnum.3f">fixnum?</a></h4><dl class="defsig"><dt class="defsig" id="def:fixnum.3f"><span class="sig"><tt>(fixnum? X)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns <tt>#t</tt> if <tt>X</tt> is a fixnum, or <tt>#f</tt> otherwise.</p></dd>
</dl>
<h4 id="sec:Fixnum_limits"><a href="#sec:Fixnum_limits">Fixnum limits</a></h4><dl class="defsig"><dt class="defsig" id="def:most-positive-fixnum"><span class="sig"><tt>most-positive-fixnum</tt></span> <span class="type">constant</span></dt>
<dt class="defsig" id="def:most-negative-fixnum"><span class="sig"><tt>most-negative-fixnum</tt></span> <span class="type">constant</span></dt>
<dt class="defsig" id="def:fixnum-bits"><span class="sig"><tt>fixnum-bits</tt></span> <span class="type">constant</span></dt>
<dt class="defsig" id="def:fixnum-precision"><span class="sig"><tt>fixnum-precision</tt></span> <span class="type">constant</span></dt>
<dd class="defsig"><p>Platform-specific fixnum limits.</p></dd>
</dl>
<h4 id="sec:Arithmetic_floating-point_operations"><a href="#sec:Arithmetic_floating-point_operations">Arithmetic floating-point operations</a></h4><dl class="defsig"><dt class="defsig" id="def:fp.2b"><span class="sig"><tt>(fp+ X Y)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fp-"><span class="sig"><tt>(fp- X Y)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fp.2a"><span class="sig"><tt>(fp* X Y)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fp.2f"><span class="sig"><tt>(fp/ X Y)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpneg"><span class="sig"><tt>(fpneg X)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpmin"><span class="sig"><tt>(fpmin X Y)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpmax"><span class="sig"><tt>(fpmax X Y)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fp.3d"><span class="sig"><tt>(fp= X Y)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fp.3e"><span class="sig"><tt>(fp&gt; X Y)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fp.3c"><span class="sig"><tt>(fp&lt; X Y)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fp.3e.3d"><span class="sig"><tt>(fp&gt;= X Y)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fp.3c.3d"><span class="sig"><tt>(fp&lt;= X Y)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpfloor"><span class="sig"><tt>(fpfloor X)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpceiling"><span class="sig"><tt>(fpceiling X)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fptruncate"><span class="sig"><tt>(fptruncate X)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpround"><span class="sig"><tt>(fpround X)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpsin"><span class="sig"><tt>(fpsin X)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpcos"><span class="sig"><tt>(fpcos X)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fptan"><span class="sig"><tt>(fptan X)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpasin"><span class="sig"><tt>(fpasin X)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpacos"><span class="sig"><tt>(fpacos X)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpatan"><span class="sig"><tt>(fpatan X)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpatan2"><span class="sig"><tt>(fpatan2 X Y)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fplog"><span class="sig"><tt>(fplog X)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpexp"><span class="sig"><tt>(fpexp X)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpexpt"><span class="sig"><tt>(fpexpt X Y)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpsqrt"><span class="sig"><tt>(fpsqrt X)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpabs"><span class="sig"><tt>(fpabs X)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:fpinteger.3f"><span class="sig"><tt>(fpinteger? X)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Arithmetic floating-point operations.</p><p>In safe mode, these procedures throw a type error when given non-float arguments. In unsafe mode, these procedures do not check their arguments. A non-flonum argument in unsafe mode can crash the application.</p><p>Note: <tt>fpround</tt> uses the rounding mode that your C library implements, which is usually different from R5RS.</p></dd>
</dl>
<h4 id="sec:flonum.3f"><a href="#sec:flonum.3f">flonum?</a></h4><dl class="defsig"><dt class="defsig" id="def:flonum.3f"><span class="sig"><tt>(flonum? X)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns <tt>#t</tt> if <tt>X</tt> is a flonum, or <tt>#f</tt> otherwise.</p></dd>
</dl>
<h4 id="sec:Flonum_limits"><a href="#sec:Flonum_limits">Flonum limits</a></h4><dl class="defsig"><dt class="defsig" id="def:maximum-flonum"><span class="sig"><tt>maximum-flonum</tt></span> <span class="type">constant</span></dt>
<dt class="defsig" id="def:minimum-flonum"><span class="sig"><tt>minimum-flonum</tt></span> <span class="type">constant</span></dt>
<dt class="defsig" id="def:flonum-radix"><span class="sig"><tt>flonum-radix</tt></span> <span class="type">constant</span></dt>
<dt class="defsig" id="def:flonum-epsilon"><span class="sig"><tt>flonum-epsilon</tt></span> <span class="type">constant</span></dt>
<dt class="defsig" id="def:flonum-precision"><span class="sig"><tt>flonum-precision</tt></span> <span class="type">constant</span></dt>
<dt class="defsig" id="def:flonum-decimal-precision"><span class="sig"><tt>flonum-decimal-precision</tt></span> <span class="type">constant</span></dt>
<dt class="defsig" id="def:flonum-maximum-exponent"><span class="sig"><tt>flonum-maximum-exponent</tt></span> <span class="type">constant</span></dt>
<dt class="defsig" id="def:flonum-minimum-exponent"><span class="sig"><tt>flonum-minimum-exponent</tt></span> <span class="type">constant</span></dt>
<dt class="defsig" id="def:flonum-maximum-decimal-exponent"><span class="sig"><tt>flonum-maximum-decimal-exponent</tt></span> <span class="type">constant</span></dt>
<dt class="defsig" id="def:flonum-minimum-decimal-exponent"><span class="sig"><tt>flonum-minimum-decimal-exponent</tt></span> <span class="type">constant</span></dt>
<dd class="defsig"><p>Platform-specific flonum limits.</p></dd>
</dl>
<h4 id="sec:finite.3f"><a href="#sec:finite.3f">finite?</a></h4><dl class="defsig"><dt class="defsig" id="def:finite.3f"><span class="sig"><tt>(finite? N)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns <tt>#f</tt> if <tt>N</tt> is negative or positive infinity, and <tt>#t</tt> otherwise.</p></dd>
</dl>
<h4 id="sec:signum"><a href="#sec:signum">signum</a></h4><dl class="defsig"><dt class="defsig" id="def:signum"><span class="sig"><tt>(signum N)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns <tt>1</tt> if <tt>N</tt> is positive, <tt>-1</tt> if <tt>N</tt> is negative or <tt>0</tt> if <tt>N</tt> is zero. <tt>signum</tt> is exactness preserving.</p></dd>
</dl>
<h3 id="sec:File_Input.2fOutput"><a href="#sec:File_Input.2fOutput">File Input/Output</a></h3><h4 id="sec:current-output-port"><a href="#sec:current-output-port">current-output-port</a></h4><dl class="defsig"><dt class="defsig" id="def:current-output-port"><span class="sig"><tt>(current-output-port [PORT])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns default output port. If <tt>PORT</tt> is given, then that port is selected as the new current output port.</p><p>Note that the default output port is not buffered. Use <a href="Unit%20posix.html#sec:Setting_the_file_buffering_mode"><tt>set-buffering-mode!</tt></a> if you need a different behavior.</p></dd>
</dl>
<h4 id="sec:current-error-port"><a href="#sec:current-error-port">current-error-port</a></h4><dl class="defsig"><dt class="defsig" id="def:current-error-port"><span class="sig"><tt>(current-error-port [PORT])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns default error output port. If <tt>PORT</tt> is given, then that port is selected as the new current error output port.</p><p>Note that the default error output port is not buffered. Use <a href="Unit%20posix.html#sec:Setting_the_file_buffering_mode"><tt>set-buffering-mode!</tt></a> if you need a different behavior.</p></dd>
</dl>
<h4 id="sec:flush-output"><a href="#sec:flush-output">flush-output</a></h4><dl class="defsig"><dt class="defsig" id="def:flush-output"><span class="sig"><tt>(flush-output [PORT])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Write buffered output to the given output-port. <tt>PORT</tt> defaults to the value of <tt>(current-output-port)</tt>.</p></dd>
</dl>
<h4 id="sec:port-closed.3f"><a href="#sec:port-closed.3f">port-closed?</a></h4><dl class="defsig"><dt class="defsig" id="def:port-closed.3f"><span class="sig"><tt>(port-closed? PORT)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Is the given <tt>PORT</tt> closed?</p></dd>
</dl>
<h4 id="sec:port-name"><a href="#sec:port-name">port-name</a></h4><dl class="defsig"><dt class="defsig" id="def:port-name"><span class="sig"><tt>(port-name [PORT])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Fetch filename from <tt>PORT</tt>. This returns the filename that was used to open this file. Returns a special tag string, enclosed into parentheses for non-file ports. <tt>PORT</tt> defaults to the value of <tt>(current-input-port)</tt>.</p></dd>
</dl>
<h4 id="sec:port-position"><a href="#sec:port-position">port-position</a></h4><dl class="defsig"><dt class="defsig" id="def:port-position"><span class="sig"><tt>(port-position [PORT])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns the current position of <tt>PORT</tt> as two values: row and column number. If the port does not support such an operation an error is signaled. This procedure is currently only available for input ports. <tt>PORT</tt> defaults to the value of <tt>(current-input-port)</tt>.</p></dd>
</dl>
<h4 id="sec:set-port-name.21"><a href="#sec:set-port-name.21">set-port-name!</a></h4><dl class="defsig"><dt class="defsig" id="def:set-port-name.21"><span class="sig"><tt>(set-port-name! PORT STRING)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Sets the name of <tt>PORT</tt> to <tt>STRING</tt>.</p></dd>
</dl>
<h3 id="sec:Files"><a href="#sec:Files">Files</a></h3><h4 id="sec:delete-file"><a href="#sec:delete-file">delete-file</a></h4><dl class="defsig"><dt class="defsig" id="def:delete-file"><span class="sig"><tt>(delete-file STRING)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Deletes the file with the pathname <tt>STRING</tt>. If the file does not exist, an error is signaled.</p></dd>
</dl>
<h4 id="sec:directory-exists.3f"><a href="#sec:directory-exists.3f">directory-exists?</a></h4><dl class="defsig"><dt class="defsig" id="def:directory-exists.3f"><span class="sig"><tt>(directory-exists? STRING)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns <tt>STRING</tt> if a directory with the given pathname exists, or <tt>#f</tt> otherwise.</p></dd>
</dl>
<h4 id="sec:file-exists.3f"><a href="#sec:file-exists.3f">file-exists?</a></h4><dl class="defsig"><dt class="defsig" id="def:file-exists.3f"><span class="sig"><tt>(file-exists? STRING)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns <tt>STRING</tt> if a file or directory with the given pathname exists, or <tt>#f</tt> otherwise.</p></dd>
</dl>
<h4 id="sec:rename-file"><a href="#sec:rename-file">rename-file</a></h4><dl class="defsig"><dt class="defsig" id="def:rename-file"><span class="sig"><tt>(rename-file OLD NEW)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Renames the file or directory with the pathname <tt>OLD</tt> to <tt>NEW</tt>. If the operation does not succeed, an error is signaled.</p></dd>
</dl>
<h3 id="sec:String_ports"><a href="#sec:String_ports">String ports</a></h3><h4 id="sec:get-output-string"><a href="#sec:get-output-string">get-output-string</a></h4><dl class="defsig"><dt class="defsig" id="def:get-output-string"><span class="sig"><tt>(get-output-string PORT)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns accumulated output of a port created with <tt>(open-output-string)</tt>.</p></dd>
</dl>
<h4 id="sec:open-input-string"><a href="#sec:open-input-string">open-input-string</a></h4><dl class="defsig"><dt class="defsig" id="def:open-input-string"><span class="sig"><tt>(open-input-string STRING)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a port for reading from <tt>STRING</tt>.</p></dd>
</dl>
<h4 id="sec:open-output-string"><a href="#sec:open-output-string">open-output-string</a></h4><dl class="defsig"><dt class="defsig" id="def:open-output-string"><span class="sig"><tt>(open-output-string)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a port for accumulating output in a string.</p></dd>
</dl>
<h3 id="sec:Feature_identifiers"><a href="#sec:Feature_identifiers">Feature identifiers</a></h3><p>CHICKEN maintains a global list of <i>features</i> naming functionality available in the current system. Additionally the <tt>cond-expand</tt> form accesses this feature list to infer what features are provided. Predefined features are <tt>chicken</tt>, and the SRFIs (Scheme Request For Implementation) provided by the base system: <tt>srfi-23, srfi-30, srfi-39</tt>. If the <tt>eval</tt> unit is used (the default), the features <tt>srfi-0, srfi-2, srfi-6, srfi-8, srfi-9</tt> and <tt>srfi-10</tt> are defined. When compiling code (during compile-time) the feature <tt>compiling</tt> is registered. When evaluating code in the interpreter (csi), the feature <tt>csi</tt> is registered.</p><h4 id="sec:features"><a href="#sec:features">features</a></h4><dl class="defsig"><dt class="defsig" id="def:features"><span class="sig"><tt>(features)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a list of all registered features that will be accepted as valid feature-identifiers by <tt>cond-expand</tt>.</p></dd>
</dl>
<h4 id="sec:feature.3f"><a href="#sec:feature.3f">feature?</a></h4><dl class="defsig"><dt class="defsig" id="def:feature.3f"><span class="sig"><tt>(feature? ID ...)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns <tt>#t</tt> if all features with the given feature-identifiers <tt>ID ...</tt> are registered.</p></dd>
</dl>
<h4 id="sec:register-feature.21"><a href="#sec:register-feature.21">register-feature!</a></h4><dl class="defsig"><dt class="defsig" id="def:register-feature.21"><span class="sig"><tt>(register-feature! FEATURE ...)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Register one or more features that will be accepted as valid feature-identifiers by <tt>cond-expand</tt>. <tt>FEATURE ...</tt> may be a keyword, string or symbol.</p></dd>
</dl>
<h4 id="sec:unregister-feature.21"><a href="#sec:unregister-feature.21">unregister-feature!</a></h4><dl class="defsig"><dt class="defsig" id="def:unregister-feature.21"><span class="sig"><tt>(unregister-feature! FEATURE ...)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Unregisters the specified feature-identifiers. <tt>FEATURE ...</tt> may be a keyword, string or symbol.</p></dd>
</dl>
<h3 id="sec:Keywords"><a href="#sec:Keywords">Keywords</a></h3><p>Keywords are special symbols prefixed with <tt>#:</tt> that evaluate to themselves. Procedures can use keywords to accept optional named parameters in addition to normal required parameters. Assignment to and bindings of keyword symbols is not allowed. The parameter <tt>keyword-style</tt> and the compiler/interpreter option <tt>-keyword-style</tt> can be used to allow an additional keyword syntax, either compatible to Common LISP, or to DSSSL.  As long as this parameter is set to <tt>#:suffix</tt>, Chicken conforms to <a href="http://srfi.schemers.org/srfi-88/srfi-88.html">SRFI-88</a>.</p><h4 id="sec:get-keyword"><a href="#sec:get-keyword">get-keyword</a></h4><dl class="defsig"><dt class="defsig" id="def:get-keyword"><span class="sig"><tt>(get-keyword KEYWORD ARGLIST [THUNK])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns the argument from <tt>ARGLIST</tt> specified under the keyword <tt>KEYWORD</tt>. If the keyword is not found, then the zero-argument procedure <tt>THUNK</tt> is invoked and the result value is returned. If <tt>THUNK</tt> is not given, <tt>#f</tt> is returned.</p><pre class="highlight"><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">increase x . args</span>)</span>
  <span class="paren2">(<span class="default">+ x <span class="paren3">(<span class="default">get-keyword <span class="keyword">#:amount</span> args <span class="paren4">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren5">(<span class="default"></span>)</span> 1</span>)</span></span>)</span></span>)</span> </span>)</span>
<span class="paren1">(<span class="default">increase 123</span>)</span>                                      ==&gt; 124
<span class="paren1">(<span class="default">increase 123 <span class="keyword">#:amount</span> 10</span>)</span>                          ==&gt; 133</pre><p>Note: the <tt>KEYWORD</tt> may actually be any kind of object.</p></dd>
</dl>
<h4 id="sec:keyword.3f"><a href="#sec:keyword.3f">keyword?</a></h4><dl class="defsig"><dt class="defsig" id="def:keyword.3f"><span class="sig"><tt>(keyword? X)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns <tt>#t</tt> if <tt>X</tt> is a keyword symbol, or <tt>#f</tt> otherwise.</p></dd>
</dl>
<h4 id="sec:keyword-.3estring"><a href="#sec:keyword-.3estring">keyword-&gt;string</a></h4><dl class="defsig"><dt class="defsig" id="def:keyword-.3estring"><span class="sig"><tt>(keyword-&gt;string KEYWORD)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Transforms <tt>KEYWORD</tt> into a string.</p></dd>
</dl>
<h4 id="sec:string-.3ekeyword"><a href="#sec:string-.3ekeyword">string-&gt;keyword</a></h4><dl class="defsig"><dt class="defsig" id="def:string-.3ekeyword"><span class="sig"><tt>(string-&gt;keyword STRING)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a keyword with the name <tt>STRING</tt>.</p></dd>
</dl>
<h3 id="sec:Environment_information_and_system_interface"><a href="#sec:Environment_information_and_system_interface">Environment information and system interface</a></h3><h4 id="sec:argv"><a href="#sec:argv">argv</a></h4><dl class="defsig"><dt class="defsig" id="def:argv"><span class="sig"><tt>(argv)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Return a list of all supplied command-line arguments. The first item in the list is a string containing the name of the executing program. The other items are the arguments passed to the application. This list is freshly created on every invocation of <tt>(argv)</tt>. It depends on the host-shell whether arguments are expanded ('globbed') or not.</p></dd>
</dl>
<h4 id="sec:exit"><a href="#sec:exit">exit</a></h4><dl class="defsig"><dt class="defsig" id="def:exit"><span class="sig"><tt>(exit [CODE])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Exit the running process and return exit-code, which defaults to 0 (Invokes <tt>exit-handler</tt>).</p><p>Note that pending <tt>dynamic-wind</tt> thunks are <i>not</i> invoked when exiting your program in this way.</p></dd>
</dl>
<h4 id="sec:build-platform"><a href="#sec:build-platform">build-platform</a></h4><dl class="defsig"><dt class="defsig" id="def:build-platform"><span class="sig"><tt>(build-platform)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a symbol specifying the toolset which has been used for building the executing system, which is one of the following:</p><pre>cygwin
mingw32
gnu
intel
unknown</pre></dd>
</dl>
<h4 id="sec:chicken-version"><a href="#sec:chicken-version">chicken-version</a></h4><dl class="defsig"><dt class="defsig" id="def:chicken-version"><span class="sig"><tt>(chicken-version [FULL])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a string containing the version number of the CHICKEN runtime system. If the optional argument <tt>FULL</tt> is given and true, then a full version string is returned.</p></dd>
</dl>
<h4 id="sec:errno"><a href="#sec:errno">errno</a></h4><dl class="defsig"><dt class="defsig" id="def:errno"><span class="sig"><tt>(errno)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns the error code of the last system call.</p></dd>
</dl>
<h4 id="sec:get-environment-variable"><a href="#sec:get-environment-variable">get-environment-variable</a></h4><dl class="defsig"><dt class="defsig" id="def:get-environment-variable"><span class="sig"><tt>(get-environment-variable STRING)</tt></span> <span class="type">procedure</span></dt>
<dt class="defsig" id="def:getenv"><span class="sig"><tt>(getenv STRING)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns the value of the environment variable <tt>STRING</tt> or <tt>#f</tt> if that variable is not defined. See also <a href="http://srfi.schemers.org/srfi-98/">SRFI-98</a>. <tt>getenv</tt> is an alias for <tt>get-environment-variable</tt>.</p></dd>
</dl>
<h4 id="sec:machine-byte-order"><a href="#sec:machine-byte-order">machine-byte-order</a></h4><dl class="defsig"><dt class="defsig" id="def:machine-byte-order"><span class="sig"><tt>(machine-byte-order)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns the symbol <tt>little-endian</tt> or <tt>big-endian</tt>, depending on the machine's byte-order.</p></dd>
</dl>
<h4 id="sec:machine-type"><a href="#sec:machine-type">machine-type</a></h4><dl class="defsig"><dt class="defsig" id="def:machine-type"><span class="sig"><tt>(machine-type)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a symbol specifying the processor on which this process is currently running, which is one of the following:</p><pre>alpha
mips
hppa
ultrasparc
sparc
ppc
ppc64
ia64
x86
x86-64
unknown</pre></dd>
</dl>
<h4 id="sec:on-exit"><a href="#sec:on-exit">on-exit</a></h4><dl class="defsig"><dt class="defsig" id="def:on-exit"><span class="sig"><tt>(on-exit THUNK)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Schedules the zero-argument procedures <tt>THUNK</tt> to be executed before the process exits, either explicitly via <tt>exit</tt> or implicitly after execution of the last top-level form. Note that finalizers for unreferenced finalized data are run before exit procedures.</p></dd>
</dl>
<h4 id="sec:software-type"><a href="#sec:software-type">software-type</a></h4><dl class="defsig"><dt class="defsig" id="def:software-type"><span class="sig"><tt>(software-type)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a symbol specifying the operating system on which this process is currently running, which is one of the following:</p><pre>windows
unix
macos
ecos
unknown</pre></dd>
</dl>
<h4 id="sec:software-version"><a href="#sec:software-version">software-version</a></h4><dl class="defsig"><dt class="defsig" id="def:software-version"><span class="sig"><tt>(software-version)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a symbol specifying the operating system version on which this process is currently running, which is one of the following:</p><pre>linux
freebsd
netbsd
openbsd
macosx
hpux
solaris
sunos
unknown</pre></dd>
</dl>
<h4 id="sec:c-runtime"><a href="#sec:c-runtime">c-runtime</a></h4><dl class="defsig"><dt class="defsig" id="def:c-runtime"><span class="sig"><tt>(c-runtime)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a symbol that designates what kind of C runtime library has been linked with this version of the Chicken libraries. Possible return values are <tt>static</tt>, <tt>dynamic</tt> or <tt>unknown</tt>. On systems not compiled with the Microsoft C compiler, <tt>c-runtime</tt> always returns <tt>unknown</tt>.</p></dd>
</dl>
<h4 id="sec:system"><a href="#sec:system">system</a></h4><dl class="defsig"><dt class="defsig" id="def:system"><span class="sig"><tt>(system STRING)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Execute shell command. The functionality offered by this procedure depends on the capabilities of the host shell. If the forking of a subprocess failed, an exception is raised. Otherwise the return status of the subprocess is returned unaltered.</p><p>On a UNIX system, that value is the raw return value of waitpid(2), which contains signal, core dump and exit status.    It is 0 on success.  To pull out the signal number or exit status portably requires POSIX calls, but in a pinch you can use something like this:</p><pre class="highlight"><span class="comment">;; Returns two values: #t if the process exited normally or #f otherwise;
</span><span class="comment">;; and either the exit status, or the signal number if terminated via signal.
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">process-status rc</span>)</span>
  <span class="paren2">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren3">(<span class="default">wait-signaled? x</span>)</span> <span class="paren3">(<span class="default">not <span class="paren4">(<span class="default">= 0 <span class="paren5">(<span class="default">bitwise-and x 127</span>)</span></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren3">(<span class="default">wait-signal x</span>)</span> <span class="paren3">(<span class="default">bitwise-and x 127</span>)</span></span>)</span>
  <span class="paren2">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren3">(<span class="default">wait-exit-status x</span>)</span> <span class="paren3">(<span class="default">arithmetic-shift x -8</span>)</span></span>)</span>
  <span class="paren2">(<span class="default"><i><span class="symbol">if</span></i> <span class="paren3">(<span class="default">wait-signaled? rc</span>)</span>
      <span class="paren3">(<span class="default">values #f <span class="paren4">(<span class="default">wait-signal rc</span>)</span></span>)</span>
      <span class="paren3">(<span class="default">values #t <span class="paren4">(<span class="default">wait-exit-status rc</span>)</span></span>)</span></span>)</span></span>)</span>

#<span class="comment">;&gt; (process-status (system &quot;exit 42&quot;))
</span>#t
42</pre></dd>
</dl>
<h3 id="sec:Execution_time"><a href="#sec:Execution_time">Execution time</a></h3><h4 id="sec:cpu-time"><a href="#sec:cpu-time">cpu-time</a></h4><dl class="defsig"><dt class="defsig" id="def:cpu-time"><span class="sig"><tt>(cpu-time)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns the used CPU time of the current process in milliseconds as two values: the time spent in user code, and the time spent in system code. On platforms where user and system time can not be differentiated, system time will be always be 0.</p></dd>
</dl>
<h4 id="sec:current-milliseconds"><a href="#sec:current-milliseconds">current-milliseconds</a></h4><dl class="defsig"><dt class="defsig" id="def:current-milliseconds"><span class="sig"><tt>(current-milliseconds)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns the number of milliseconds since process- or machine startup.</p></dd>
</dl>
<h4 id="sec:current-seconds"><a href="#sec:current-seconds">current-seconds</a></h4><dl class="defsig"><dt class="defsig" id="def:current-seconds"><span class="sig"><tt>(current-seconds)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns the number of seconds since midnight, Jan. 1, 1970.</p></dd>
</dl>
<h4 id="sec:current-gc-milliseconds"><a href="#sec:current-gc-milliseconds">current-gc-milliseconds</a></h4><dl class="defsig"><dt class="defsig" id="def:current-gc-milliseconds"><span class="sig"><tt>(current-gc-milliseconds)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns the number of milliseconds spent in major garbage collections since the last call of <tt>current-gc-milliseconds</tt> and returns an exact integer.</p></dd>
</dl>
<h3 id="sec:Interrupts_and_error-handling"><a href="#sec:Interrupts_and_error-handling">Interrupts and error-handling</a></h3><h4 id="sec:enable-warnings"><a href="#sec:enable-warnings">enable-warnings</a></h4><dl class="defsig"><dt class="defsig" id="def:enable-warnings"><span class="sig"><tt>(enable-warnings [BOOL])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Enables or disables warnings, depending on wether <tt>BOOL</tt> is true or false. If called with no arguments, this procedure returns <tt>#t</tt> if warnings are currently enabled, or <tt>#f</tt> otherwise. Note that this is not a parameter. The current state (whether warnings are enabled or disabled) is global and not thread-local.</p></dd>
</dl>
<h4 id="sec:error"><a href="#sec:error">error</a></h4><dl class="defsig"><dt class="defsig" id="def:error"><span class="sig"><tt>(error [LOCATION] [STRING] EXP ...)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Prints error message, writes all extra arguments to the value of <tt>(current-error-port)</tt> and invokes the current exception-handler. This conforms to <a href="http://srfi.schemers.org/srfi-23/srfi-23.html">SRFI-23</a>. If <tt>LOCATION</tt> is given and a symbol, it specifies the <i>location</i> (the name of the procedure) where the error occurred.</p></dd>
</dl>
<h4 id="sec:get-call-chain"><a href="#sec:get-call-chain">get-call-chain</a></h4><dl class="defsig"><dt class="defsig" id="def:get-call-chain"><span class="sig"><tt>(get-call-chain [START [THREAD]])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a list with the call history. Backtrace information is only generated in code compiled without <tt>-no-trace</tt> and evaluated code. If the optional argument <tt>START</tt> is given, the backtrace starts at this offset, i.e. when <tt>START</tt> is 1, the next to last trace-entry is printed, and so on. If the optional argument <tt>THREAD</tt> is given, then the call-chain will only be constructed for calls performed by this thread.</p></dd>
</dl>
<h4 id="sec:print-call-chain"><a href="#sec:print-call-chain">print-call-chain</a></h4><dl class="defsig"><dt class="defsig" id="def:print-call-chain"><span class="sig"><tt>(print-call-chain [PORT [START [THREAD [HEADER]]]])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Prints a backtrace of the procedure call history to <tt>PORT</tt>, which defaults to <tt>(current-output-port)</tt>. The output is prefixed by the <tt>HEADER</tt>, which defaults to <tt>&quot;\n\tCall history:\n&quot;</tt>.</p></dd>
</dl>
<h4 id="sec:print-error-message"><a href="#sec:print-error-message">print-error-message</a></h4><dl class="defsig"><dt class="defsig" id="def:print-error-message"><span class="sig"><tt>(print-error-message EXN [PORT [HEADER]])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Prints an appropriate error message to <tt>PORT</tt> (which defaults to the value of <tt>(current-output-port)</tt> for the object <tt>EXN</tt>. <tt>EXN</tt> may be a condition, a string or any other object. The output is prefixed by the <tt>HEADER</tt>, which defaults to <tt>&quot;Error:&quot;</tt>.</p></dd>
</dl>
<h4 id="sec:procedure-information"><a href="#sec:procedure-information">procedure-information</a></h4><dl class="defsig"><dt class="defsig" id="def:procedure-information"><span class="sig"><tt>(procedure-information PROC)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns an s-expression with debug information for the procedure <tt>PROC</tt>, or <tt>#f</tt>, if <tt>PROC</tt> has no associated debug information.</p></dd>
</dl>
<h4 id="sec:reset"><a href="#sec:reset">reset</a></h4><dl class="defsig"><dt class="defsig" id="def:reset"><span class="sig"><tt>(reset)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Reset program (Invokes <tt>reset-handler</tt>).</p></dd>
</dl>
<h4 id="sec:warning"><a href="#sec:warning">warning</a></h4><dl class="defsig"><dt class="defsig" id="def:warning"><span class="sig"><tt>(warning STRING EXP ...)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Displays a warning message (if warnings are enabled with <tt>enable-warnings</tt>) and continues execution.</p></dd>
</dl>
<h3 id="sec:Garbage_collection"><a href="#sec:Garbage_collection">Garbage collection</a></h3><h4 id="sec:gc"><a href="#sec:gc">gc</a></h4><dl class="defsig"><dt class="defsig" id="def:gc"><span class="sig"><tt>(gc [FLAG])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Invokes a garbage-collection and returns the number of free bytes in the heap. The flag specifies whether a minor (<tt>#f</tt>) or major (<tt>#t</tt>) GC is to be triggered. If no argument is given, <tt>#t</tt> is assumed. An explicit <tt>#t</tt> argument will cause all pending finalizers to be executed.</p></dd>
</dl>
<h4 id="sec:memory-statistics"><a href="#sec:memory-statistics">memory-statistics</a></h4><dl class="defsig"><dt class="defsig" id="def:memory-statistics"><span class="sig"><tt>(memory-statistics)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Performs a major garbage collection and returns a three element vector containing the total heap size in bytes, the number of bytes currently used and the size of the nursery (the first heap generation). Note that the actual heap is actually twice the size given in the heap size, because CHICKEN uses a copying semi-space collector.</p></dd>
</dl>
<h4 id="sec:set-finalizer.21"><a href="#sec:set-finalizer.21">set-finalizer!</a></h4><dl class="defsig"><dt class="defsig" id="def:set-finalizer.21"><span class="sig"><tt>(set-finalizer! X PROC)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Registers a procedure of one argument <tt>PROC</tt>, that will be called as soon as the non-immediate data object <tt>X</tt> is about to be garbage-collected (with that object as its argument). Note that the finalizer will <b>not</b> be called while interrupts are disabled. This procedure returns <tt>X</tt>.</p><p>Finalizers are invoked asynchronously, in the thread that happens to be currently running. Finalizers for data that has become garbage are called on normal program exit. Finalizers are not run on abnormal program exit. A normal program exit does not run finalizers that are still reachable from global data.</p><p>Multiple finalizers can be registered for the same object. The order in which the finalizers run is undefined.</p></dd>
</dl>
<h4 id="sec:set-gc-report.21"><a href="#sec:set-gc-report.21">set-gc-report!</a></h4><dl class="defsig"><dt class="defsig" id="def:set-gc-report.21"><span class="sig"><tt>(set-gc-report! FLAG)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Print statistics after every GC, depending on <tt>FLAG</tt>. A value of <tt>#t</tt> shows statistics after every major GC. A true value different from <tt>#t</tt> shows statistics after every minor GC. <tt>#f</tt> switches statistics off.</p></dd>
</dl>
<h3 id="sec:Other_predicates_and_comparison_operations"><a href="#sec:Other_predicates_and_comparison_operations">Other predicates and comparison operations</a></h3><h4 id="sec:promise.3f"><a href="#sec:promise.3f">promise?</a></h4><dl class="defsig"><dt class="defsig" id="def:promise.3f"><span class="sig"><tt>(promise? X)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns <tt>#t</tt> if <tt>X</tt> is a promise returned by <tt>delay</tt>, or <tt>#f</tt> otherwise.</p></dd>
</dl>
<h4 id="sec:equal.3d.3f"><a href="#sec:equal.3d.3f">equal=?</a></h4><dl class="defsig"><dt class="defsig" id="def:equal.3d.3f"><span class="sig"><tt>(equal=? X y)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Similar to the standard parocedure <tt>equal?</tt>, but compares numbers using the <tt>=</tt> operator, so <tt>equal=?</tt> allows structural comparison in combination with comparison of numerical data by value.</p></dd>
</dl>
<h3 id="sec:String_utilities"><a href="#sec:String_utilities">String utilities</a></h3><h4 id="sec:reverse-list-.3estring"><a href="#sec:reverse-list-.3estring">reverse-list-&gt;string</a></h4><dl class="defsig"><dt class="defsig" id="def:reverse-list-.3estring"><span class="sig"><tt>(reverse-list-&gt;string LIST)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a string with the characters in <tt>LIST</tt> in reverse order. This is equivalent to <tt>(list-&gt;string (reverse LIST))</tt>, but much more efficient.</p></dd>
</dl>
<h3 id="sec:Generating_uninterned_symbols"><a href="#sec:Generating_uninterned_symbols">Generating uninterned symbols</a></h3><h4 id="sec:gensym"><a href="#sec:gensym">gensym</a></h4><dl class="defsig"><dt class="defsig" id="def:gensym"><span class="sig"><tt>(gensym [STRING-OR-SYMBOL])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a newly created uninterned symbol. If an argument is provided, the new symbol is prefixed with that argument.</p></dd>
</dl>
<h4 id="sec:string-.3euninterned-symbol"><a href="#sec:string-.3euninterned-symbol">string-&gt;uninterned-symbol</a></h4><dl class="defsig"><dt class="defsig" id="def:string-.3euninterned-symbol"><span class="sig"><tt>(string-&gt;uninterned-symbol STRING)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a newly created, unique symbol with the name <tt>STRING</tt>.</p></dd>
</dl>
<h4 id="sec:symbol-append"><a href="#sec:symbol-append">symbol-append</a></h4><dl class="defsig"><dt class="defsig" id="def:symbol-append"><span class="sig"><tt>(symbol-append SYMBOL1 ...)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Creates a new interned symbol from the concatenated names of the argument symbols <tt>(SYMBOL1 ...)</tt>.</p></dd>
</dl>
<h3 id="sec:Standard_Input.2fOutput"><a href="#sec:Standard_Input.2fOutput">Standard Input/Output</a></h3><h4 id="sec:port.3f"><a href="#sec:port.3f">port?</a></h4><dl class="defsig"><dt class="defsig" id="def:port.3f"><span class="sig"><tt>(port? X)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns <tt>#t</tt> if <tt>X</tt> is a port object or <tt>#f</tt> otherwise.</p></dd>
</dl>
<h4 id="sec:print"><a href="#sec:print">print</a></h4><dl class="defsig"><dt class="defsig" id="def:print"><span class="sig"><tt>(print [EXP1 ...])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Outputs the optional arguments <tt>EXP1 ...</tt> using <tt>display</tt> and writes a newline character to the port that is the value of <tt>(current-output-port)</tt>. Returns <tt>(void)</tt>.</p></dd>
</dl>
<h4 id="sec:print.2a"><a href="#sec:print.2a">print*</a></h4><dl class="defsig"><dt class="defsig" id="def:print.2a"><span class="sig"><tt>(print* [EXP1 ...])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Similar to <tt>print</tt>, but does not output a terminating newline character and performs a <tt>flush-output</tt> after writing its arguments.</p></dd>
</dl>
<h3 id="sec:User-defined_named_characters"><a href="#sec:User-defined_named_characters">User-defined named characters</a></h3><h4 id="sec:char-name"><a href="#sec:char-name">char-name</a></h4><dl class="defsig"><dt class="defsig" id="def:char-name"><span class="sig"><tt>(char-name SYMBOL-OR-CHAR [CHAR])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>This procedure can be used to inquire about character names or to define new ones. With a single argument the behavior is as follows: If <tt>SYMBOL-OR-CHAR</tt> is a symbol, then <tt>char-name</tt> returns the character with this name, or <tt>#f</tt> if no character is defined under this name. If <tt>SYMBOL-OR-CHAR</tt> is a character, then the name of the character is returned as a symbol, or <tt>#f</tt> if the character has no associated name.</p><p>If the optional argument <tt>CHAR</tt> is provided, then <tt>SYMBOL-OR-CHAR</tt> should be a symbol that will be the new name of the given character. If multiple names designate the same character, then the <tt>write</tt> will use the character name that was defined last.</p><pre class="highlight"><span class="paren1">(<span class="default">char-name &#x27;space</span>)</span>                  ==&gt; <span class="character">#\space</span>
<span class="paren1">(<span class="default">char-name <span class="character">#\space</span></span>)</span>                 ==&gt; space
<span class="paren1">(<span class="default">char-name &#x27;bell</span>)</span>                   ==&gt; #f
<span class="paren1">(<span class="default">char-name <span class="paren2">(<span class="default">integer-&gt;char 7</span>)</span></span>)</span>       ==&gt; #f
<span class="paren1">(<span class="default">char-name &#x27;bell <span class="paren2">(<span class="default">integer-&gt;char 7</span>)</span></span>)</span>
<span class="paren1">(<span class="default">char-name &#x27;bell</span>)</span>                   ==&gt; <span class="character">#\bell</span>
<span class="paren1">(<span class="default">char-&gt;integer <span class="paren2">(<span class="default">char-name &#x27;bell</span>)</span></span>)</span>   ==&gt; 7</pre></dd>
</dl>
<h3 id="sec:Blobs"><a href="#sec:Blobs">Blobs</a></h3><p>&quot;blobs&quot; are collections of unstructured bytes. You can't do much with them, but allow conversion to and from SRFI-4 number vectors.</p><h4 id="sec:make-blob"><a href="#sec:make-blob">make-blob</a></h4><dl class="defsig"><dt class="defsig" id="def:make-blob"><span class="sig"><tt>(make-blob SIZE)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a blob object of <tt>SIZE</tt> bytes, aligned on an 8-byte boundary, uninitialized.</p></dd>
</dl>
<h4 id="sec:blob.3f"><a href="#sec:blob.3f">blob?</a></h4><dl class="defsig"><dt class="defsig" id="def:blob.3f"><span class="sig"><tt>(blob? X)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns <tt>#t</tt> if <tt>X</tt> is a blob object, or <tt>#f</tt> otherwise.</p></dd>
</dl>
<h4 id="sec:blob-size"><a href="#sec:blob-size">blob-size</a></h4><dl class="defsig"><dt class="defsig" id="def:blob-size"><span class="sig"><tt>(blob-size BLOB)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns the number of bytes in <tt>BLOB</tt>.</p></dd>
</dl>
<h4 id="sec:blob-.3estring"><a href="#sec:blob-.3estring">blob-&gt;string</a></h4><dl class="defsig"><dt class="defsig" id="def:blob-.3estring"><span class="sig"><tt>(blob-&gt;string BLOB)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a string with the contents of <tt>BLOB</tt>.</p></dd>
</dl>
<h4 id="sec:string-.3eblob"><a href="#sec:string-.3eblob">string-&gt;blob</a></h4><dl class="defsig"><dt class="defsig" id="def:string-.3eblob"><span class="sig"><tt>(string-&gt;blob STRING)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a blob with the contents of <tt>STRING</tt>.</p></dd>
</dl>
<h4 id="sec:blob.3d.3f"><a href="#sec:blob.3d.3f">blob=?</a></h4><dl class="defsig"><dt class="defsig" id="def:blob.3d.3f"><span class="sig"><tt>(blob=? BLOB1 BLOB2)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns <tt>#t</tt> if the two argument blobs are of the same size and have the same content.</p></dd>
</dl>
<h3 id="sec:Vectors"><a href="#sec:Vectors">Vectors</a></h3><h4 id="sec:vector-copy.21"><a href="#sec:vector-copy.21">vector-copy!</a></h4><dl class="defsig"><dt class="defsig" id="def:vector-copy.21"><span class="sig"><tt>(vector-copy! VECTOR1 VECTOR2 [COUNT])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Copies contents of <tt>VECTOR1</tt> into <tt>VECTOR2</tt>. If the argument <tt>COUNT</tt> is given, it specifies the maximal number of elements to be copied. If not given, the minimum of the lengths of the argument vectors is copied.</p><p>Exceptions: <tt>(exn bounds)</tt></p></dd>
</dl>
<h4 id="sec:vector-resize"><a href="#sec:vector-resize">vector-resize</a></h4><dl class="defsig"><dt class="defsig" id="def:vector-resize"><span class="sig"><tt>(vector-resize VECTOR N [INIT])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Creates and returns a new vector with the contents of <tt>VECTOR</tt> and length <tt>N</tt>. If <tt>N</tt> is greater than the original length of <tt>VECTOR</tt>, then all additional items are initialized to <tt>INIT</tt>. If <tt>INIT</tt> is not specified, the contents are initialized to some unspecified value.</p></dd>
</dl>
<h3 id="sec:The_unspecified_value"><a href="#sec:The_unspecified_value">The unspecified value</a></h3><h4 id="sec:void"><a href="#sec:void">void</a></h4><dl class="defsig"><dt class="defsig" id="def:void"><span class="sig"><tt>(void ARGUMENT ...)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Ignores <tt>ARGUMENT ...</tt> and returns an unspecified value.</p></dd>
</dl>
<h3 id="sec:Continuations"><a href="#sec:Continuations">Continuations</a></h3><h4 id="sec:call.2fcc"><a href="#sec:call.2fcc">call/cc</a></h4><dl class="defsig"><dt class="defsig" id="def:call.2fcc"><span class="sig"><tt>(call/cc PROCEDURE)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>An alias for <tt>call-with-current-continuation</tt>.</p></dd>
</dl>
<h4 id="sec:continuation-capture"><a href="#sec:continuation-capture">continuation-capture</a></h4><dl class="defsig"><dt class="defsig" id="def:continuation-capture"><span class="sig"><tt>(continuation-capture PROCEDURE)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Creates a continuation object representing the current continuation and tail-calls <tt>PROCEDURE</tt> with this continuation as the single argument.</p><p>More information about this continuation API can be found in the paper <a href="http://repository.readscheme.org/ftp/papers/sw2001/feeley.pdf">http://repository.readscheme.org/ftp/papers/sw2001/feeley.pdf</a> <i>A Better API for first class Continuations</i> by Marc Feeley.</p></dd>
</dl>
<h4 id="sec:continuation.3f"><a href="#sec:continuation.3f">continuation?</a></h4><dl class="defsig"><dt class="defsig" id="def:continuation.3f"><span class="sig"><tt>(continuation? X)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns <tt>#t</tt> if <tt>X</tt> is a continuation object, or <tt>#f</tt> otherwise. Please note that this applies only to continuations created by the Continuation API, but not by call/cc, i.e.: <tt>(call-with-current-continuation continuation?)</tt> returns <tt>#f</tt>, whereas <tt>(continuation-capture continuation?)</tt> returns <tt>#t</tt>.</p></dd>
</dl>
<h4 id="sec:continuation-graft"><a href="#sec:continuation-graft">continuation-graft</a></h4><dl class="defsig"><dt class="defsig" id="def:continuation-graft"><span class="sig"><tt>(continuation-graft CONT THUNK)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Calls the procedure <tt>THUNK</tt> with no arguments and the implicit continuation <tt>CONT</tt>.</p></dd>
</dl>
<h4 id="sec:continuation-return"><a href="#sec:continuation-return">continuation-return</a></h4><dl class="defsig"><dt class="defsig" id="def:continuation-return"><span class="sig"><tt>(continuation-return CONT VALUE ...)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns the value(s) to the continuation <tt>CONT</tt>. <tt>continuation-return</tt> could be implemented like this:</p><pre class="highlight"><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">continuation-return k . vals</span>)</span>
  <span class="paren2">(<span class="default">continuation-graft
    k
    <span class="paren3">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren4">(<span class="default"></span>)</span> <span class="paren4">(<span class="default">apply values vals</span>)</span></span>)</span> </span>)</span> </span>)</span></pre></dd>
</dl>
<h3 id="sec:Setters"><a href="#sec:Setters">Setters</a></h3><p>SRFI-17 is fully implemented. For more information see: <a href="http://srfi.schemers.org/srfi-17/srfi-17.html">SRFI-17</a>.</p><h4 id="sec:setter"><a href="#sec:setter">setter</a></h4><dl class="defsig"><dt class="defsig" id="def:setter"><span class="sig"><tt>(setter PROCEDURE)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns the setter-procedure of <tt>PROCEDURE</tt>, or signals an error if <tt>PROCEDURE</tt> has no associated setter-procedure.</p><p>Note that <tt>(set! (setter PROC) ...)</tt> for a procedure that has no associated setter procedure yet is a very slow operation (the old procedure is replaced by a modified copy, which involves a garbage collection).</p></dd>
</dl>
<h4 id="sec:getter-with-setter"><a href="#sec:getter-with-setter">getter-with-setter</a></h4><dl class="defsig"><dt class="defsig" id="def:getter-with-setter"><span class="sig"><tt>(getter-with-setter GETTER SETTER)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a copy of the procedure <tt>GETTER</tt> with the associated setter procedure <tt>SETTER</tt>. Contrary to the SRFI specification, the setter of the returned procedure may be changed.</p></dd>
</dl>
<h3 id="sec:Reader_extensions"><a href="#sec:Reader_extensions">Reader extensions</a></h3><h4 id="sec:define-reader-ctor"><a href="#sec:define-reader-ctor">define-reader-ctor</a></h4><dl class="defsig"><dt class="defsig" id="def:define-reader-ctor"><span class="sig"><tt>(define-reader-ctor SYMBOL PROC)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Define new read-time constructor for <tt>#,</tt> read syntax. For further information, see the documentation for <a href="http://srfi.schemers.org/srfi-10/srfi-10.html">SRFI-10</a>.</p></dd>
</dl>
<h4 id="sec:set-read-syntax.21"><a href="#sec:set-read-syntax.21">set-read-syntax!</a></h4><dl class="defsig"><dt class="defsig" id="def:set-read-syntax.21"><span class="sig"><tt>(set-read-syntax! CHAR-OR-SYMBOL PROC)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>When the reader encounters the non-whitespace character <tt>CHAR</tt> while reading an expression from a given port, then the procedure <tt>PROC</tt> will be called with that port as its argument. The procedure should return a value that will be returned to the reader:</p><pre class="highlight"> <span class="comment">; A simple RGB color syntax:
</span>
 <span class="paren1">(<span class="default">set-read-syntax! <span class="character">#\%</span>
   <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default">port</span>)</span>
     <span class="paren3">(<span class="default">apply vector
       <span class="paren4">(<span class="default">map <span class="paren5">(<span class="default">cut string-&gt;number &lt;&gt; 16</span>)</span>
	    <span class="paren5">(<span class="default">string-chop <span class="paren6">(<span class="default">read-string 6 port</span>)</span> 2</span>)</span> </span>)</span> </span>)</span> </span>)</span> </span>)</span>

 <span class="paren1">(<span class="default"><i><span class="symbol">with-input-from-string</span></i> <span class="string">&quot;(1 2 %f0f0f0 3)&quot;</span> read</span>)</span>
 <span class="comment">; ==&gt; (1 2 #(240 240 240) 3)</span></pre><p>If <tt>CHAR-OR-SYMBOL</tt> is a symbol, then a so-called <i>read-mark</i> handler is defined. In that case the handler procedure will be called when a character-sequence of the form</p><pre>#!SYMBOL</pre><p>is encountered.</p><p>You can undo special handling of read-syntax by passing <tt>#f</tt> as the second argument (if the syntax was previously defined via <tt>set-read-syntax!</tt>).</p><p>Note that all of CHICKEN's special non-standard read-syntax is handled directly by the reader. To disable built-in read-syntax, define a handler that triggers an error (for example).</p></dd>
</dl>
<h4 id="sec:set-sharp-read-syntax.21"><a href="#sec:set-sharp-read-syntax.21">set-sharp-read-syntax!</a></h4><dl class="defsig"><dt class="defsig" id="def:set-sharp-read-syntax.21"><span class="sig"><tt>(set-sharp-read-syntax! CHAR-OR-SYMBOL PROC)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Similar to <tt>set-read-syntax!</tt>, but allows defining new <tt>#&lt;CHAR&gt; ...</tt> reader syntax. If the first argument is a symbol, then this procedure is equivalent to <tt>set-read-syntax!</tt>.</p></dd>
</dl>
<h4 id="sec:set-parameterized-read-syntax.21"><a href="#sec:set-parameterized-read-syntax.21">set-parameterized-read-syntax!</a></h4><dl class="defsig"><dt class="defsig" id="def:set-parameterized-read-syntax.21"><span class="sig"><tt>(set-parameterized-read-syntax! CHAR-OR-SYMBOL PROC)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Similar to <tt>set-sharp-read-syntax!</tt>, but intended for defining reader syntax of the form <tt>#&lt;NUMBER&gt;&lt;CHAR&gt; ...</tt>. The handler procedure <tt>PROC</tt> will be called with two arguments: the input port and the number preceding the dispatching character. If the first argument is a symbol, then this procedure is equivalent to <tt>set-read-syntax!</tt>.</p></dd>
</dl>
<h4 id="sec:copy-read-table"><a href="#sec:copy-read-table">copy-read-table</a></h4><dl class="defsig"><dt class="defsig" id="def:copy-read-table"><span class="sig"><tt>(copy-read-table READ-TABLE)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns a copy of the given read-table. You can access the currently active read-table with <tt>(current-read-table)</tt>.</p></dd>
</dl>
<h3 id="sec:Property_lists"><a href="#sec:Property_lists">Property lists</a></h3><p>As in other Lisp dialects, CHICKEN supports &quot;property lists&quot; associated with symbols. Properties are accessible via a key that can be any kind of value but which will be compared using <tt>eq?</tt>.</p><h4 id="sec:get"><a href="#sec:get">get</a></h4><dl class="defsig"><dt class="defsig" id="def:get"><span class="sig"><tt>(get SYMBOL PROPERTY [DEFAULT])</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Returns the value stored under the key <tt>PROPERTY</tt> in the property list of <tt>SYMBOL</tt>. If no such property is stored, returns <tt>DEFAULT</tt>. The <tt>DEFAULT</tt> is optional and defaults to <tt>#f</tt>.</p></dd>
</dl>
<h4 id="sec:put.21"><a href="#sec:put.21">put!</a></h4><dl class="defsig"><dt class="defsig" id="def:put.21"><span class="sig"><tt>(put! SYMBOL PROPERTY VALUE)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>setter: (set! (get SYMBOL PROPERTY) VALUE)</p><p>Stores <tt>VALUE</tt> under the key <tt>PROPERTY</tt> in the property list of <tt>SYMBOL</tt> replacing any previously stored value.</p></dd>
</dl>
<h4 id="sec:remprop.21"><a href="#sec:remprop.21">remprop!</a></h4><dl class="defsig"><dt class="defsig" id="def:remprop.21"><span class="sig"><tt>(remprop! SYMBOL PROPERTY)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Deletes the first property matching the key <tt>PROPERTY</tt> in the property list of <tt>SYMBOL</tt>. Returns <tt>#t</tt> when a deletion performed, and <tt>#f</tt> otherwise.</p></dd>
</dl>
<h4 id="sec:symbol-plist"><a href="#sec:symbol-plist">symbol-plist</a></h4><dl class="defsig"><dt class="defsig" id="def:symbol-plist"><span class="sig"><tt>(symbol-plist SYMBOL)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>setter: (set! (symbol-plist SYMBOL) LST)</p><p>Returns the property list of <tt>SYMBOL</tt> or sets it.</p></dd>
</dl>
<h4 id="sec:get-properties"><a href="#sec:get-properties">get-properties</a></h4><dl class="defsig"><dt class="defsig" id="def:get-properties"><span class="sig"><tt>(get-properties SYMBOL PROPERTIES)</tt></span> <span class="type">procedure</span></dt>
<dd class="defsig"><p>Searches the property list of <tt>SYMBOL</tt> for the first property with a key in the list <tt>PROPERTIES</tt>. Returns 3 values: the matching property key, value, and the tail of property list after the matching property. When no match found all values are <tt>#f</tt>.</p><p><tt>PROPERTIES</tt> may also be an atom, in which case it is treated as a list of one element.</p></dd>
</dl>
<hr /><p>Previous: <a href="Exceptions.html">Exceptions</a> Next: <a href="Unit%20eval.html">Unit eval</a></p></div></div></body>