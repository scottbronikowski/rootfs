<!doctype html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="manual.css" type="text/css" /></head>
<title>Chicken &raquo; Using the compiler</title>
<meta name="viewport" content="initial-scale=1" /></html>
<body>
<div id="body">
<div id="main">
<div id="toc">
<h2>TOC &raquo;</h2>
<ul>
<li><a href="#sec:Using_the_compiler">Using the compiler</a>
<ul>
<li><a href="#sec:Compiler_command_line_format">Compiler command line format</a>
<ul>
<li><a href="#sec:Basic_command-line_options">Basic command-line options</a></li>
<li><a href="#sec:Further_options">Further options</a></li></ul></li>
<li><a href="#sec:Runtime_options">Runtime options</a></li>
<li><a href="#sec:Examples">Examples</a>
<ul>
<li><a href="#sec:A_simple_example_.28with_one_source_file.29">A simple example (with one source file)</a>
<ul>
<li><a href="#sec:Writing_your_source_file">Writing your source file</a></li>
<li><a href="#sec:Compiling_your_program">Compiling your program</a></li>
<li><a href="#sec:Running_your_program">Running your program</a></li></ul></li>
<li><a href="#sec:An_example_with_multiple_files">An example with multiple files</a>
<ul>
<li><a href="#sec:Writing_your_source_files">Writing your source files</a></li>
<li><a href="#sec:Compiling_and_running_your_program">Compiling and running your program</a></li></ul></li></ul></li>
<li><a href="#sec:Extending_the_compiler">Extending the compiler</a></li>
<li><a href="#sec:Distributing_compiled_C_files">Distributing compiled C files</a></li></ul></li></ul></div><h2 id="sec:Using_the_compiler"><a href="#sec:Using_the_compiler">Using the compiler</a></h2><p>The <tt>csc</tt> compiler driver provides a convenient interface to the basic Scheme-to-C translator (<tt>chicken</tt>) and takes care for compiling and linking the generated C files into executable code. Enter</p><pre>csc -help</pre><p>on the command line for a list of options.</p><h3 id="sec:Compiler_command_line_format"><a href="#sec:Compiler_command_line_format">Compiler command line format</a></h3><pre>csc FILENAME-OR-OPTION</pre><p><tt>FILENAME</tt> is the pathname of the source file that is to be compiled. A filename argument of <tt>-</tt> specifies that the source text should be read from standard input.</p><h4 id="sec:Basic_command-line_options"><a href="#sec:Basic_command-line_options">Basic command-line options</a></h4><dl><dt>-analyze-only</dt>
<dd>Stop compilation after first analysis pass.</dd><dt>-block</dt>
<dd>Enable block-compilation. When this option is specified, the compiler assumes that global variables are not modified outside this compilation-unit.  Specifically, toplevel bindings are not seen by <tt>eval</tt> and unused toplevel bindings are removed.</dd><dt>-case-insensitive</dt>
<dd>Enables the reader to read symbols case insensitive. The default is to read case sensitive (in violation of R5RS).  This option registers the <tt>case-insensitive</tt> feature identifier.</dd><dt>-check-syntax</dt>
<dd>Aborts compilation process after macro-expansion and syntax checks.</dd><dt>-consult-inline-file FILENAME</dt>
<dd>load file with definitions for cross-module inlining generated by a previous compiloer invocation via <tt>-emit-inline-file</tt>. Implies <tt>-inline</tt>.</dd><dt>-debug MODES</dt>
<dd>Enables one or more compiler debugging modes. <tt>MODES</tt> is a string of characters that select debugging information about the compiler that will be printed to standard output.</dd></dl>
<pre>    t          show time needed for compilation
    b          show breakdown of time needed for each compiler pass
    o          show performed optimizations
    r          show invocation parameters
    s          show program-size information and other statistics
    a          show node-matching during simplification
    p          show execution of compiler sub-passes
    m          show GC statistics during compilation
    n          print the line-number database 
    c          print every expression before macro-expansion
    u          lists all unassigned global variable references
    d          lists all assigned global variables
    x          display information about experimental features
    D          when printing nodes, use node-tree output
    N          show the real-name mapping table
    S          show applications of compiler syntax
    T          show expressions after converting to node tree
    U          show expressions after unboxing
    M          show syntax-/runtime-requirements
    1          show source expressions
    2          show canonicalized expressions
    3          show expressions converted into CPS
    4          show database after each analysis pass
    5          show expressions after each optimization pass
    6          show expressions after each inlining pass
    7          show expressions after complete optimization
    8          show database after final analysis
    9          show expressions after closure conversion</pre><dl><dt>-debug-level LEVEL</dt>
<dd>Selects amount of debug-information. <tt>LEVEL</tt> should be an integer.</dd></dl>
<pre>    -debug-level 0             is equivalent to -no-trace -no-lambda-info
    -debug-level 1             is equivalent to -no-trace
    -debug-level 2             is equivalent to -scrutinize</pre><dl><dt>-disable-interrupts</dt>
<dd>Equivalent to the <tt>(disable-interrupts)</tt> declaration. No interrupt-checks are generated for compiled programs.</dd><dt>-disable-stack-overflow-checks</dt>
<dd>Disables detection of stack overflows. This is equivalent to running the compiled executable with the <tt>-:o</tt> runtime option.</dd><dt>-dynamic</dt>
<dd>This option should be used when compiling files intended to be loaded dynamically into a running Scheme program.</dd><dt>-epilogue FILENAME</dt>
<dd>Includes the file named <tt>FILENAME</tt> at the end of the compiled source file. The include-path is not searched. This option may be given multiple times.</dd><dt>-emit-all-import-libraries</dt>
<dd>emit import libraries for all modules defined in the current compulation unit (see also: <tt>-emit-import-library</tt>).</dd><dt>-emit-external-prototypes-first</dt>
<dd>Emit prototypes for callbacks defined with <tt>define-external</tt> before any other foreign declarations. This is sometimes useful, when C/C++ code embedded into the a Scheme program has to access the callbacks. By default the prototypes are emitted after foreign declarations.</dd><dt>-emit-import-library MODULE</dt>
<dd>Specifies that an import library named <tt>MODULE.import.scm</tt> for the named module should be generated (equivalent to using the <tt>emit-import-library</tt> declaration).</dd><dt>-emit-inline-file FILENAME</dt>
<dd>Write procedures that can be globally inlined in internal form to <tt>FILENAME</tt>, if global inlining is enabled. Implies <tt>-inline -local</tt>. If the inline-file would be empty (because no procedure would be inlinable) no file is generated and any existing inline-file with that name is deleted.</dd><dt>-explicit-use</dt>
<dd>Disables automatic use of the units <tt>library, eval</tt> and <tt>extras</tt>. Use this option if compiling a library unit instead of an application unit.</dd><dt>-extend FILENAME</dt>
<dd>Loads a Scheme source file or compiled Scheme program (on systems that support it) before compilation commences. This feature can be used to extend the compiler.  This option may be given multiple times. The file is also searched in the current include path and in the extension-repository.</dd><dt>-feature SYMBOL</dt>
<dd>Registers <tt>SYMBOL</tt> to be a valid feature identifier for <tt>cond-expand</tt>. Multiple symbols may be given, if comma-separated.</dd><dt>-fixnum-arithmetic</dt>
<dd>Equivalent to <tt>(fixnum-arithmetic)</tt> declaration. Assume all mathematical operations use small integer arguments.</dd><dt>-heap-size NUMBER</dt>
<dd>Sets a fixed heap size of the generated executable to <tt>NUMBER</tt> bytes. The parameter may be followed by a  <tt>M</tt> (<tt>m</tt>) or <tt>K</tt> (<tt>k</tt>) suffix which stand for mega- and kilobytes, respectively.  The default heap size is 5 kilobytes. Note that only half of it is in use at every given time.</dd><dt>-heap-initial-size NUMBER</dt>
<dd>Sets the size that the heap of the compiled application should have at startup time.</dd><dt>-heap-growth PERCENTAGE</dt>
<dd>Sets the heap-growth rate for the compiled program at compile time (see: <tt>-:hg</tt>).</dd><dt>-heap-shrinkage PERCENTAGE</dt>
<dd>Sets the heap-shrinkage rate for the compiled program at compile time (see: <tt>-:hs</tt>).</dd><dt>-help</dt>
<dd>Print a summary of available options and the format of the command line parameters and exit the compiler.</dd><dt>-ignore-repository</dt>
<dd>Do not load any extensions from the repository (treat repository as empty). Also do not consult compiled (only interpreted) import libraries in <tt>import</tt> forms.</dd><dt>-include-path PATHNAME</dt>
<dd>Specifies an additional search path for files included via the <tt>include</tt> special form. This option may be given multiple times. If the environment variable <tt>CHICKEN_INCLUDE_PATH</tt> is set, it should contain a list of alternative include pathnames separated by <tt>;</tt>.</dd><dt>-inline</dt>
<dd>Enable procedure inlining for known procedures of a size below the threshold (which can be set through the <tt>-inline-limit</tt> option).</dd><dt>-inline-global</dt>
<dd>Enable cross-module inlining (in addition to local inlining). Implies <tt>-inline</tt>. For more information, see also <a href="Declarations.html">Declarations</a>.</dd><dt>-inline-limit THRESHOLD</dt>
<dd>Sets the maximum size of a potentially inlinable procedure. The default threshold is <tt>20</tt>.</dd><dt>-keyword-style STYLE</dt>
<dd>Enables alternative keyword syntax, where <tt>STYLE</tt> may be either <tt>prefix</tt> (as in Common Lisp, e.g. :keyword), <tt>suffix</tt> (as in DSSSL, e.g. keyword:) or <tt>none</tt>. Any other value is ignored. The default is <tt>suffix</tt>.</dd><dt>-keep-shadowed-macros</dt>
<dd>Do not remove macro definitions with the same name as assigned toplevel variables (the default is to remove the macro definition).</dd><dt>-local</dt>
<dd>Assume toplevel variables defined in the current compilation unit are not externally modified. This gives the compiler more opportunities for inlining. Note that this may result in counter-intuitive and non-standard behaviour: an asssignment to an exported toplevel variable executed in a different compilation unit or in evaluated code will possibly not be seen by code executing in the current compilation unit.</dd><dt>-module</dt>
<dd>wraps the compiled code in an implicit module named <tt>main</tt>, importing the <tt>scheme</tt> and <tt>chicken</tt> modules.</dd><dt>-no-argc-checks</dt>
<dd>disable argument count checks</dd><dt>-no-bound-checks</dt>
<dd>disable bound variable checks</dd><dt>-no-feature SYMBOL</dt>
<dd>Disables the predefined feature-identifier <tt>SYMBOL</tt>. Multiple symbols may be given, if comma-separated.</dd><dt>-no-lambda-info</dt>
<dd>Don't emit additional information for each <tt>lambda</tt> expression (currently the argument-list, after alpha-conversion/renaming).</dd><dt>-no-module-registration</dt>
<dd>Do not generate module-registration code in the compiled code. This is only needed if you want to use an import library that is generated by other means (manually, for example).</dd><dt>-no-parentheses-synonyms STYLE</dt>
<dd>Disables list delimiter synonyms, [..] and {...} for (...).</dd><dt>-no-procedure-checks</dt>
<dd>disable procedure call checks</dd><dt>-no-procedure-checks-for-usual-bindings</dt>
<dd>disable procedure call checks only for usual bindings</dd><dt>-no-procedure-checks-for-toplevel-bindings</dt>
<dd>disable bound and procedure call checks for calls to procedures referenced through a toplevel variable.</dd><dt>-no-symbol-escape</dt>
<dd>Disables support for escaped symbols, the |...| form.</dd><dt>-no-trace</dt>
<dd>Disable generation of tracing information. If a compiled executable should halt due to a runtime error, then a list of the name and the line-number (if available) of the last procedure calls is printed, unless <tt>-no-trace</tt> is specified. With this option the generated code is slightly faster.</dd><dt>-no-warnings</dt>
<dd>Disable generation of compiler warnings.</dd><dt>-nursery NUMBER</dt>
<dt>-stack-size NUMBER</dt>
<dd>Sets the size of the first heap-generation of the generated executable to <tt>NUMBER</tt> bytes. The parameter may be followed by a <tt>M</tt> (<tt>m</tt>) or <tt>K</tt> (<tt>k</tt>) suffix.  The default stack-size depends on the target platform.</dd><dt>-optimize-leaf-routines</dt>
<dd>Enable leaf routine optimization.</dd><dt>-optimize-level LEVEL</dt>
<dd>Enables certain sets of optimization options. <tt>LEVEL</tt> should be an integer.</dd></dl>
<pre>    -optimize-level 0          is equivalent to -no-usual-integrations -no-compiler-syntax
    -optimize-level 1          is equivalent to -optimize-leaf-routines
    -optimize-level 2          is equivalent to -optimize-leaf-routines -inline -unboxing
    -optimize-level 3          is equivalent to -optimize-leaf-routines -local -inline -inline-global -unboxing
    -optimize-level 4          is equivalent to -optimize-leaf-routines -local -inline -inline-global -unboxing -unsafe
    -optimize-level 5          is equivalent to -optimize-leaf-routines -block -inline -inline-global -unsafe -unboxing -disable-interrupts -no-trace -no-lambda-info</pre><dl><dt>-output-file FILENAME</dt>
<dd>Specifies the pathname of the generated C file. Default is <tt>FILENAME.c</tt>.</dd><dt>-postlude EXPRESSIONS</dt>
<dd>Add <tt>EXPRESSIONS</tt> after all other toplevel expressions in the compiled file.  This option may be given multiple times. Processing of this option takes place after processing of <tt>-epilogue</tt>.</dd><dt>-prelude EXPRESSIONS</dt>
<dd>Add <tt>EXPRESSIONS</tt> before all other toplevel expressions in the compiled file.  This option may be given multiple times. Processing of this option takes place before processing of <tt>-prologue</tt>.</dd><dt>-profile</dt>
<dt>-accumulate-profile</dt>
<dd>Instruments the source code to count procedure calls and execution times. After the program terminates (either via an explicit <tt>exit</tt> or implicitly), profiling statistics are written to a file named <tt>PROFILE.&lt;randomnumber&gt;</tt>. Each line of the generated file contains a list with the procedure name, the number of calls and the time spent executing it. Use the <tt>chicken-profile</tt> program to display the profiling information in a more user-friendly form. Enter <tt>chicken-profile</tt> with no arguments at the command line to get a list of available options. The <tt>-accumulate-profile</tt> option is similar to <tt>-profile</tt>, but the resulting profile information will be appended to any existing <tt>PROFILE</tt> file. <tt>chicken-profile</tt> will merge and sum up the accumulated timing information, if several entries for the same procedure calls exist. Only profiling information for global procedures will be collected.</dd><dt>-profile-name FILENAME</dt>
<dd>Specifies name of the generated profile information (which defaults to <tt>PROFILE.&lt;randomnumber&gt;</tt>. Implies <tt>-profile</tt>.</dd><dt>-prologue FILENAME</dt>
<dd>Includes the file named <tt>FILENAME</tt> at the start of the compiled source file.  The include-path is not searched. This option may be given multiple times.</dd><dt>-r5rs-syntax</dt>
<dd>Disables the Chicken extensions to R5RS syntax. Does not disable <a href="Non-standard%20read%20syntax.html">non-standard read syntax</a>.</dd><dt>-raw</dt>
<dd>Disables the generation of any implicit code that uses the Scheme libraries (that is all runtime system files besides <tt>runtime.c</tt> and <tt>chicken.h</tt>).</dd><dt>-require-extension NAME</dt>
<dd>Loads the extension <tt>NAME</tt> before the compilation process commences. This is identical to adding <tt>(require-extension NAME)</tt> at the start of the compiled program. If <tt>-uses NAME</tt> is also given on the command line, then any occurrences of <tt>-require-extension NAME</tt> are replaced with <tt>(declare (uses NAME))</tt>. Multiple names may be given and should be separated by <tt>,</tt>.</dd></dl>
<pre></pre><dl><dt>-setup-mode</dt>
<dd>When locating extension, search the current directory first. By default, extensions are located first in the <i>extension repository</i>, where <tt>chicken-install</tt> stores compiled extensions and their associated metadata.</dd><dt>-scrutinize</dt>
<dd>Enable simple flow-analysis to catch common type errors and argument/result mismatches. You can also use the <tt>scrutinize</tt> declaration to enable scrutiny.</dd><dt>-static-extension NAME</dt>
<dd>similar to <tt>-require-extension NAME</tt>, but links extension statically (also applies for an explicit <tt>(require-extension NAME)</tt>).</dd><dt>-types FILENAME</dt>
<dd>load additional type database from <tt>FILENAME</tt>. Type-definitions in <tt>FILENAME</tt> will override previous type-definitions.</dd><dt>-compile-syntax</dt>
<dd>Makes macros also available at run-time. By default macros are not available at run-time.</dd><dt>-to-stdout</dt>
<dd>Write compiled code to standard output instead of creating a <tt>.c</tt> file.</dd><dt>-unboxing</dt>
<dd>try to use unboxed temporaries for numerical operations. This optimization is only effective in unsafe mode.</dd><dt>-unit NAME</dt>
<dd>Compile this file as a library unit. Equivalent to <tt>-prelude &quot;(declare (unit NAME))&quot;</tt></dd><dt>-unsafe</dt>
<dd>Disable runtime safety checks.</dd><dt>-uses NAME</dt>
<dd>Use definitions from the library unit <tt>NAME</tt>. This is equivalent to <tt>-prelude &quot;(declare (uses NAME))&quot;</tt>. Multiple arguments may be given, separated by <tt>,</tt>.</dd><dt>-no-usual-integrations</dt>
<dd>Specifies that standard procedures and certain internal procedures may be redefined, and can not be inlined. This is equivalent to declaring <tt>(not usual-integrations)</tt>.</dd><dt>-version</dt>
<dd>Prints the version and some copyright information and exit the compiler.</dd><dt>-verbose</dt>
<dd>Prints progress information to standard output during compilation.</dd></dl>
<p>The environment variable <tt>CHICKEN_OPTIONS</tt> can be set to a string with default command-line options for the compiler.</p><h4 id="sec:Further_options"><a href="#sec:Further_options">Further options</a></h4><p>Enter</p><pre> csc -help</pre><p>to see a list of all supported options and short aliases to basic options.</p><h3 id="sec:Runtime_options"><a href="#sec:Runtime_options">Runtime options</a></h3><p>After successful compilation a C source file is generated and can be compiled with a C compiler. Executables generated with CHICKEN (and the compiler itself) accept a small set of runtime options:</p><dl><dt><tt>-:?</tt></dt>
<dd>Shows a list of the available runtime options and exits the program.</dd><dt><tt>-:aNUMBER</tt></dt>
<dd>Specifies the length of the buffer for recording a trace of the last invoked procedures. Defaults to 16.</dd><dt><tt>-:b</tt></dt>
<dd>Enter a read-eval-print-loop when an error is encountered.</dd><dt><tt>-:B</tt></dt>
<dd>Sounds a bell (ASCII 7) on every major garbage collection.</dd><dt><tt>-:c</tt></dt>
<dd>Forces console mode. Currently this is only used in the interpreter (<tt>csi</tt>) to force output of the <tt>#;N&gt;</tt> prompt even if stdin is not a terminal (for example if running in an <tt>emacs</tt> buffer under Windows).</dd><dt><tt>-:d</tt></dt>
<dd>Prints some debug-information at runtime.</dd><dt><tt>-:D</tt></dt>
<dd>Prints some more debug-information at runtime.</dd><dt><tt>-:g</tt></dt>
<dd>Prints information about garbage-collection.</dd><dt><tt>-:G</tt></dt>
<dd>Force GUI mode (show error messages in dialog box, suitable for platform).</dd><dt><tt>-:H</tt></dt>
<dd>Before terminating, dump heap usage to stderr.</dd><dt><tt>-:fNUMBER</tt></dt>
<dd>Specifies the maximal number of currently pending finalizers before finalization is forced.</dd><dt><tt>-:hNUMBER</tt></dt>
<dd>Specifies fixed heap size</dd><dt><tt>-:hgPERCENTAGE</tt></dt>
<dd>Sets the growth rate of the heap in percent. If the heap is exhausted, then it will grow by <tt>PERCENTAGE</tt>. The default is 200.</dd><dt><tt>-:hiNUMBER</tt></dt>
<dd>Specifies the initial heap size</dd><dt><tt>-:hmNUMBER</tt></dt>
<dd>Specifies a maximal heap size. The default is (2GB - 15).</dd><dt><tt>-:hsPERCENTAGE</tt></dt>
<dd>Sets the shrink rate of the heap in percent. If no more than a quarter of <tt>PERCENTAGE</tt> of the heap is used, then it will shrink to <tt>PERCENTAGE</tt>. The default is 50.  Note: If you want to make sure that the heap never shrinks, specify a value of <tt>0</tt>.  (this can be useful in situations where an optimal heap-size is known in advance). </dd><dt><tt>-:o</tt></dt>
<dd>Disables detection of stack overflows at run-time.</dd><dt><tt>-:r</tt></dt>
<dd>Writes trace output to stderr. This option has no effect with in files compiled with the <tt>-no-trace</tt> options.</dd><dt><tt>-:sNUMBER</tt></dt>
<dd>Specifies stack size.</dd><dt><tt>-:tNUMBER</tt></dt>
<dd>Specifies symbol table size.</dd><dt><tt>-:w</tt></dt>
<dd>Enables garbage collection of unused symbols. By default unused and unbound symbols are not garbage collected.</dd><dt><tt>-:x</tt></dt>
<dd>Raises uncaught exceptions of separately spawned threads in primordial thread. By default uncaught exceptions in separate threads are not handled, unless the primordial one explicitly joins them. When warnings are enabled (the default) and <tt>-:x</tt> is not given, a warning will be shown, though.</dd></dl>
<p>The argument values may be given in bytes, in kilobytes (suffixed with <tt>K</tt> or <tt>k</tt>), in megabytes (suffixed with <tt>M</tt> or <tt>m</tt>), or in gigabytes (suffixed with <tt>G</tt> or <tt>g</tt>). Runtime options may be combined, like <tt>-:dc</tt>, but everything following a <tt>NUMBER</tt> argument is ignored. So <tt>-:wh64m</tt> is OK, but <tt>-:h64mw</tt> will not enable GC of unused symbols.</p><h3 id="sec:Examples"><a href="#sec:Examples">Examples</a></h3><h4 id="sec:A_simple_example_.28with_one_source_file.29"><a href="#sec:A_simple_example_.28with_one_source_file.29">A simple example (with one source file)</a></h4><p>To compile a Scheme program (assuming a UNIX-like environment) consisting of a single source file, perform the following steps.</p><h5 id="sec:Writing_your_source_file"><a href="#sec:Writing_your_source_file">Writing your source file</a></h5><p>In this example we will assume your source file is called <tt>foo.scm</tt>:</p><pre class="highlight"><span class="comment">;;; foo.scm
</span>
<span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">fac n</span>)</span>
  <span class="paren2">(<span class="default"><i><span class="symbol">if</span></i> <span class="paren3">(<span class="default">zero? n</span>)</span>
      1
      <span class="paren3">(<span class="default">* n <span class="paren4">(<span class="default">fac <span class="paren5">(<span class="default">- n 1</span>)</span></span>)</span></span>)</span> </span>)</span> </span>)</span>

<span class="paren1">(<span class="default">write <span class="paren2">(<span class="default">fac 10</span>)</span></span>)</span>
<span class="paren1">(<span class="default">newline</span>)</span></pre><h5 id="sec:Compiling_your_program"><a href="#sec:Compiling_your_program">Compiling your program</a></h5><p>Compile the file <tt>foo.scm</tt>:</p><pre>% csc foo.scm</pre><p>This will produce the <tt>foo</tt> executable:</p><pre>% ls
foo  foo.scm</pre><h5 id="sec:Running_your_program"><a href="#sec:Running_your_program">Running your program</a></h5><p>To run your newly compiled executable use:</p><pre>% foo
3628800</pre><p>If you get a <tt>foo: command not found</tt> error, you might want to try with <tt>./foo</tt> instead (or, in Unix machines, modify your <tt>PATH</tt> environment variable to include your current directory).</p><h4 id="sec:An_example_with_multiple_files"><a href="#sec:An_example_with_multiple_files">An example with multiple files</a></h4><p>If multiple bodies of Scheme code are to be combined into a single executable, then we have to compile each file and link the resulting object files together with the runtime system.</p><p>Let's consider an example where your program consists of multiple source files.</p><h5 id="sec:Writing_your_source_files"><a href="#sec:Writing_your_source_files">Writing your source files</a></h5><p>The declarations in these files specify which of the compiled files is the main module, and which is the library module. An executable can only have one main module, since a program has only a single entry-point. In this case <tt>foo.scm</tt> is the main module, because it doesn't have a <tt>unit</tt> declaration:</p><pre class="highlight"><span class="comment">;;; foo.scm
</span>
<span class="comment">; The declaration marks this source file as dependant on the symbols provided
</span><span class="comment">; by the bar unit:
</span><span class="paren1">(<span class="default">declare <span class="paren2">(<span class="default">uses bar</span>)</span></span>)</span>

<span class="paren1">(<span class="default">write <span class="paren2">(<span class="default">fac 10</span>)</span></span>)</span> <span class="paren1">(<span class="default">newline</span>)</span></pre><p><tt>bar.scm</tt> will be our library:</p><pre class="highlight"><span class="comment">;;; bar.scm
</span>
<span class="comment">; The declaration marks this source file as the bar unit.  The names of the
</span><span class="comment">; units and your files don&#x27;t need to match.
</span><span class="paren1">(<span class="default">declare <span class="paren2">(<span class="default">unit bar</span>)</span></span>)</span>

<span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">fac n</span>)</span>
  <span class="paren2">(<span class="default"><i><span class="symbol">if</span></i> <span class="paren3">(<span class="default">zero? n</span>)</span>
      1
      <span class="paren3">(<span class="default">* n <span class="paren4">(<span class="default">fac <span class="paren5">(<span class="default">- n 1</span>)</span></span>)</span></span>)</span> </span>)</span> </span>)</span></pre><h5 id="sec:Compiling_and_running_your_program"><a href="#sec:Compiling_and_running_your_program">Compiling and running your program</a></h5><p>You should compile your two files with the following commands:</p><pre>% csc -c bar.scm
% csc -c foo.scm</pre><p>That should produce two files, <tt>bar.o</tt> and <tt>foo.o</tt>. They contain the code from your source files in compiled form.</p><p>To link your compiled files use the following command:</p><pre>% csc foo.o bar.o -o foo</pre><p>This should produce the <tt>foo</tt> executable, which you can run just as in the previous example. At this point you can also erase the <tt>*.o</tt> files.</p><p>You could avoid one step and link the two files just as <tt>foo.scm</tt> is compiled:</p><pre>% csc -c bar.scm
% csc foo.scm bar.o -o foo</pre><p>Note that if you want to distribute your program, you might want it to follow the GNU Coding Standards.  One relatively easy way to achieve this is to use Autoconf and Automake, two tools made for this specific purpose.</p><h3 id="sec:Extending_the_compiler"><a href="#sec:Extending_the_compiler">Extending the compiler</a></h3><p>The compiler supplies a couple of hooks to add user-level passes to the compilation process. Before compilation commences any Scheme source files or compiled code specified using the <tt>-extend</tt> option are loaded and evaluated.  The parameters <tt>user-options-pass, user-read-pass, user-preprocessor-pass, user-pass</tt> and <tt>user-post-analysis-pass</tt> can be set to procedures that are called to perform certain compilation passes instead of the usual processing (for more information about parameters see: <a href="Supported%20language.html">Supported language</a>.</p><dl class="defsig"><dt class="defsig" id="def:user-options-pass"><span class="sig"><tt>user-options-pass</tt></span> <span class="type">parameter</span></dt>
<dd class="defsig"><p>Holds a procedure that will be called with a list of command-line arguments and should return two values: the source filename and the actual list of options, where compiler switches have their leading <tt>-</tt> (hyphen) removed and are converted to symbols.  Note that this parameter is invoked <b>before</b> processing of the <tt>-extend</tt> option, and so can only be changed in compiled user passes.</p></dd>
</dl>
<dl class="defsig"><dt class="defsig" id="def:user-read-pass"><span class="sig"><tt>user-read-pass</tt></span> <span class="type">parameter</span></dt>
<dd class="defsig"><p>Holds a procedure of three arguments. The first argument is a list of strings with the code passed to the compiler via <tt>-prelude</tt> options. The second argument is a list of source files including any files specified by <tt>-prologue</tt> and <tt>-epilogue</tt>. The third argument is a list of strings specified using <tt>-postlude</tt> options. The procedure should return a list of toplevel Scheme expressions.</p></dd>
</dl>
<dl class="defsig"><dt class="defsig" id="def:user-preprocessor-pass"><span class="sig"><tt>user-preprocessor-pass</tt></span> <span class="type">parameter</span></dt>
<dd class="defsig"><p>Holds a procedure of one argument. This procedure is applied to each toplevel expression in the source file <b>before</b> macro-expansion. The result is macro-expanded and compiled in place of the original expression.</p></dd>
</dl>
<dl class="defsig"><dt class="defsig" id="def:user-pass"><span class="sig"><tt>user-pass</tt></span> <span class="type">parameter</span></dt>
<dd class="defsig"><p>Holds a procedure of one argument. This procedure is applied to each toplevel expression <b>after</b> macro-expansion.  The result of the procedure is then compiled in place of the original expression.</p></dd>
</dl>
<dl class="defsig"><dt class="defsig" id="def:user-post-analysis-pass"><span class="sig"><tt>user-post-analysis-pass</tt></span> <span class="type">parameter</span></dt>
<dd class="defsig"><p>Holds a procedure that will be called after every performed program analysis pass. The procedure (when defined) will be called with seven arguments: a symbol indicating the analysis pass, the program database, the current node graph, a getter and a setter-procedure which can be used to access and manipulate the program database, which holds various information about the compiled program, a pass iteration count, and an analysis continuation flag. The getter procedure should be called with two arguments: a symbol representing the binding for which information should be retrieved, and a symbol that specifies the database-entry. The current value of the database entry will be returned or <tt>#f</tt>, if no such entry is available. The setter procedure is called with three arguments: the symbol and key and the new value. The pass iteration count currently is meaningful only for the 'opt pass. The analysis continuation flag will be <tt>#f</tt> for the last 'opt pass. For information about the contents of the program database contact the author.</p><p>Loaded code (via the <tt>-extend</tt> option) has access to the library units <tt>extras, srfi-1, srfi-4, utils, regex</tt> and the pattern matching macros. Multithreading is not available.</p><p>Note that the macroexpansion/canonicalization phase of the compiler adds certain forms to the source program.  These extra expressions are not seen by <tt>user-preprocessor-pass</tt> but by <tt>user-pass</tt>.</p></dd>
</dl>
<h3 id="sec:Distributing_compiled_C_files"><a href="#sec:Distributing_compiled_C_files">Distributing compiled C files</a></h3><p>It is relatively easy to create distributions of Scheme projects that have been compiled to C.  The runtime system of CHICKEN consists of only two handcoded C files (<tt>runtime.c</tt> and <tt>chicken.h</tt>), plus the file <tt>chicken-config.h</tt>, which is generated by the build process. All other modules of the runtime system and the extension libraries are just compiled Scheme code. The following example shows a minimal application, which should run without changes on the most frequent operating systems, like Windows, Linux or FreeBSD:</p><p>Let's take a simple example.</p><pre class="highlight"><span class="comment">; hello.scm
</span>
<span class="paren1">(<span class="default">print <span class="string">&quot;Hello, world!&quot;</span></span>)</span></pre><pre> % csc -t hello.scm -optimize-level 3 -output-file hello.c</pre><p>Compiled to C, we get <tt>hello.c</tt>. We need the files <tt>chicken.h</tt> and <tt>runtime.c</tt>, which contain the basic runtime system, plus the three basic library files <tt>library.c</tt>, <tt>eval.c</tt> and <tt>extras.c</tt> which contain the same functionality as the library linked into a plain CHICKEN-compiled application, or which is available by default in the interpreter, <tt>csi</tt>:</p><pre> % cd /tmp
 %echo '(print &quot;Hello World.&quot;)' &gt; hello.scm
 % cp $CHICKEN_BUILD/runtime.c .
 % cp $CHICKEN_BUILD/library.c .
 % cp $CHICKEN_BUILD/eval.c    .
 % cp $CHICKEN_BUILD/extras.c  .
 % gcc -static -Os -fomit-frame-pointer runtime.c library.c eval.c \
   extras.c hello.c -o hello -lm</pre><p>Now we have all files together, and can create an tarball containing all the files:</p><pre>% tar cf hello.tar Makefile hello.c runtime.c library.c eval.c extras.c chicken.h
% gzip hello.tar</pre><p>This is naturally rather simplistic. Things like enabling dynamic loading, estimating the optimal stack-size and selecting supported features of the host system would need more configuration- and build-time support. All this can be addressed using more elaborate build-scripts, makefiles or by using autoconf/automake.</p><p>Note also that the size of the application can still be reduced by removing <tt>extras</tt> and <tt>eval</tt> and compiling <tt>hello.scm</tt> with the <tt>-explicit-use</tt> option.</p><p>For more information, study the CHICKEN source code and/or get in contact with the author.</p><hr /><p>Previous: <a href="Basic%20mode%20of%20operation.html">Basic mode of operation</a></p><p>Next: <a href="Using%20the%20interpreter.html">Using the interpreter</a></p></div></div></body>