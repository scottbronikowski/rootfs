<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_23) on Mon Oct 17 19:54:04 UTC 2011 -->
<TITLE>
ExpressionParser
</TITLE>

<META NAME="date" CONTENT="2011-10-17">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ExpressionParser";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/sf/saxon/expr/ExpressionLocation.html" title="class in net.sf.saxon.expr"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../net/sf/saxon/expr/ExpressionParser.ForClause.html" title="class in net.sf.saxon.expr"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/sf/saxon/expr/ExpressionParser.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ExpressionParser.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.sf.saxon.expr</FONT>
<BR>
Class ExpressionParser</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><B>net.sf.saxon.expr.ExpressionParser</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../../net/sf/saxon/query/QueryParser.html" title="class in net.sf.saxon.query">QueryParser</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>ExpressionParser</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Parser for XPath expressions and XSLT patterns.

 This code was originally inspired by James Clark's xt but has been totally rewritten (several times)
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Michael Kay</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.ForClause.html" title="class in net.sf.saxon.expr">ExpressionParser.ForClause</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.TemporaryContainer.html" title="class in net.sf.saxon.expr">ExpressionParser.TemporaryContainer</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#compileWithTracing">compileWithTracing</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#env">env</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#language">language</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/om/NameChecker.html" title="class in net.sf.saxon.om">NameChecker</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#nameChecker">nameChecker</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Stack</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#rangeVariables">rangeVariables</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#scanOnly">scanOnly</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#SEQUENCE_TYPE">SEQUENCE_TYPE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Tokenizer.html" title="class in net.sf.saxon.expr">Tokenizer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#t">t</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#XPATH">XPATH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#XQUERY">XQUERY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#XSLT_PATTERN">XSLT_PATTERN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#ExpressionParser()">ExpressionParser</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an expression parser</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#currentTokenDisplay()">currentTokenDisplay</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Display the current token in an error message</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#declareRangeVariable(net.sf.saxon.expr.Binding)">declareRangeVariable</A></B>(<A HREF="../../../../net/sf/saxon/expr/Binding.html" title="interface in net.sf.saxon.expr">Binding</A>&nbsp;declaration)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Declare a range variable (record its existence within the parser).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#expect(int)">expect</A></B>(int&nbsp;token)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expect a given token; fail if the current token is different.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#getLanguage()">getLanguage</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the current language (XPath or XQuery)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Stack</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#getRangeVariableStack()">getRangeVariableStack</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the range variable stack.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/sf/saxon/expr/Tokenizer.html" title="class in net.sf.saxon.expr">Tokenizer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#getTokenizer()">getTokenizer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the tokenizer (the lexical analyzer)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#grumble(java.lang.String)">grumble</A></B>(java.lang.String&nbsp;message)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Report a syntax error (a static error with error code XP0003)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#grumble(java.lang.String, java.lang.String)">grumble</A></B>(java.lang.String&nbsp;message,
        java.lang.String&nbsp;errorCode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Report a static error</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#isCompileWithTracing()">isCompileWithTracing</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine whether trace hooks are included in the compiled code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#isKeyword(java.lang.String)">isKeyword</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test whether the current token is a given keyword.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/sf/saxon/pattern/LocalNameTest.html" title="class in net.sf.saxon.pattern">LocalNameTest</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#makeLocalNameTest(short, java.lang.String)">makeLocalNameTest</A></B>(short&nbsp;nodeType,
                  java.lang.String&nbsp;localName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a LocalNameTest (*:name)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#makeNameCode(java.lang.String, boolean)">makeNameCode</A></B>(java.lang.String&nbsp;qname,
             boolean&nbsp;useDefault)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a NameCode, using the static context for namespace resolution</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#makeNameCodeSilently(java.lang.String, boolean)">makeNameCodeSilently</A></B>(java.lang.String&nbsp;qname,
                     boolean&nbsp;useDefault)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a NameCode, using the static context for namespace resolution.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/sf/saxon/pattern/NamespaceTest.html" title="class in net.sf.saxon.pattern">NamespaceTest</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#makeNamespaceTest(short, java.lang.String)">makeNamespaceTest</A></B>(short&nbsp;nodeType,
                  java.lang.String&nbsp;prefix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a NamespaceTest (name:*)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/sf/saxon/pattern/NameTest.html" title="class in net.sf.saxon.pattern">NameTest</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#makeNameTest(short, java.lang.String, boolean)">makeNameTest</A></B>(short&nbsp;nodeType,
             java.lang.String&nbsp;qname,
             boolean&nbsp;useDefault)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a NameTest, using the static context for namespace resolution</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Literal.html" title="class in net.sf.saxon.expr">Literal</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#makeStringLiteral(java.lang.String)">makeStringLiteral</A></B>(java.lang.String&nbsp;currentTokenValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method to make a string literal from a token identified as a string
 literal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/sf/saxon/om/StructuredQName.html" title="class in net.sf.saxon.om">StructuredQName</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#makeStructuredQName(java.lang.String, boolean)">makeStructuredQName</A></B>(java.lang.String&nbsp;qname,
                    boolean&nbsp;useDefault)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a Structured QName, using the static context for namespace resolution</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#makeTracer(int, net.sf.saxon.expr.Expression, int, net.sf.saxon.om.StructuredQName)">makeTracer</A></B>(int&nbsp;startOffset,
           <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;exp,
           int&nbsp;construct,
           <A HREF="../../../../net/sf/saxon/om/StructuredQName.html" title="class in net.sf.saxon.om">StructuredQName</A>&nbsp;qName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If tracing, wrap an expression in a trace instruction</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#nextToken()">nextToken</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read the next token, catching any exception thrown by the tokenizer</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parse(java.lang.String, int, int, int, net.sf.saxon.expr.StaticContext)">parse</A></B>(java.lang.String&nbsp;expression,
      int&nbsp;start,
      int&nbsp;terminator,
      int&nbsp;lineNumber,
      <A HREF="../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A>&nbsp;env)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a string representing an expression</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseConstructor()">parseConstructor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a node constructor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseExpression()">parseExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a top-level Expression:
 ExprSingle ( ',' ExprSingle )*</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseExprSingle()">parseExprSingle</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse an ExprSingle</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseExtensionExpression()">parseExtensionExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse an Extension Expression
 This construct is XQuery-only, so the XPath version of this
 method throws an error unconditionally</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseForExpression()">parseForExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a FOR expression:
 for $x in expr (',' $y in expr)* 'return' expr</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseFunctionCall()">parseFunctionCall</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a function call.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseMappingExpression()">parseMappingExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a mapping expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/pattern/NodeTest.html" title="class in net.sf.saxon.pattern">NodeTest</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseNodeTest(short)">parseNodeTest</A></B>(short&nbsp;nodeType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a NodeTest.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/sf/saxon/pattern/Pattern.html" title="class in net.sf.saxon.pattern">Pattern</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parsePattern(java.lang.String, net.sf.saxon.expr.StaticContext)">parsePattern</A></B>(java.lang.String&nbsp;pattern,
             <A HREF="../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A>&nbsp;env)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a string representing an XSLT pattern</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseRelativePath()">parseRelativePath</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a relative path (a sequence of steps).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseRemainingPath(net.sf.saxon.expr.Expression)">parseRemainingPath</A></B>(<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;start)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse the remaining steps of an absolute path expression (one starting in "/" or "//").</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/value/SequenceType.html" title="class in net.sf.saxon.value">SequenceType</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseSequenceType()">parseSequenceType</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse the sequence type production.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/sf/saxon/value/SequenceType.html" title="class in net.sf.saxon.value">SequenceType</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseSequenceType(java.lang.String, net.sf.saxon.expr.StaticContext)">parseSequenceType</A></B>(java.lang.String&nbsp;input,
                  <A HREF="../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A>&nbsp;env)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a string representing a sequence type</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseStepExpression()">parseStepExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a step (including an optional sequence of predicates)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseTypeswitchExpression()">parseTypeswitchExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a Typeswitch Expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseValidateExpression()">parseValidateExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a Validate Expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#setCompileWithTracing(boolean)">setCompileWithTracing</A></B>(boolean&nbsp;trueOrFalse)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set whether trace hooks are to be included in the compiled code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#setLocation(net.sf.saxon.expr.Expression)">setLocation</A></B>(<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;exp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set location information on an expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#setLocation(net.sf.saxon.expr.Expression, int)">setLocation</A></B>(<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;exp,
            int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set location information on an expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#setRangeVariableStack(java.util.Stack)">setRangeVariableStack</A></B>(java.util.Stack&nbsp;stack)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the range variable stack.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#setScanOnly(boolean)">setScanOnly</A></B>(boolean&nbsp;scanOnly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set that we are parsing in "scan only"</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#undeclareRangeVariable()">undeclareRangeVariable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note when the most recently declared range variable has gone out of scope</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#warning(java.lang.String)">warning</A></B>(java.lang.String&nbsp;message)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Output a warning message</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="t"><!-- --></A><H3>
t</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Tokenizer.html" title="class in net.sf.saxon.expr">Tokenizer</A> <B>t</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="env"><!-- --></A><H3>
env</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A> <B>env</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="rangeVariables"><!-- --></A><H3>
rangeVariables</H3>
<PRE>
protected java.util.Stack <B>rangeVariables</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="nameChecker"><!-- --></A><H3>
nameChecker</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/om/NameChecker.html" title="class in net.sf.saxon.om">NameChecker</A> <B>nameChecker</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="scanOnly"><!-- --></A><H3>
scanOnly</H3>
<PRE>
protected boolean <B>scanOnly</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="compileWithTracing"><!-- --></A><H3>
compileWithTracing</H3>
<PRE>
protected boolean <B>compileWithTracing</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="language"><!-- --></A><H3>
language</H3>
<PRE>
protected int <B>language</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="XPATH"><!-- --></A><H3>
XPATH</H3>
<PRE>
protected static final int <B>XPATH</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#net.sf.saxon.expr.ExpressionParser.XPATH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="XSLT_PATTERN"><!-- --></A><H3>
XSLT_PATTERN</H3>
<PRE>
protected static final int <B>XSLT_PATTERN</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#net.sf.saxon.expr.ExpressionParser.XSLT_PATTERN">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SEQUENCE_TYPE"><!-- --></A><H3>
SEQUENCE_TYPE</H3>
<PRE>
protected static final int <B>SEQUENCE_TYPE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#net.sf.saxon.expr.ExpressionParser.SEQUENCE_TYPE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="XQUERY"><!-- --></A><H3>
XQUERY</H3>
<PRE>
protected static final int <B>XQUERY</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#net.sf.saxon.expr.ExpressionParser.XQUERY">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ExpressionParser()"><!-- --></A><H3>
ExpressionParser</H3>
<PRE>
public <B>ExpressionParser</B>()</PRE>
<DL>
<DD>Create an expression parser
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="setCompileWithTracing(boolean)"><!-- --></A><H3>
setCompileWithTracing</H3>
<PRE>
public void <B>setCompileWithTracing</B>(boolean&nbsp;trueOrFalse)</PRE>
<DL>
<DD>Set whether trace hooks are to be included in the compiled code. To use tracing, it is necessary
 both to compile the code with trace hooks included, and to supply a TraceListener at run-time
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>trueOrFalse</CODE> - true if trace code is to be compiled in, false otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="isCompileWithTracing()"><!-- --></A><H3>
isCompileWithTracing</H3>
<PRE>
public boolean <B>isCompileWithTracing</B>()</PRE>
<DL>
<DD>Determine whether trace hooks are included in the compiled code.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if trace hooks are included, false if not.</DL>
</DD>
</DL>
<HR>

<A NAME="getTokenizer()"><!-- --></A><H3>
getTokenizer</H3>
<PRE>
public <A HREF="../../../../net/sf/saxon/expr/Tokenizer.html" title="class in net.sf.saxon.expr">Tokenizer</A> <B>getTokenizer</B>()</PRE>
<DL>
<DD>Get the tokenizer (the lexical analyzer)
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the tokenizer (the lexical analyzer)</DL>
</DD>
</DL>
<HR>

<A NAME="nextToken()"><!-- --></A><H3>
nextToken</H3>
<PRE>
protected void <B>nextToken</B>()
                  throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Read the next token, catching any exception thrown by the tokenizer
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="expect(int)"><!-- --></A><H3>
expect</H3>
<PRE>
protected void <B>expect</B>(int&nbsp;token)
               throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Expect a given token; fail if the current token is different. Note that this method
 does not read any tokens.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>token</CODE> - the expected token
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if the current token is not the expected
     token</DL>
</DD>
</DL>
<HR>

<A NAME="grumble(java.lang.String)"><!-- --></A><H3>
grumble</H3>
<PRE>
protected void <B>grumble</B>(java.lang.String&nbsp;message)
                throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Report a syntax error (a static error with error code XP0003)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>message</CODE> - the error message
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - always thrown: an exception containing the
     supplied message</DL>
</DD>
</DL>
<HR>

<A NAME="grumble(java.lang.String, java.lang.String)"><!-- --></A><H3>
grumble</H3>
<PRE>
protected void <B>grumble</B>(java.lang.String&nbsp;message,
                       java.lang.String&nbsp;errorCode)
                throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Report a static error
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>message</CODE> - the error message<DD><CODE>errorCode</CODE> - the error code
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - always thrown: an exception containing the
     supplied message</DL>
</DD>
</DL>
<HR>

<A NAME="warning(java.lang.String)"><!-- --></A><H3>
warning</H3>
<PRE>
protected void <B>warning</B>(java.lang.String&nbsp;message)
                throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Output a warning message
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>message</CODE> - the text of the message
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getLanguage()"><!-- --></A><H3>
getLanguage</H3>
<PRE>
protected java.lang.String <B>getLanguage</B>()</PRE>
<DL>
<DD>Get the current language (XPath or XQuery)
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a string representation of the language being parsed, for use in error messages</DL>
</DD>
</DL>
<HR>

<A NAME="currentTokenDisplay()"><!-- --></A><H3>
currentTokenDisplay</H3>
<PRE>
protected java.lang.String <B>currentTokenDisplay</B>()</PRE>
<DL>
<DD>Display the current token in an error message
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the display representation of the token</DL>
</DD>
</DL>
<HR>

<A NAME="parse(java.lang.String, int, int, int, net.sf.saxon.expr.StaticContext)"><!-- --></A><H3>
parse</H3>
<PRE>
public <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>parse</B>(java.lang.String&nbsp;expression,
                        int&nbsp;start,
                        int&nbsp;terminator,
                        int&nbsp;lineNumber,
                        <A HREF="../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A>&nbsp;env)
                 throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse a string representing an expression
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>expression</CODE> - the expression expressed as a String<DD><CODE>start</CODE> - offset within the string where parsing is to start<DD><CODE>terminator</CODE> - character to treat as terminating the expression<DD><CODE>lineNumber</CODE> - location of the start of the expression, for diagnostics<DD><CODE>env</CODE> - the static context for the expression
<DT><B>Returns:</B><DD>an Expression object representing the result of parsing
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if the expression contains a syntax error</DL>
</DD>
</DL>
<HR>

<A NAME="parsePattern(java.lang.String, net.sf.saxon.expr.StaticContext)"><!-- --></A><H3>
parsePattern</H3>
<PRE>
public <A HREF="../../../../net/sf/saxon/pattern/Pattern.html" title="class in net.sf.saxon.pattern">Pattern</A> <B>parsePattern</B>(java.lang.String&nbsp;pattern,
                            <A HREF="../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A>&nbsp;env)
                     throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse a string representing an XSLT pattern
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pattern</CODE> - the pattern expressed as a String<DD><CODE>env</CODE> - the static context for the pattern
<DT><B>Returns:</B><DD>a Pattern object representing the result of parsing
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if the pattern contains a syntax error</DL>
</DD>
</DL>
<HR>

<A NAME="parseSequenceType(java.lang.String, net.sf.saxon.expr.StaticContext)"><!-- --></A><H3>
parseSequenceType</H3>
<PRE>
public <A HREF="../../../../net/sf/saxon/value/SequenceType.html" title="class in net.sf.saxon.value">SequenceType</A> <B>parseSequenceType</B>(java.lang.String&nbsp;input,
                                      <A HREF="../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A>&nbsp;env)
                               throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse a string representing a sequence type
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the string, which should conform to the XPath SequenceType
      production<DD><CODE>env</CODE> - the static context
<DT><B>Returns:</B><DD>a SequenceType object representing the type
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="parseExpression()"><!-- --></A><H3>
parseExpression</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>parseExpression</B>()
                              throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse a top-level Expression:
 ExprSingle ( ',' ExprSingle )*
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the Expression object that results from parsing
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if the expression contains a syntax error</DL>
</DD>
</DL>
<HR>

<A NAME="parseExprSingle()"><!-- --></A><H3>
parseExprSingle</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>parseExprSingle</B>()
                              throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse an ExprSingle
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the resulting subexpression
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="parseTypeswitchExpression()"><!-- --></A><H3>
parseTypeswitchExpression</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>parseTypeswitchExpression</B>()
                                        throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse a Typeswitch Expression.
 This construct is XQuery-only, so the XPath version of this
 method throws an error unconditionally
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the expression that results from the parsing
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parseValidateExpression()"><!-- --></A><H3>
parseValidateExpression</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>parseValidateExpression</B>()
                                      throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse a Validate Expression.
 This construct is XQuery-only, so the XPath version of this
 method throws an error unconditionally
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the parsed expression; except that this version of the method always
 throws an exception
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parseExtensionExpression()"><!-- --></A><H3>
parseExtensionExpression</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>parseExtensionExpression</B>()
                                       throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse an Extension Expression
 This construct is XQuery-only, so the XPath version of this
 method throws an error unconditionally
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the parsed expression; except that this version of the method
 always throws an exception
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parseForExpression()"><!-- --></A><H3>
parseForExpression</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>parseForExpression</B>()
                                 throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse a FOR expression:
 for $x in expr (',' $y in expr)* 'return' expr
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the resulting subexpression
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="parseMappingExpression()"><!-- --></A><H3>
parseMappingExpression</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>parseMappingExpression</B>()
                                     throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse a mapping expression. This is a common routine that handles
 XPath 'for' expressions and quantified expressions.

 <p>Syntax: <br/>
 (for|some|every) $x in expr (',' $y in expr)* (return|satisfies) expr
 </p>

 <p>On entry, the current token indicates whether a for, some, or every
 expression is expected.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the resulting subexpression
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="parseSequenceType()"><!-- --></A><H3>
parseSequenceType</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/value/SequenceType.html" title="class in net.sf.saxon.value">SequenceType</A> <B>parseSequenceType</B>()
                                  throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse the sequence type production.
 The QName must be the name of a built-in schema-defined data type.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the resulting subexpression
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="parseRelativePath()"><!-- --></A><H3>
parseRelativePath</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>parseRelativePath</B>()
                                throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse a relative path (a sequence of steps). Called when the current token immediately
 follows a separator (/ or //), or an implicit separator (XYZ is equivalent to ./XYZ)
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the resulting subexpression
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="parseRemainingPath(net.sf.saxon.expr.Expression)"><!-- --></A><H3>
parseRemainingPath</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>parseRemainingPath</B>(<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;start)
                                 throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse the remaining steps of an absolute path expression (one starting in "/" or "//"). Note that the
 token immediately after the "/" or "//" has already been read, and in the case of "/", it has been confirmed
 that we have a path expression starting with "/" rather than a standalone "/" expression.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>start</CODE> - the initial implicit expression: root() in the case of "/", root()/descendant-or-self::node in
 the case of "//"
<DT><B>Returns:</B><DD>the completed path expression
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parseStepExpression()"><!-- --></A><H3>
parseStepExpression</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>parseStepExpression</B>()
                                  throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse a step (including an optional sequence of predicates)
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the resulting subexpression
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="makeStringLiteral(java.lang.String)"><!-- --></A><H3>
makeStringLiteral</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Literal.html" title="class in net.sf.saxon.expr">Literal</A> <B>makeStringLiteral</B>(java.lang.String&nbsp;currentTokenValue)
                             throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Method to make a string literal from a token identified as a string
 literal. This is trivial in XPath, but in XQuery the method is overridden
 to identify pseudo-XML character and entity references. Note that the job of handling
 doubled string delimiters is done by the tokenizer.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>currentTokenValue</CODE> - the token as read (excluding quotation marks)
<DT><B>Returns:</B><DD>The string value of the string literal
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parseConstructor()"><!-- --></A><H3>
parseConstructor</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>parseConstructor</B>()
                               throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse a node constructor. This is allowed only in XQuery, so the method throws
 an error for XPath.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the expression that results from the parsing
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parseNodeTest(short)"><!-- --></A><H3>
parseNodeTest</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/pattern/NodeTest.html" title="class in net.sf.saxon.pattern">NodeTest</A> <B>parseNodeTest</B>(short&nbsp;nodeType)
                          throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse a NodeTest.
 One of QName, prefix:*, *:suffix, *, text(), node(), comment(), or
 processing-instruction(literal?), or element(~,~), attribute(~,~), etc.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodeType</CODE> - the node type being sought if one is specified
<DT><B>Returns:</B><DD>the resulting NodeTest object
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="parseFunctionCall()"><!-- --></A><H3>
parseFunctionCall</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>parseFunctionCall</B>()
                                throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Parse a function call.
 function-name '(' ( Expression (',' Expression )* )? ')'
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the resulting subexpression
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="declareRangeVariable(net.sf.saxon.expr.Binding)"><!-- --></A><H3>
declareRangeVariable</H3>
<PRE>
protected void <B>declareRangeVariable</B>(<A HREF="../../../../net/sf/saxon/expr/Binding.html" title="interface in net.sf.saxon.expr">Binding</A>&nbsp;declaration)
                             throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Declare a range variable (record its existence within the parser).
 A range variable is a variable declared within an expression, as distinct
 from a variable declared in the context.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>declaration</CODE> - the variable declaration to be added to the stack
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="undeclareRangeVariable()"><!-- --></A><H3>
undeclareRangeVariable</H3>
<PRE>
protected void <B>undeclareRangeVariable</B>()</PRE>
<DL>
<DD>Note when the most recently declared range variable has gone out of scope
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRangeVariableStack()"><!-- --></A><H3>
getRangeVariableStack</H3>
<PRE>
public java.util.Stack <B>getRangeVariableStack</B>()</PRE>
<DL>
<DD>Get the range variable stack. Used when parsing a nested subexpression
 inside an attribute constructor
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the stack used for locally-declared variables</DL>
</DD>
</DL>
<HR>

<A NAME="setRangeVariableStack(java.util.Stack)"><!-- --></A><H3>
setRangeVariableStack</H3>
<PRE>
public void <B>setRangeVariableStack</B>(java.util.Stack&nbsp;stack)</PRE>
<DL>
<DD>Set the range variable stack. Used when parsing a nested subexpression
 inside an attribute constructor.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stack</CODE> - the stack to be used for local variables declared within the expression</DL>
</DD>
</DL>
<HR>

<A NAME="makeNameCode(java.lang.String, boolean)"><!-- --></A><H3>
makeNameCode</H3>
<PRE>
public final int <B>makeNameCode</B>(java.lang.String&nbsp;qname,
                              boolean&nbsp;useDefault)
                       throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Make a NameCode, using the static context for namespace resolution
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>qname</CODE> - The name as written, in the form "[prefix:]localname"<DD><CODE>useDefault</CODE> - Defines the action when there is no prefix. If
      true, use the default namespace URI for element names. If false,
     use no namespace URI (as for attribute names).
<DT><B>Returns:</B><DD>the namecode, which can be used to identify this name in the
     name pool
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if the name is invalid, or the prefix
     undeclared</DL>
</DD>
</DL>
<HR>

<A NAME="makeNameCodeSilently(java.lang.String, boolean)"><!-- --></A><H3>
makeNameCodeSilently</H3>
<PRE>
public final int <B>makeNameCodeSilently</B>(java.lang.String&nbsp;qname,
                                      boolean&nbsp;useDefault)
                               throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A>,
                                      <A HREF="../../../../net/sf/saxon/om/QNameException.html" title="class in net.sf.saxon.om">QNameException</A></PRE>
<DL>
<DD>Make a NameCode, using the static context for namespace resolution.
 This variant of the method does not call "grumble" to report any errors
 to the ErrorListener, it only reports errors by throwing exceptions. This
 allows the caller to control the message output.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>qname</CODE> - The name as written, in the form "[prefix:]localname"<DD><CODE>useDefault</CODE> - Defines the action when there is no prefix. If
      true, use the default namespace URI for element names. If false,
     use no namespace URI (as for attribute names).
<DT><B>Returns:</B><DD>the namecode, which can be used to identify this name in the
     name pool
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if the name is invalid, or the prefix
     undeclared
<DD><CODE><A HREF="../../../../net/sf/saxon/om/QNameException.html" title="class in net.sf.saxon.om">QNameException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="makeStructuredQName(java.lang.String, boolean)"><!-- --></A><H3>
makeStructuredQName</H3>
<PRE>
public final <A HREF="../../../../net/sf/saxon/om/StructuredQName.html" title="class in net.sf.saxon.om">StructuredQName</A> <B>makeStructuredQName</B>(java.lang.String&nbsp;qname,
                                                 boolean&nbsp;useDefault)
                                          throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Make a Structured QName, using the static context for namespace resolution
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>qname</CODE> - The name as written, in the form "[prefix:]localname"<DD><CODE>useDefault</CODE> - Defines the action when there is no prefix. If
      true, use the default namespace URI for element names. If false,
     use no namespace URI (as for attribute names).
<DT><B>Returns:</B><DD>the namecode, which can be used to identify this name in the
     name pool
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if the name is invalid, or the prefix
     undeclared</DL>
</DD>
</DL>
<HR>

<A NAME="makeNameTest(short, java.lang.String, boolean)"><!-- --></A><H3>
makeNameTest</H3>
<PRE>
public <A HREF="../../../../net/sf/saxon/pattern/NameTest.html" title="class in net.sf.saxon.pattern">NameTest</A> <B>makeNameTest</B>(short&nbsp;nodeType,
                             java.lang.String&nbsp;qname,
                             boolean&nbsp;useDefault)
                      throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Make a NameTest, using the static context for namespace resolution
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodeType</CODE> - the type of node required (identified by a constant in
     class Type)<DD><CODE>qname</CODE> - the lexical QName of the required node<DD><CODE>useDefault</CODE> - true if the default namespace should be used when
     the QName is unprefixed
<DT><B>Returns:</B><DD>a NameTest, representing a pattern that tests for a node of a
     given node kind and a given name
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if the QName is invalid</DL>
</DD>
</DL>
<HR>

<A NAME="makeNamespaceTest(short, java.lang.String)"><!-- --></A><H3>
makeNamespaceTest</H3>
<PRE>
public <A HREF="../../../../net/sf/saxon/pattern/NamespaceTest.html" title="class in net.sf.saxon.pattern">NamespaceTest</A> <B>makeNamespaceTest</B>(short&nbsp;nodeType,
                                       java.lang.String&nbsp;prefix)
                                throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Make a NamespaceTest (name:*)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodeType</CODE> - integer code identifying the type of node required<DD><CODE>prefix</CODE> - the namespace prefix
<DT><B>Returns:</B><DD>the NamespaceTest, a pattern that matches all nodes in this
     namespace
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if the namespace prefix is not declared</DL>
</DD>
</DL>
<HR>

<A NAME="makeLocalNameTest(short, java.lang.String)"><!-- --></A><H3>
makeLocalNameTest</H3>
<PRE>
public <A HREF="../../../../net/sf/saxon/pattern/LocalNameTest.html" title="class in net.sf.saxon.pattern">LocalNameTest</A> <B>makeLocalNameTest</B>(short&nbsp;nodeType,
                                       java.lang.String&nbsp;localName)
                                throws <A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Make a LocalNameTest (*:name)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodeType</CODE> - the kind of node to be matched<DD><CODE>localName</CODE> - the requred local name
<DT><B>Returns:</B><DD>a LocalNameTest, a pattern which matches all nodes of a given
     local name, regardless of namespace
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if the local name is invalid</DL>
</DD>
</DL>
<HR>

<A NAME="setLocation(net.sf.saxon.expr.Expression)"><!-- --></A><H3>
setLocation</H3>
<PRE>
protected void <B>setLocation</B>(<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;exp)</PRE>
<DL>
<DD>Set location information on an expression. At present this consists of a simple
 line number. Needed mainly for XQuery.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>exp</CODE> - the expression whose location information is to be set</DL>
</DD>
</DL>
<HR>

<A NAME="setLocation(net.sf.saxon.expr.Expression, int)"><!-- --></A><H3>
setLocation</H3>
<PRE>
protected void <B>setLocation</B>(<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;exp,
                           int&nbsp;offset)</PRE>
<DL>
<DD>Set location information on an expression. At present only the line number
 is retained. Needed mainly for XQuery. This version of the method supplies an
 explicit offset (character position within the expression or query), which the tokenizer
 can convert to a line number and column number.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>exp</CODE> - the expression whose location information is to be set<DD><CODE>offset</CODE> - the character position within the expression (ignoring newlines)</DL>
</DD>
</DL>
<HR>

<A NAME="makeTracer(int, net.sf.saxon.expr.Expression, int, net.sf.saxon.om.StructuredQName)"><!-- --></A><H3>
makeTracer</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>makeTracer</B>(int&nbsp;startOffset,
                                <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;exp,
                                int&nbsp;construct,
                                <A HREF="../../../../net/sf/saxon/om/StructuredQName.html" title="class in net.sf.saxon.om">StructuredQName</A>&nbsp;qName)</PRE>
<DL>
<DD>If tracing, wrap an expression in a trace instruction
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>startOffset</CODE> - the position of the expression in the soruce<DD><CODE>exp</CODE> - the expression to be wrapped<DD><CODE>construct</CODE> - integer constant identifying the kind of construct<DD><CODE>qName</CODE> - the name of the construct (if applicable)
<DT><B>Returns:</B><DD>the expression that does the tracing</DL>
</DD>
</DL>
<HR>

<A NAME="isKeyword(java.lang.String)"><!-- --></A><H3>
isKeyword</H3>
<PRE>
protected boolean <B>isKeyword</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD>Test whether the current token is a given keyword.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - The string to be compared with the current token
<DT><B>Returns:</B><DD>true if they are the same</DL>
</DD>
</DL>
<HR>

<A NAME="setScanOnly(boolean)"><!-- --></A><H3>
setScanOnly</H3>
<PRE>
public void <B>setScanOnly</B>(boolean&nbsp;scanOnly)</PRE>
<DL>
<DD>Set that we are parsing in "scan only"
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scanOnly</CODE> - true if parsing is to proceed in scan-only mode. In this mode
 namespace bindings are not yet known, so no attempt is made to look up namespace
 prefixes.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/sf/saxon/expr/ExpressionLocation.html" title="class in net.sf.saxon.expr"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../net/sf/saxon/expr/ExpressionParser.ForClause.html" title="class in net.sf.saxon.expr"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/sf/saxon/expr/ExpressionParser.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ExpressionParser.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
