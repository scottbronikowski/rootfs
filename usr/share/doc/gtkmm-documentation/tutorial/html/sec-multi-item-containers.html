<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Multiple-item widgets</title>
<link rel="stylesheet" href="style.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="index.html" title="Programming with gtkmm 3">
<link rel="up" href="chapter-container-widgets.html" title="Chapter 8. Container Widgets">
<link rel="prev" href="chapter-container-widgets.html" title="Chapter 8. Container Widgets">
<link rel="next" href="chapter-treeview.html" title="Chapter 9. The TreeView widget">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Multiple-item widgets </th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="chapter-container-widgets.html"><img src="icons/prev.png" alt="Prev"></a> </td>
<th width="60%" align="center">Chapter 8. Container Widgets</th>
<td width="20%" align="right"> <a accesskey="n" href="chapter-treeview.html"><img src="icons/next.png" alt="Next"></a>
</td>
</tr>
</table>
<hr>
</div>
<div class="sect1" title="Multiple-item widgets">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="sec-multi-item-containers"></a>Multiple-item widgets </h2></div></div></div>
<p>
Multiple-item widgets inherit from <code class="classname">Gtk::Container</code>; just
as with <code class="classname">Gtk::Bin</code>, you use the <code class="methodname">add()</code>
and <code class="methodname">remove()</code> methods to add and remove contained widgets.
Unlike <code class="methodname">Gtk::Bin::remove()</code>, however, the
<code class="methodname">remove()</code> method for <code class="classname">Gtk::Container</code>
takes an argument, specifiying which widget to remove.
</p>
<div class="sect2" title="Packing">
<div class="titlepage"><div><div><h3 class="title">
<a name="container-packing"></a>Packing</h3></div></div></div>
<p>
You've probably noticed that <span class="application">gtkmm</span> windows seem "elastic" - they can usually be stretched in many  different ways. This is due to the <span class="emphasis"><em>widget packing</em></span>
system.
</p>
<p>
Many GUI toolkits require you to precisely place widgets in a window, using absolute positioning, often using a visual editor. This leads to several problems:
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>The widgets don't rearrange themselves when the window is resized. Some widgets are hidden when the window is made smaller, and lots of useless space appears when the window is made larger.</p></li>
<li class="listitem"><p>It's impossible to predict the amount of space necessary for text after it has been translated to other languages, or displayed in a different font. On Unix it is also impossible to anticipate the effects of every theme and window manager.</p></li>
<li class="listitem"><p>
Changing the layout of a window "on the fly", to make some extra widgets appear, for instance, is complex. It  requires tedious recalculation of every widget's position.</p></li>
</ul></div>
<p>
<span class="application">gtkmm</span> uses the packing system to solve these problems. Rather than specifying the position and size of each widget in the window,
you can arrange your widgets in rows, columns,
and/or tables. <span class="application">gtkmm</span> can size your window automatically, based on the
sizes of the widgets it contains. And the sizes of the widgets are, in turn, determined by the amount of text they contain, or the minimum and maximum sizes that you specify, and/or how you have requested that the available space should be shared between sets of widgets.
You can perfect your layout by
specifying padding distance and centering values for each of your widgets. <span class="application">gtkmm</span> then uses
all this information to resize and reposition everything sensibly and smoothly when the user manipulates the window. </p>
<p>
<span class="application">gtkmm</span> arranges widgets hierarchically, using <span class="emphasis"><em>containers</em></span>.
A Container widget contains other widgets. Most <span class="application">gtkmm</span> widgets are
containers. Windows, Notebook tabs, and Buttons are all container widgets.
There are two flavours of containers: single-child containers, which are all
descendants of <code class="classname">Gtk::Bin</code>, and multiple-child containers,
which are descendants of <code class="classname">Gtk::Container</code>. Most widgets
in <span class="application">gtkmm</span> are descendants of <code class="classname">Gtk::Bin</code>, including
<code class="classname">Gtk::Window</code>.
</p>
<p>
Yes, that's correct: a Window can contain at most one widget. How, then, can
we use a window for anything useful?  By placing a multiple-child container in
the window. The most useful container widgets are
<code class="classname">Gtk:Grid</code>, <code class="classname">Gtk:VBox</code>,
<code class="classname">Gtk::HBox</code>, and <code class="classname">Gtk::Table</code>.
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>
<code class="classname">Gtk::Grid</code> arranges its child widgets in rows and
columns. Use <code class="methodname">attach()</code>,
<code class="methodname">attach_next_to()</code> and <code class="methodname">add()</code> to
insert child widgets.
</p></li>
<li class="listitem"><p>
<code class="classname">Gtk::VBox</code> and <code class="classname">Gtk::HBox</code> arrange
their child widgets vertically and horizontally, respectively. Use
<code class="methodname">pack_start()</code> and <code class="methodname">pack_end()</code> to insert
child widgets.
</p></li>
<li class="listitem"><p>
<code class="classname">Gtk::Table</code> arranges its widgets in a grid. Use
<code class="methodname">attach()</code> to insert widgets.
</p></li>
</ul></div>
<p>
 There are several other containers, which we will also discuss.
</p>
<p>
If you've never used a packing toolkit before, it can take some
getting used to. You'll probably find, however, that you don't
need to rely on visual form editors quite as much as you might with
other toolkits.
</p>
</div>
<div class="sect2" title="An improved Hello World">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-helloworld2"></a>An improved Hello World</h3></div></div></div>
<p>
Let's take a look at a slightly improved <code class="literal">helloworld</code>, showing what we've learnt.
</p>
<div class="figure">
<a name="figure-helloworld2"></a><p class="title"><b>Figure 8.6. Hello World 2</b></p>
<div class="figure-contents"><div class="screenshot"><div><img src="figures/helloworld2.png" alt="Hello World 2"></div></div></div>
</div>
<br class="figure-break"><p><a class="ulink" href="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/helloworld2?h=master" target="_top">Source Code</a></p>
<p>File: <code class="filename">helloworld.h</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#ifndef GTKMM_EXAMPLE_HELLOWORLD_H
#define GTKMM_EXAMPLE_HELLOWORLD_H

#include &lt;gtkmm/box.h&gt;
#include &lt;gtkmm/button.h&gt;
#include &lt;gtkmm/window.h&gt;

class HelloWorld : public Gtk::Window
{
public:
  HelloWorld();
  virtual ~HelloWorld();

protected:

  // Signal handlers:
  // Our new improved on_button_clicked(). (see below)
  void on_button_clicked(Glib::ustring data);

  // Child widgets:
  Gtk::Box m_box1;
  Gtk::Button m_button1, m_button2;
};

#endif // GTKMM_EXAMPLE_HELLOWORLD_H
</pre>
<p>File: <code class="filename">main.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include "helloworld.h"
#include &lt;gtkmm/main.h&gt;

int main (int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  HelloWorld helloworld;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(helloworld);

  return 0;
}
</pre>
<p>File: <code class="filename">helloworld.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include "helloworld.h"
#include &lt;iostream&gt;

HelloWorld::HelloWorld()
: m_button1("Button 1"),
  m_button2("Button 2")
{
  // This just sets the title of our new window.
  set_title("Hello Buttons!");

  // sets the border width of the window.
  set_border_width(10);

  // put the box into the main window.
  add(m_box1);

  // Now when the button is clicked, we call the "on_button_clicked" function
  // with a pointer to "button 1" as it's argument
  m_button1.signal_clicked().connect(sigc::bind&lt;Glib::ustring&gt;(
              sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), "button 1"));

  // instead of gtk_container_add, we pack this button into the invisible
  // box, which has been packed into the window.
  // note that the pack_start default arguments are Gtk::EXPAND | Gtk::FILL, 0
  m_box1.pack_start(m_button1);

  // always remember this step, this tells GTK that our preparation
  // for this button is complete, and it can be displayed now.
  m_button1.show();

  // call the same signal handler with a different argument,
  // passing a pointer to "button 2" instead.
  m_button2.signal_clicked().connect(sigc::bind&lt;-1, Glib::ustring&gt;(
              sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), "button 2"));

  m_box1.pack_start(m_button2);

  // Show the widgets.
  // They will not really be shown until this Window is shown.
  m_button2.show();
  m_box1.show();
}

HelloWorld::~HelloWorld()
{
}

// Our new improved signal handler.  The data passed to this method is
// printed to stdout.
void HelloWorld::on_button_clicked(Glib::ustring data)
{
  std::cout &lt;&lt; "Hello World - " &lt;&lt; data &lt;&lt; " was pressed" &lt;&lt; std::endl;
}

</pre>
<p>
After building and running this program, try resizing the window to see the
behaviour. Also, try playing with the options to
<code class="methodname">pack_start()</code> while reading the <a class="link" href="sec-multi-item-containers.html#sec-boxes" title="Boxes">Boxes</a> section.
</p>
</div>
<div class="sect2" title="Boxes">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-boxes"></a>Boxes</h3></div></div></div>
<p>
Most packing uses boxes as in the above example. These
are invisible containers into which we can pack our widgets. When
packing widgets into a horizontal box, the objects are inserted
horizontally from left to right or right to left depending on whether
<code class="methodname">pack_start()</code> or <code class="methodname">pack_end()</code> is used.
In a vertical box, widgets are packed from top to bottom or vice
versa. You may use any combination of boxes inside or beside other
boxes to create the desired effect.
</p>
<div class="sect3" title="Adding widgets">
<div class="titlepage"><div><div><h4 class="title">
<a name="boxes-adding-widgets"></a>Adding widgets</h4></div></div></div>
<div class="sect4" title="Per-child packing options">
<div class="titlepage"><div><div><h5 class="title">
<a name="per-child-packing-options"></a>Per-child packing options</h5></div></div></div>
<p>
The <code class="methodname">pack_start()</code> and
<code class="methodname">pack_end()</code> methods place widgets inside these
containers. The <code class="methodname">pack_start()</code> method will start at
the top and work its way down in a <code class="classname">VBox</code>, or pack left to
right in an <code class="classname">HBox</code>.
<code class="methodname">pack_end()</code> will do the opposite, packing from
bottom to top in a <code class="classname">VBox</code>, or right to left in an
<code class="classname">HBox</code>. Using these methods allows us to right justify or
left justify our widgets. We will use <code class="methodname">pack_start()</code>
in most of our examples.
</p>
<p>
There are several options governing how  widgets are to be packed, and this can
be confusing at first. If you have difficulties then it is sometimes a good
idea to play with the <span class="application">glade</span> GUI designer to see what
is possible. You might even decide to use the
<span class="application">Gtk::Builder</span> API to load your GUI at runtime.
</p>
<p>
There are basically five
different styles, as shown in this picture:
</p>
<div class="figure">
<a name="figure-box-packing1"></a><p class="title"><b>Figure 8.7. Box Packing 1</b></p>
<div class="figure-contents"><div class="screenshot"><div><img src="figures/box_packing1.png" alt="Box Packing 1"></div></div></div>
</div>
<br class="figure-break"><p>
Each line contains one horizontal box (<code class="classname">HBox</code>) with
several buttons. Each of the buttons on a line is packed into the
<code class="classname">HBox</code> with the same arguments to the
<code class="methodname">pack_start()</code> method).
</p>
<p>
This is the declaration of the <code class="methodname">pack_start()</code> method:
</p>
<pre class="programlisting">void pack_start(Gtk::Widget&amp; child,
                PackOptions options = PACK_EXPAND_WIDGET,
                guint padding = 0);</pre>
<p>
The first argument is the widget you're packing. In our example these are all <code class="classname">Button</code>s.
</p>
<p>
The <em class="parameter"><code>options</code></em> argument can take one of these three options:
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p><code class="literal">PACK_SHRINK</code>: Space is contracted to the child widget size. The widget will take up just-enough space and never expand.</p></li>
<li class="listitem"><p><code class="literal">PACK_EXPAND_PADDING</code>: Extra space is filled with padding. The widgets will be spaced out evenly, but their sizes won't change - there will be empty space between the widgets instead. </p></li>
<li class="listitem"><p><code class="literal">PACK_EXPAND_WIDGET</code>: Extra space is taken up by increasing the child widget size, without changing the amount of space between widgets.</p></li>
</ul></div>
<p>
</p>
<p>
The <em class="parameter"><code>padding</code></em> argument specifies the width of an extra
border area to leave around the packed widget.
</p>
<p><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Box.html" target="_top">Reference</a></p>
</div>
<div class="sect4" title="Per-container packing options">
<div class="titlepage"><div><div><h5 class="title">
<a name="per-container-packing-options"></a>Per-container packing options</h5></div></div></div>
<p>
Here's the constructor for the box widgets:
</p>
<pre class="programlisting">Gtk::Box(bool homogeneous = false, int spacing = 0);</pre>
<p>
Passing <code class="literal">true</code> for <em class="parameter"><code>homogeneous</code></em> will
cause all of the contained widgets to be the same size.
<em class="parameter"><code>spacing</code></em> is a (minimum) number of pixels to leave between
each widget.
</p>
<p>
What's the difference between spacing (set when the box is created)
and padding (set when elements are packed)? Spacing is added between
objects, and padding is added on either side of a widget. The following
figure should make it clearer:
</p>
<div class="figure">
<a name="figure-box-packing2"></a><p class="title"><b>Figure 8.8. Box Packing 2</b></p>
<div class="figure-contents"><div class="screenshot"><div><img src="figures/box_packing2.png" alt="Box Packing 2"></div></div></div>
</div>
<br class="figure-break">
</div>
</div>
<div class="sect3" title="Example">
<div class="titlepage"><div><div><h4 class="title">
<a name="box-packing-example"></a>Example</h4></div></div></div>
<p>
Here is the source code for the example that produced the screenshots above. When you run this example, provide a number between 1 and 3 as a command-line option, to see different packing options in use.</p>
<p><a class="ulink" href="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/box?h=master" target="_top">Source Code</a></p>
<p>File: <code class="filename">packbox.h</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#ifndef GTKMM_EXAMPLE_PACKBOX_H
#define GTKMM_EXAMPLE_PACKBOX_H

#include &lt;gtkmm.h&gt;

class PackBox : public Gtk::Box
{
public:
  PackBox(bool homogeneous, int spacing, Gtk::PackOptions, int padding = 0);
  virtual ~PackBox();

protected:
  Gtk::Button m_button1, m_button2, m_button3;
  Gtk::Button* m_pbutton4;

  char padstr[80];
};

#endif //GTKMM_EXAMPLE_PACKBOX_H
</pre>
<p>File: <code class="filename">examplewindow.h</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;
#include "packbox.h"

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow(int which);
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit_clicked();

  //Child widgets:
  Gtk::Button m_button;
  Gtk::Box m_box1;
  Gtk::Box m_boxQuit;
  Gtk::Button m_buttonQuit;

  Gtk::Label m_Label1, m_Label2;

  Gtk::Separator m_seperator1, m_seperator2, m_seperator3, m_seperator4, m_seperator5;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre>
<p>File: <code class="filename">examplewindow.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow(int which)
: m_box1(Gtk::ORIENTATION_VERTICAL),
  m_buttonQuit("Quit")
{
  set_title("Gtk::Box example");

  PackBox *pPackBox1, *pPackBox2, *pPackBox3, *pPackBox4, *pPackBox5;

  switch(which)
  {
    case 1:
    {
      m_Label1.set_text("Gtk::Box(Gtk::ORIENTATION_HORIZONTAL, 0);");

      // Align the label to the left side.  We'll discuss this function and
      // others in the section on Widget Attributes.
      m_Label1.set_alignment(Gtk::ALIGN_START, Gtk::ALIGN_START);

      // Pack the label into the vertical box (vbox box1).  Remember that
      // widgets added to a vbox will be packed one on top of the other in
      // order.
      m_box1.pack_start(m_Label1, Gtk::PACK_SHRINK);

      // Create a PackBox - homogeneous = false, spacing = 0,
      // options = Gtk::PACK_SHRINK, padding = 0
      pPackBox1 = Gtk::manage(new PackBox(false, 0, Gtk::PACK_SHRINK));
      m_box1.pack_start(*pPackBox1, Gtk::PACK_SHRINK);

      // Create a PackBox - homogeneous = false, spacing = 0,
      // options = Gtk::PACK_EXPAND_PADDING, padding = 0
      pPackBox2 = Gtk::manage(new PackBox(false, 0, Gtk::PACK_EXPAND_PADDING));
      m_box1.pack_start(*pPackBox2, Gtk::PACK_SHRINK);

      // Create a PackBox - homogeneous = false, spacing = 0,
      // options = Gtk::PACK_EXPAND_WIDGET, padding = 0
      pPackBox3 = Gtk::manage(new PackBox(false, 0, Gtk::PACK_EXPAND_WIDGET));
      m_box1.pack_start(*pPackBox3, Gtk::PACK_SHRINK);

      // pack the separator into the vbox.  Remember each of these
      // widgets are being packed into a vbox, so they'll be stacked
      // vertically.
      m_box1.pack_start(m_seperator1, Gtk::PACK_SHRINK, 5);

      // create another new label, and show it.
      m_Label2.set_text("Gtk::Box(Gtk::ORIENTATION_HORIZONTAL, 0);");
      m_Label2.set_alignment(Gtk::ALIGN_START, Gtk::ALIGN_START);
      m_box1.pack_start(m_Label2, Gtk::PACK_SHRINK);

      // Args are: homogeneous, spacing, options, padding
      pPackBox4 = Gtk::manage(new PackBox(true, 0, Gtk::PACK_EXPAND_PADDING));
      m_box1.pack_start(*pPackBox4, Gtk::PACK_SHRINK);

      // Args are: homogeneous, spacing, options, padding
      pPackBox5 = Gtk::manage(new PackBox(true, 0, Gtk::PACK_EXPAND_WIDGET));
      m_box1.pack_start(*pPackBox5, Gtk::PACK_SHRINK);

      m_box1.pack_start(m_seperator2, Gtk::PACK_SHRINK, 5);

      break;
    }

    case 2:
    {

      m_Label1.set_text("Gtk::Box(Gtk::ORIENTATION_HORIZONTAL, 10);");
      m_Label1.set_alignment(Gtk::ALIGN_START, Gtk::ALIGN_START);
      m_box1.pack_start(m_Label1, Gtk::PACK_SHRINK);

      pPackBox1 = Gtk::manage(new PackBox(false, 10, Gtk::PACK_EXPAND_PADDING));
      m_box1.pack_start(*pPackBox1, Gtk::PACK_SHRINK);

      pPackBox2 = Gtk::manage(new PackBox(false, 10, Gtk::PACK_EXPAND_WIDGET));
      m_box1.pack_start(*pPackBox2, Gtk::PACK_SHRINK);

      m_box1.pack_start(m_seperator1, Gtk::PACK_SHRINK, 5);


      m_Label2.set_text("Gtk::Box(Gtk::ORIENTATION_HORIZONTAL, 0);");
      m_Label2.set_alignment(Gtk::ALIGN_START, Gtk::ALIGN_START);
      m_box1.pack_start(m_Label2, Gtk::PACK_SHRINK);

      pPackBox3 = Gtk::manage(new PackBox(false, 0, Gtk::PACK_SHRINK, 10));
      m_box1.pack_start(*pPackBox3, Gtk::PACK_SHRINK);

      pPackBox4 = Gtk::manage(new PackBox(false, 0, Gtk::PACK_EXPAND_WIDGET, 10));
      m_box1.pack_start(*pPackBox4, Gtk::PACK_SHRINK);

      m_box1.pack_start(m_seperator2, Gtk::PACK_SHRINK, 5);

      break;
    }

    case 3:
    {
      // This demonstrates the ability to use Gtk::Box::pack_end() to
      // right justify widgets.  First, we create a new box as before.
      pPackBox1 = Gtk::manage(new PackBox(false, 0, Gtk::PACK_SHRINK));

      // create the label that will be put at the end.
      m_Label1.set_text("end");

      // pack it using pack_end(), so it is put on the right side
      // of the PackBox.
      pPackBox1-&gt;pack_end(m_Label1, Gtk::PACK_SHRINK);

      m_box1.pack_start(*pPackBox1, Gtk::PACK_SHRINK);

      // this explicitly sets the separator to 400 pixels wide by 5 pixels
      // high.  This is so the hbox we created will also be 400 pixels wide,
      // and the "end" label will be separated from the other labels in the
      // hbox.  Otherwise, all the widgets in the hbox would be packed as
      // close together as possible.
      m_seperator1.set_size_request(400, 5);

      // pack the separator into ourselves
      m_box1.pack_start(m_seperator1, Gtk::PACK_SHRINK, 5);

      break;
    }

    default:
    {
      std::cerr &lt;&lt; "Unexpected command-line option." &lt;&lt; std::endl;
      break;
    }
  }

  // Connect the signal to hide the window:
  m_buttonQuit.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit_clicked) );

  // pack the button into the quitbox.
  // The last 2 arguments to Box::pack_start are: options, padding.
  m_boxQuit.pack_start(m_buttonQuit, Gtk::PACK_EXPAND_PADDING);
  m_box1.pack_start(m_boxQuit, Gtk::PACK_SHRINK);

  // pack the vbox (box1) which now contains all our widgets, into the
  // main window.
  add(m_box1);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit_clicked()
{
  hide();
}

</pre>
<p>File: <code class="filename">main.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

using std::atoi;

int main(int argc, char *argv[])
{
  Gtk::Main main_instance(argc, argv);

  if(argc != 2)
  {
    std::cerr &lt;&lt; "usage: packbox num, where num is 1, 2, or 3." &lt;&lt; std::endl;
    return 1;
  }

  ExampleWindow window( atoi(argv[1]) );
  Gtk::Main::run(window); //Shows the window and returns when it is closed.

  return 0;
}
</pre>
<p>File: <code class="filename">packbox.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include "packbox.h"
#include &lt;cstdio&gt; //For sprintf().

PackBox::PackBox(bool homogeneous, int spacing, Gtk::PackOptions options,
        int padding)
: Gtk::Box(Gtk::ORIENTATION_HORIZONTAL, spacing),
  m_button1("box.pack_start("),
  m_button2("button,"),
  m_button3((options == Gtk::PACK_SHRINK) ? "Gtk::PACK_SHRINK" :
            ((options == Gtk::PACK_EXPAND_PADDING) ?
             "Gtk::PACK_EXPAND_PADDING" : "Gtk::PACK_EXPAND_WIDGET"))
{
  set_homogeneous(homogeneous);

  pack_start(m_button1, options, padding);
  pack_start(m_button2, options, padding);
  pack_start(m_button3, options, padding);

  sprintf(padstr, "%d);", padding);

  m_pbutton4 = new Gtk::Button(padstr);
  pack_start(*m_pbutton4, options, padding);
}

PackBox::~PackBox()
{
  delete m_pbutton4;
}

</pre>
</div>
</div>
<div class="sect2" title="ButtonBoxes">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-buttonbox"></a>ButtonBoxes</h3></div></div></div>
<p>
Button boxes are a convenient way to quickly arrange a group of buttons. They
come in both horizontal (<code class="classname">Gtk::HButtonBox</code>) and vertical
(<code class="classname">Gtk::VButtonBox</code>) flavours. They are exactly alike,
except in name and orientation.
</p>
<p>
<code class="classname">ButtonBox</code>es help to make applications appear consistent
because they use standard settings, such as inter-button spacing and packing.
</p>
<p>
Buttons are added to a <code class="classname">ButtonBox</code> with the
<code class="methodname">add()</code> method.
</p>
<p>
Button boxes support several layout styles. The style can be retrieved and
changed using <code class="methodname">get_layout()</code> and
<code class="methodname">set_layout()</code>.
</p>
<p><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ButtonBox.html" target="_top">Reference</a></p>
<div class="sect3" title="Example">
<div class="titlepage"><div><div><h4 class="title">
<a name="buttonbox-example"></a>Example</h4></div></div></div>
<div class="figure">
<a name="figure-buttonbox"></a><p class="title"><b>Figure 8.9. ButtonBox</b></p>
<div class="figure-contents"><div class="screenshot"><div><img src="figures/buttonbox.png" alt="ButtonBox"></div></div></div>
</div>
<br class="figure-break"><p><a class="ulink" href="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/buttonbox?h=master" target="_top">Source Code</a></p>
<p>File: <code class="filename">examplebuttonbox.h</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#ifndef GTKMM_EXAMPLE_BUTTONBOX_H
#define GTKMM_EXAMPLE_BUTTONBOX_H

#include &lt;gtkmm.h&gt;

class ExampleButtonBox : public Gtk::Frame
{
public:
  ExampleButtonBox(bool horizontal,
       const Glib::ustring&amp; title,
       gint spacing,
       Gtk::ButtonBoxStyle layout);

protected:
  Gtk::Button m_Button_OK, m_Button_Cancel, m_Button_Help;
};

#endif //GTKMM_EXAMPLE_BUTTONBOX_H
</pre>
<p>File: <code class="filename">examplewindow.h</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_clicked();

  //Child widgets:
  Gtk::Box m_VBox_Main, m_VBox;
  Gtk::Box m_HBox;
  Gtk::Frame m_Frame_Horizontal, m_Frame_Vertical;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre>
<p>File: <code class="filename">examplebuttonbox.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include "examplebuttonbox.h"

ExampleButtonBox::ExampleButtonBox(bool horizontal,
       const Glib::ustring&amp; title,
       gint spacing,
       Gtk::ButtonBoxStyle layout)
: Gtk::Frame(title),
  m_Button_OK("OK"),
  m_Button_Cancel("Cancel"),
  m_Button_Help("Help")
{
  Gtk::ButtonBox* bbox = 0;

  if(horizontal)
    bbox = Gtk::manage( new Gtk::ButtonBox(Gtk::ORIENTATION_HORIZONTAL) );
  else
    bbox = Gtk::manage( new Gtk::ButtonBox(Gtk::ORIENTATION_VERTICAL) );

  bbox-&gt;set_border_width(5);

  add(*bbox);

  /* Set the appearance of the Button Box */
  bbox-&gt;set_layout(layout);
  bbox-&gt;set_spacing(spacing);

  bbox-&gt;add(m_Button_OK);
  bbox-&gt;add(m_Button_Cancel);
  bbox-&gt;add(m_Button_Help);
}

</pre>
<p>File: <code class="filename">examplewindow.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include "examplewindow.h"
#include "examplebuttonbox.h"

ExampleWindow::ExampleWindow()
: m_VBox_Main(Gtk::ORIENTATION_VERTICAL),
  m_VBox(Gtk::ORIENTATION_VERTICAL),
  m_Frame_Horizontal("Horizontal Button Boxes"),
  m_Frame_Vertical("Vertical Button Boxes")
{
  set_title("Gtk::ButtonBox");
  add(m_VBox_Main);

  m_VBox_Main.pack_start(m_Frame_Horizontal, Gtk::PACK_EXPAND_WIDGET, 10);

  //The horizontal ButtonBoxes:
  m_VBox.set_border_width(10);
  m_Frame_Horizontal.add(m_VBox);

  m_VBox.pack_start(*Gtk::manage(
              new ExampleButtonBox(true, "Spread (spacing 40)", 40,
                  Gtk::BUTTONBOX_SPREAD)),
          Gtk::PACK_EXPAND_WIDGET, 0);

  m_VBox.pack_start(*Gtk::manage(
              new ExampleButtonBox(true, "Edge (spacing 30)", 30,
                  Gtk::BUTTONBOX_EDGE)),
          Gtk::PACK_EXPAND_WIDGET, 5);

  m_VBox.pack_start(*Gtk::manage(
              new ExampleButtonBox(true, "Start (spacing 20)", 20,
                  Gtk::BUTTONBOX_START)),
          Gtk::PACK_EXPAND_WIDGET, 5);

  m_VBox.pack_start(*Gtk::manage(
              new ExampleButtonBox(true, "end (spacing 10)", 10,
                  Gtk::BUTTONBOX_END)),
          Gtk::PACK_EXPAND_WIDGET, 5);


  //The vertical ButtonBoxes:
  m_VBox_Main.pack_start(m_Frame_Vertical, Gtk::PACK_EXPAND_WIDGET, 10);

  m_HBox.set_border_width(10);
  m_Frame_Vertical.add(m_HBox);

  m_HBox.pack_start(*Gtk::manage(
              new ExampleButtonBox(false, "Spread (spacing 5)", 5,
                  Gtk::BUTTONBOX_SPREAD)),
          Gtk::PACK_EXPAND_WIDGET, 0);

  m_HBox.pack_start(*Gtk::manage(
              new ExampleButtonBox(false, "Edge (spacing 30)", 30,
                  Gtk::BUTTONBOX_EDGE)),
          Gtk::PACK_EXPAND_WIDGET, 5);

  m_HBox.pack_start(*Gtk::manage(
              new ExampleButtonBox(false, "Start (spacing 20)", 20,
                  Gtk::BUTTONBOX_START)),
          Gtk::PACK_EXPAND_WIDGET, 5);

  m_HBox.pack_start(*Gtk::manage(new ExampleButtonBox(false, "End (spacing 10)",
                  10, Gtk::BUTTONBOX_END)),
          Gtk::PACK_EXPAND_WIDGET, 5);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_clicked()
{
  hide();
}
</pre>
<p>File: <code class="filename">main.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</pre>
</div>
</div>
<div class="sect2" title="Grid">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-grid"></a>Grid</h3></div></div></div>
<p>
A <code class="classname">Grid</code> dynamically lays out child widgets in rows and
columns. The dimensions of the grid do not need to be specified in the constructor.
</p>
<p>
Child widgets can span multiple rows or columns, using
<code class="methodname">attach()</code>, or added next to an existing widget inside
the grid with <code class="methodname">attach_next_to()</code>. Individual rows and columns of the grid can be set to have uniform height or width with
<code class="methodname">set_row_homogeneous()</code> and
<code class="methodname">set_column_homogeneous()</code>.
</p>
<p>You can set the <span class="emphasis"><em>margin</em></span> and <span class="emphasis"><em>expand</em></span> properties of the
child <code class="classname">Widget</code>s to control their spacing and their behaviour when the Grid is resized.
</p>
<p><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Grid.html" target="_top">Reference</a></p>
<div class="sect3" title="Example">
<div class="titlepage"><div><div><h4 class="title">
<a name="grid-example"></a>Example</h4></div></div></div>
<p>
This example creates a window with three buttons in a grid.
The first two buttons are in the upper row, from left to right. A
third button is attached underneath the first button, in a new lower row,
spanning two columns.
</p>
<div class="figure">
<a name="figure-grid"></a><p class="title"><b>Figure 8.10. Grid</b></p>
<div class="figure-contents"><div class="screenshot"><div><img src="figures/grid.png" alt="Grid"></div></div></div>
</div>
<br class="figure-break"><p><a class="ulink" href="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/grid?h=master" target="_top">Source Code</a></p>
<p>File: <code class="filename">examplewindow.h</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

private:
  // Signal handlers:
  void on_button_quit();
  void on_button_numbered(const Glib::ustring&amp; data);

  // Child widgets:
  Gtk::Grid m_grid;
  Gtk::Button m_button_1, m_button_2, m_button_quit;
};

#endif /* GTKMM_EXAMPLEWINDOW_H */
</pre>
<p>File: <code class="filename">examplewindow.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_button_1("button 1"),
  m_button_2("button 2"),
  m_button_quit("Quit")
{
  set_title("Gtk::Grid");
  set_border_width(12);

  add(m_grid);

  m_grid.add(m_button_1);
  m_grid.add(m_button_2);
  m_grid.attach_next_to(m_button_quit, m_button_1, Gtk::POS_BOTTOM, 2, 1);

  m_button_1.signal_clicked().connect(
    sigc::bind&lt;Glib::ustring&gt;( sigc::mem_fun(*this,
      &amp;ExampleWindow::on_button_numbered), "button 1") );
  m_button_2.signal_clicked().connect(
    sigc::bind&lt;Glib::ustring&gt;( sigc::mem_fun(*this,
      &amp;ExampleWindow::on_button_numbered), "button 2") );

  m_button_quit.signal_clicked().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_button_quit) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

void
ExampleWindow::on_button_numbered(const Glib::ustring&amp; data)
{
  std::cout &lt;&lt; data &lt;&lt; " was pressed" &lt;&lt; std::endl;
}
</pre>
<p>File: <code class="filename">main.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  // Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</pre>
</div>
</div>
<div class="sect2" title="Table">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-table"></a>Table</h3></div></div></div>
<p>
Tables allows us to place widgets in a grid, similar to <code class="classname">Gtk::Grid</code>.
</p>
<div class="sect3" title="Constructor">
<div class="titlepage"><div><div><h4 class="title">
<a name="table-constructor"></a>Constructor</h4></div></div></div>
<p>
The grid's dimensions need to be specified in the constructor:
</p>
<pre class="programlisting">Gtk::Table(int rows = 1, int columns = 1, bool homogeneous = false);</pre>
<p>
The first argument is the number of rows to make in the table, while the
second, obviously, is the number of columns. If
<em class="parameter"><code>homogeneous</code></em> is <code class="literal">true</code>, the table cells
will all be the same size (the size of the largest widget in the table).
</p>
<p>
The rows and columns are indexed starting at 0. If you specify
<em class="parameter"><code>rows</code></em> = 2 and <em class="parameter"><code>columns</code></em> = 2, the
layout would look something like this:
</p>
<pre class="programlisting">
 0          1          2
0+----------+----------+
 |          |          |
1+----------+----------+
 |          |          |
2+----------+----------+
</pre>
<p>
Note that the coordinate system starts in the upper left hand corner.
</p>
</div>
<div class="sect3" title="Adding widgets">
<div class="titlepage"><div><div><h4 class="title">
<a name="table-adding-widgets"></a>Adding widgets</h4></div></div></div>
<p>
To place a widget into a box, use the following method:
</p>
<pre class="programlisting">void Gtk::Table::attach(Gtk::Widget&amp; child,
                        guint left_attach, guint right_attach,
                        guint top_attach, guint bottom_attach,
                        guint xoptions = Gtk::FILL | Gtk::EXPAND,
                        guint yoptions = Gtk::FILL | Gtk::EXPAND,
                        guint xpadding = 0, guint ypadding = 0);</pre>
<p>
The first argument is the widget you wish to place in the table.
</p>
<p>
The <em class="parameter"><code>left_attach</code></em> and
<em class="parameter"><code>right_attach</code></em> arguments specify where to place the
widget, and how many boxes to use. For example, if you want a button in the
lower-right cell of a 2 x 2 table, and want it to occupy that cell
<span class="emphasis"><em>only</em></span>, then <em class="parameter"><code>left_attach</code></em> would
be 1, <em class="parameter"><code>right_attach</code></em> 2,
<em class="parameter"><code>top_attach</code></em> 1, and
<em class="parameter"><code>bottom_attach</code></em> 2. If, on the other hand, you
wanted a widget to take up the entire top row of our 2 x 2 table, you'd set
<em class="parameter"><code>left_attach</code></em> = 0,
<em class="parameter"><code>right_attach</code></em> = 2,
<em class="parameter"><code>top_attach</code></em> = 0, and
<em class="parameter"><code>bottom_attach</code></em> = 1.
</p>
<p>
<em class="parameter"><code>xoptions</code></em> and <em class="parameter"><code>yoptions</code></em> are used to
specify packing options and may be bitwise ORed together to allow multiple
options. These options are:
</p>
<p>
</p>
<div class="variablelist"><dl>
<dt><span class="term"><code class="literal">Gtk::FILL</code></span></dt>
<dd><p>
If the table box is larger than the widget, and
<code class="literal">Gtk::FILL</code> is specified, the widget will expand to use all the room available.
</p></dd>
<dt><span class="term"><code class="literal">Gtk::SHRINK</code></span></dt>
<dd><p>
If the table widget is allocated less
space than it requested (because the user resized the window),
then the widgets will normally just disappear off the bottom of the
window. If <code class="literal">Gtk::SHRINK</code> is specified, the widgets
will shrink with the table.
</p></dd>
<dt><span class="term"><code class="literal">Gtk::EXPAND</code></span></dt>
<dd><p>This will cause the table to expand to use up anyremaining space in the window.
</p></dd>
</dl></div>
<p>
</p>
<p>
The padding arguments work just as they do for
<code class="methodname">pack_start()</code>.
</p>
</div>
<div class="sect3" title="Other methods">
<div class="titlepage"><div><div><h4 class="title">
<a name="table-other-methods"></a>Other methods</h4></div></div></div>
<p>
<code class="methodname">set_row_spacing()</code> and
<code class="methodname">set_col_spacing()</code> set the spacing between
the rows at the specified row or column. Note that for columns, the space goes
to the right of the column, and for rows, the space goes below the row.
</p>
<p>
You can also set a consistent spacing for all rows and/or columns with
<code class="methodname">set_row_spacings()</code> and
<code class="methodname">set_col_spacings()</code>. Note that with these calls, the last
row and last column do not get any spacing.
</p>
<p><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Table.html" target="_top">Reference</a></p>
</div>
<div class="sect3" title="Example">
<div class="titlepage"><div><div><h4 class="title">
<a name="table-example"></a>Example</h4></div></div></div>
<p>
In the following example, we make a window with three buttons in a 2 x 2
table. The first two buttons will be placed in the upper row. A
third button is placed in the lower row, spanning both columns.
</p>
<div class="figure">
<a name="figure-table"></a><p class="title"><b>Figure 8.11. Table</b></p>
<div class="figure-contents"><div class="screenshot"><div><img src="figures/table.png" alt="Table"></div></div></div>
</div>
<br class="figure-break"><p><a class="ulink" href="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/table?h=master" target="_top">Source Code</a></p>
<p>File: <code class="filename">examplewindow.h</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();
  void on_button_numbered(Glib::ustring data);

  //Child widgets:
  Gtk::Table m_Table;
  Gtk::Button m_Button_1, m_Button_2, m_Button_Quit;

};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre>
<p>File: <code class="filename">examplewindow.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_Table(2, 2, true),
  m_Button_1("button 1"),
  m_Button_2("button 2"),
  m_Button_Quit("Quit")
{
  set_title("Gtk::Table");
  set_border_width(20);

  add(m_Table);

  m_Table.attach(m_Button_1, 0, 1, 0, 1);
  m_Table.attach(m_Button_2, 1, 2, 0, 1);
  m_Table.attach(m_Button_Quit, 0, 2, 1, 2);

  m_Button_1.signal_clicked().connect(
          sigc::bind&lt;Glib::ustring&gt;( sigc::mem_fun(*this,
                  &amp;ExampleWindow::on_button_numbered), "button 1") );
  m_Button_2.signal_clicked().connect(
          sigc::bind&lt;Glib::ustring&gt;( sigc::mem_fun(*this,
                  &amp;ExampleWindow::on_button_numbered), "button 2") );

  m_Button_Quit.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

void
ExampleWindow::on_button_numbered(Glib::ustring data)
{
  std::cout &lt;&lt; "Hello again - " &lt;&lt; data &lt;&lt; " was pressed" &lt;&lt; std::endl;
}

</pre>
<p>File: <code class="filename">main.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</pre>
</div>
</div>
<div class="sect2" title="Notebook">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-notebook"></a>Notebook</h3></div></div></div>
<p>
A <code class="classname">Notebook</code> has a set of stacked
<code class="literal">pages</code>, each of which contains widgets. Labelled
<code class="literal">tabs</code> allow the user to select the pages.
<code class="classname">Notebook</code>s allow several sets of widgets to be placed in a
small space, by only showing one page at a time. For instance, they are often
used in preferences dialogs.
</p>
<p>
Use the <code class="methodname">append_page()</code>, <code class="methodname">prepend_page()</code>
and <code class="methodname">insert_page()</code> methods to add tabbed pages to the
<code class="literal">Notebook</code>, supplying the child widget and the name for the
tab.
</p>
<p>
To discover the currently visible page, use the
<code class="methodname">get_current_page()</code> method. This returns the page number,
and then calling <code class="methodname">get_nth_page()</code> with that number will give
you a pointer to the actual child widget.
</p>
<p>
To programmatically change the selected page, use the
<code class="methodname">set_current_page()</code> method.
</p>
<p><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Notebook.html" target="_top">Reference</a></p>
<div class="sect3" title="Example">
<div class="titlepage"><div><div><h4 class="title">
<a name="notebook-example"></a>Example</h4></div></div></div>
<div class="figure">
<a name="figure-notebook"></a><p class="title"><b>Figure 8.12. Notebook</b></p>
<div class="figure-contents"><div class="screenshot"><div><img src="figures/notebook.png" alt="Notebook"></div></div></div>
</div>
<br class="figure-break"><p><a class="ulink" href="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/notebook/?h=master" target="_top">Source Code</a></p>
<p>File: <code class="filename">examplewindow.h</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();
  void on_notebook_switch_page(Gtk::Widget* page, guint page_num);

  //Child widgets:
  Gtk::Box m_VBox;
  Gtk::Notebook m_Notebook;
  Gtk::Label m_Label1, m_Label2;

  Gtk::ButtonBox m_ButtonBox;
  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</pre>
<p>File: <code class="filename">examplewindow.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_VBox(Gtk::ORIENTATION_VERTICAL),
  m_Label1("Contents of tab 1"),
  m_Label2("Contents of tab 2"),
  m_Button_Quit("Quit")
{
  set_title("Gtk::Notebook example");
  set_border_width(10);
  set_default_size(400, 200);


  add(m_VBox);

  //Add the Notebook, with the button underneath:
  m_Notebook.set_border_width(10);
  m_VBox.pack_start(m_Notebook);
  m_VBox.pack_start(m_ButtonBox, Gtk::PACK_SHRINK);

  m_ButtonBox.pack_start(m_Button_Quit, Gtk::PACK_SHRINK);
  m_Button_Quit.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );

  //Add the Notebook pages:
  m_Notebook.append_page(m_Label1, "First");
  m_Notebook.append_page(m_Label2, "Second");

  m_Notebook.signal_switch_page().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_notebook_switch_page) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

void ExampleWindow::on_notebook_switch_page(Gtk::Widget* /* page */, guint page_num)
{
  std::cout &lt;&lt; "Switched to tab with index " &lt;&lt; page_num &lt;&lt; std::endl;

  //You can also use m_Notebook.get_current_page() to get this index.
}
</pre>
<p>File: <code class="filename">main.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</pre>
</div>
</div>
<div class="sect2" title="Assistant">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec-assistant"></a>Assistant</h3></div></div></div>
<p>
An <code class="classname">Assistant</code> splits a complex operation into steps. Each step is a page, containing a header, a child widget and an action area. The Assistant's action area has navigation buttons which update automatically depending on the type of the page, set with <code class="methodname">set_page_type()</code>.
</p>
<p>
Use the <code class="methodname">append_page()</code>, <code class="methodname">prepend_page</code> and <code class="methodname">insert_page()</code> methods to add pages to the <code class="classname">Assistant</code>, supplying the child widget for each page.
</p>
<p>
To determine the currently-visible page, use the <code class="methodname">get_current_page()</code> method, and pass the result to <code class="methodname">get_nth_page()</code>, which returns a pointer to the actual widget. To programmatically change the current page, use the <code class="methodname">set_current_page()</code> method.
</p>
<p>
To set the title of a page, use the <code class="methodname">set_page_title()</code> method. The header and side images of a page can be set with the <code class="methodname">set_page_header_image()</code> and <code class="methodname">set_page_side_image()</code> methods.
</p>
<p>
To add widgets to the action area, use the <code class="methodname">add_action_widget()</code> method. They will be packed alongside the default buttons. Use the <code class="methodname">remove_action_widget()</code> method to remove widgets.
</p>
<p><a class="ulink" href="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Assistant.html" target="_top">Reference</a></p>
<div class="sect3" title="Example">
<div class="titlepage"><div><div><h4 class="title">
<a name="assistant-example"></a>Example</h4></div></div></div>
<div class="figure">
<a name="figure-assistant"></a><p class="title"><b>Figure 8.13. Assistant</b></p>
<div class="figure-contents"><div class="screenshot"><div><img src="figures/assistant.png" alt="Assistant"></div></div></div>
</div>
<br class="figure-break"><p><a class="ulink" href="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/assistant/?h=master" target="_top">Source Code</a></p>
<p>File: <code class="filename">exampleassistant.h</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#ifndef GTKMM_EXAMPLEASSISTANT_H
#define GTKMM_EXAMPLEASSISTANT_H

#include &lt;gtkmm.h&gt;

class ExampleAssistant : public Gtk::Assistant
{
public:
  ExampleAssistant();
  virtual ~ExampleAssistant();

  void get_result(bool&amp; check_state, Glib::ustring&amp; entry_text);

private:
  // Signal handlers:
  void on_assistant_apply();
  void on_assistant_cancel();
  void on_assistant_close();
  void on_assistant_prepare(Gtk::Widget* widget);
  void on_entry_changed();

  // Member functions:
  void print_status();

  // Child widgets:
  Gtk::Box m_box;
  Gtk::Label m_label1, m_label2;
  Gtk::CheckButton m_check;
  Gtk::Entry m_entry;
};

#endif /* GTKMM_EXAMPLEASSISTANT_H */
</pre>
<p>File: <code class="filename">examplewindow.h</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include "exampleassistant.h"
#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

private:
  // Signal handlers:
  void on_button_clicked();
  void on_assistant_apply();

  // Child widgets:
  Gtk::Table m_table;
  Gtk::Button m_button;
  Gtk::Label m_label1, m_label2;
  Gtk::CheckButton m_check;
  Gtk::Entry m_entry;
  ExampleAssistant m_assistant;
};

#endif /* GTKMM_EXAMPLEWINDOW_H */
</pre>
<p>File: <code class="filename">examplewindow.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include "examplewindow.h"
#include "exampleassistant.h"

ExampleWindow::ExampleWindow()
: m_table(3, 2),
  m_button("Show the assistant"),
  m_label1("State of assistant checkbutton:"),
  m_label2("Contents of assistant entry:")
{
  set_title("Gtk::Assistant example");
  set_border_width(12);

  m_table.attach(m_button, 0, 2, 0, 1, Gtk::FILL, Gtk::EXPAND);
  m_table.attach(m_label1, 0, 1, 1, 2, Gtk::FILL, Gtk::EXPAND);
  m_table.attach(m_label2, 0, 1, 2, 3, Gtk::FILL, Gtk::EXPAND);
  m_table.attach(m_check, 1, 2, 1, 2);
  m_table.attach(m_entry, 1, 2, 2, 3);
  add(m_table);

  m_label1.set_alignment(0.0, 0.5);
  m_label2.set_alignment(0.0, 0.5);

  m_button.signal_clicked().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_button_clicked));
  m_assistant.signal_apply().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_assistant_apply));

  m_check.set_sensitive(false);
  m_entry.set_sensitive(false);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_assistant_apply()
{
  bool check_state;
  Glib::ustring entry_text;

  m_assistant.get_result(check_state, entry_text);
  m_check.set_active(check_state);
  m_entry.set_text(entry_text);
}

void ExampleWindow::on_button_clicked()
{
  m_assistant.show();
}
</pre>
<p>File: <code class="filename">main.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  // Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</pre>
<p>File: <code class="filename">exampleassistant.cc</code> (For use with gtkmm 3, not gtkmm 2)
</p>
<pre class="programlisting">
#include &lt;iostream&gt;
#include "exampleassistant.h"

ExampleAssistant::ExampleAssistant()
: m_box(Gtk::ORIENTATION_HORIZONTAL, 12),
  m_label1("Type text to allow the assistant to continue:"),
  m_label2("Confirmation page"),
  m_check("Optional extra information")
{
  set_title("Gtk::Assistant example");
  set_border_width(12);
  set_default_size(400, 300);

  m_box.pack_start(m_label1);
  m_box.pack_start(m_entry);

  append_page(m_box);
  append_page(m_check);
  append_page(m_label2);

  set_page_title(*get_nth_page(0), "Page 1");
  set_page_title(*get_nth_page(1), "Page 2");
  set_page_title(*get_nth_page(2), "Confirmation");

  set_page_complete(m_check, true);
  set_page_complete(m_label2, true);

  set_page_type(m_box, Gtk::ASSISTANT_PAGE_INTRO);
  set_page_type(m_label2, Gtk::ASSISTANT_PAGE_CONFIRM);

  signal_apply().connect(sigc::mem_fun(*this,
    &amp;ExampleAssistant::on_assistant_apply));
  signal_cancel().connect(sigc::mem_fun(*this,
    &amp;ExampleAssistant::on_assistant_cancel));
  signal_close().connect(sigc::mem_fun(*this,
    &amp;ExampleAssistant::on_assistant_close));
  signal_prepare().connect(sigc::mem_fun(*this,
    &amp;ExampleAssistant::on_assistant_prepare));

  m_entry.signal_changed().connect(sigc::mem_fun(*this,
    &amp;ExampleAssistant::on_entry_changed));

  show_all_children();
}

ExampleAssistant::~ExampleAssistant()
{
}

void ExampleAssistant::get_result(bool&amp; check_state, Glib::ustring&amp; entry_text)
{
  check_state = m_check.get_active();
  entry_text = m_entry.get_text();
}

void ExampleAssistant::on_assistant_apply()
{
  std::cout &lt;&lt; "Apply was clicked";
  print_status();
}

void ExampleAssistant::on_assistant_cancel()
{
  std::cout &lt;&lt; "Cancel was clicked";
  print_status();
  hide();
}

void ExampleAssistant::on_assistant_close()
{
  std::cout &lt;&lt; "Assistant was closed";
  print_status();
  hide();
}

void ExampleAssistant::on_assistant_prepare(Gtk::Widget* /* widget */)
{
  set_title(Glib::ustring::compose("Gtk::Assistant example (Page %1 of %2)",
    get_current_page() + 1, get_n_pages()));
}

void ExampleAssistant::on_entry_changed()
{
  // The page is only complete if the entry contains text.
  if(m_entry.get_text_length())
    set_page_complete(m_box, true);
  else
    set_page_complete(m_box, false);
}

void ExampleAssistant::print_status()
{
  std::cout &lt;&lt; ", entry contents: \"" &lt;&lt; m_entry.get_text()
    &lt;&lt; "\", checkbutton status: " &lt;&lt; m_check.get_active() &lt;&lt; std::endl;
}
</pre>
</div>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="chapter-container-widgets.html"><img src="icons/prev.png" alt="Prev"></a> </td>
<td width="20%" align="center"><a accesskey="u" href="chapter-container-widgets.html"><img src="icons/up.png" alt="Up"></a></td>
<td width="40%" align="right"> <a accesskey="n" href="chapter-treeview.html"><img src="icons/next.png" alt="Next"></a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Chapter 8. Container Widgets </td>
<td width="20%" align="center"><a accesskey="h" href="index.html"><img src="icons/home.png" alt="Home"></a></td>
<td width="40%" align="right" valign="top"> Chapter 9. The TreeView widget</td>
</tr>
</table>
</div>
</body>
</html>
